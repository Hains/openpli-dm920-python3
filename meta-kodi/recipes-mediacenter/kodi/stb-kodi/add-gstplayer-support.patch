From b66416461d1445251c1d6b03ab0dbc43e97590c5 Mon Sep 17 00:00:00 2001
From: "emanuel@ihad.de" <emanuel@ihad.de>
Date: Sat, 17 Mar 2018 19:48:17 +0100
Subject: [PATCH 3/5] add gstplayer support

---
 Makefile.in                                   |    1 +
 configure.ac                                  |   56 +
 system/keymaps/gen.xml                        |   73 +
 system/playercorefactory.xml                  |   22 +-
 xbmc/Application.cpp                          |   40 +-
 xbmc/ApplicationPlayer.cpp                    |    9 +-
 xbmc/cores/GstPlayer/CMakeLists.txt           |    9 +
 xbmc/cores/GstPlayer/GstPlayer.cpp            |  769 +++++++++++
 xbmc/cores/GstPlayer/GstPlayer.h              |  170 +++
 xbmc/cores/GstPlayer/GstPlayerAudio.cpp       |  120 ++
 xbmc/cores/GstPlayer/GstPlayerAudio.h         |   43 +
 xbmc/cores/GstPlayer/GstPlayerVideo.cpp       | 1176 +++++++++++++++++
 xbmc/cores/GstPlayer/GstPlayerVideo.h         |  170 +++
 xbmc/cores/GstPlayer/Makefile                 |    8 +
 .../DVDInputStreams/DVDInputStreamMemory.h    |    1 +
 .../DVDInputStreamPVRManager.cpp              |   30 +-
 .../DVDInputStreamPVRManager.h                |    6 +
 .../playercorefactory/PlayerCoreConfig.h      |   10 +
 .../playercorefactory/PlayerCoreFactory.cpp   |   15 +
 xbmc/dialogs/GUIDialogBusy.cpp                |    9 +-
 xbmc/pvr/PVRManager.cpp                       |    6 +-
 xbmc/settings/AdvancedSettings.cpp            |    2 +-
 xbmc/video/windows/GUIWindowFullScreen.cpp    |   38 +-
 23 files changed, 2755 insertions(+), 28 deletions(-)
 create mode 100644 system/keymaps/gen.xml
 create mode 100644 xbmc/cores/GstPlayer/CMakeLists.txt
 create mode 100644 xbmc/cores/GstPlayer/GstPlayer.cpp
 create mode 100644 xbmc/cores/GstPlayer/GstPlayer.h
 create mode 100644 xbmc/cores/GstPlayer/GstPlayerAudio.cpp
 create mode 100644 xbmc/cores/GstPlayer/GstPlayerAudio.h
 create mode 100644 xbmc/cores/GstPlayer/GstPlayerVideo.cpp
 create mode 100644 xbmc/cores/GstPlayer/GstPlayerVideo.h
 create mode 100644 xbmc/cores/GstPlayer/Makefile

diff --git a/Makefile.in b/Makefile.in
index 984fd00091..955890f0ea 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -40,6 +40,7 @@ DIRECTORY_ARCHIVES=$(VideoPlayer_ARCHIVES) \
                    xbmc/cores/DllLoader/exports/exports.a \
                    xbmc/cores/DllLoader/exports/util/exports_utils.a \
                    xbmc/cores/ExternalPlayer/ExternalPlayer.a \
+                   xbmc/cores/GstPlayer/GstPlayer.a \
                    xbmc/cores/VideoPlayer/VideoRenderers/VideoRenderer.a \
                    xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoShaders.a \
                    xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/HwDecRender.a \
diff --git a/configure.ac b/configure.ac
index 629929aafa..91b2481cd6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -198,6 +198,8 @@ libcap_disabled="== Capabilities detection support disabled. =="
 libcap_not_found="== Could not find libcap. Capabilities detection support disabled. =="
 gtest_enabled="== Google Test Framework will be configured. =="
 gtest_disabled="== Google Test Framework will not be configured. =="
+gstreamer_not_found="== GStreamer libraries not found. GStreamer support disabled. =="
+gstreamer_disabled="== GStreamer support manually disabled. =="
 
 libudev_not_found="== Could not find libudev. Will use polling to check for device changes. =="
 libudev_disabled="== udev support disabled. Will use polling to check for device changes. =="
@@ -274,6 +276,12 @@ AC_ARG_ENABLE([openmax],
   [use_openmax=$enableval],
   [use_openmax=auto])
 
+AC_ARG_ENABLE([gstreamer],
+  [AS_HELP_STRING([--enable-gstreamer],
+  [enable GStreamer support (default is auto)])],
+  [use_gstreamer=$enableval],
+  [use_gstreamer=auto])
+ 
 AC_ARG_ENABLE([tegra],
   [AS_HELP_STRING([--enable-tegra],
   [enable Tegra2 arm (default is no)])],
@@ -1774,6 +1782,53 @@ if test "${USE_STATIC_FFMPEG}" = "1"; then
   LIBS=$(${ECHO} ${LIBS} | ${SED} ':a;N;$!ba;s/\n/ /g')
 fi
 
+# GSTREAMER
+if test "x$use_gstreamer" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    if test "x$use_gstreamer" = "xyes"; then
+      AC_MSG_ERROR([GStreamer not supported on this platform])
+    else
+      use_gstreamer="no"
+      AC_MSG_NOTICE($gstreamer_disabled)
+    fi
+    USE_GSTREAMER=0
+  else
+    AC_SUBST(gst_pbutils, 1.0)
+    AC_SUBST(gstreamer_req, 1.0)
+    AC_SUBST(gstreamer_base_req, 1.0)
+    AC_SUBST(gstreamer_plugins_base_req, 1.0)
+    PKG_CHECK_MODULES(GSTREAMER, gstreamer-1.0 >= $gstreamer_req, HAVE_GSTREAMER=1, HAVE_GSTREAMER=0)
+    PKG_CHECK_MODULES(GSTREAMER_BASE, gstreamer-base-1.0 >= $gstreamer_base_req, HAVE_GSTREAMER_BASE=1, HAVE_GSTREAMER_BASE=0)
+    PKG_CHECK_MODULES(GSTREAMER_PLUGINS_BASE, gstreamer-plugins-base-1.0 >= $gstreamer_plugins_base_req, HAVE_GSTREAMER_PLUGINS_BASE=1, HAVE_GSTREAMER_PLUGINS_BASE=0)
+    PKG_CHECK_MODULES(GST_PBU, gstreamer-pbutils-1.0 >= $gst_pbutils, HAVE_GST_PBU=1, HAVE_GST_PBU=0)
+    
+
+    if test $HAVE_GSTREAMER -eq 1 -a $HAVE_GSTREAMER_BASE -eq 1 -a $HAVE_GSTREAMER_PLUGINS_BASE -eq 1 -a $HAVE_GST_PBU -eq 1; then
+      INCLUDES="$INCLUDES $GSTREAMER_CFLAGS $GSTREAMER_BASE_CFLAGS $GSTREAMER_PLUGINS_BASE_CFLAGS $GST_PBU_CFLAGS"
+      LIBS="$LIBS $GSTREAMER_LIBS $GSTREAMER_BASE_LIBS $GSTREAMER_PLUGINS_BASE_LIBS $GST_PBU_LIBS"
+      USE_GSTREAMER=1
+      AC_DEFINE([HAVE_LIBGSTREAMER], [1], [Define to 1 if you have the 'GStreamer' library.])
+    else
+      if test "x$use_gstreamer" = "xyes"; then
+        AC_MSG_ERROR([$gstreamer_not_found])
+      else
+        use_gstreamer="no"
+        USE_GSTREAMER=0
+        AC_MSG_RESULT($gstreamer_not_found)
+      fi
+    fi
+  fi
+else
+  USE_GSTREAMER=0
+  AC_MSG_NOTICE($gstreamer_disabled)
+fi
+
+if test "$use_gstreamer" != "no"; then
+  final_message="$final_message\n  GStreamer:\tYes"
+else
+  final_message="$final_message\n  GStreamer:\tNo"
+fi
+
 echo "Checking for SWIG installation"
 AC_PATH_PROG(SWIG_EXE, swig, "none")
 if test "$SWIG_EXE" = "none"; then
@@ -2450,6 +2505,7 @@ AC_SUBST(USE_LIBSMBCLIENT)
 AC_SUBST(USE_LIBNFS)
 AC_SUBST(USE_AIRPLAY)
 AC_SUBST(USE_OPENMAX)
+AC_SUBST(USE_GSTREAMER)
 AC_SUBST(USE_PULSE)
 AC_SUBST(HAVE_LIBPULSE)
 AC_SUBST(USE_ALSA)
diff --git a/system/keymaps/gen.xml b/system/keymaps/gen.xml
new file mode 100644
index 0000000000..6f32a755fa
--- /dev/null
+++ b/system/keymaps/gen.xml
@@ -0,0 +1,73 @@
+<keymap>
+  <global>
+    <keyboard>
+      <key id="61596">mute</key>
+      <key id="61625">volumeup</key>
+      <key id="61597">volumedown</key>
+      <key id="61588">info</key>
+    </keyboard>
+  </global>
+  <music>
+    <keyboard>
+      <key id="61625">volumeup</key>
+      <key id="61596">mute</key>
+      <key id="61597">volumedown</key>
+    </keyboard>
+  </music>
+  <videos>
+    <keyboard>
+      <key id="61568">up</key>
+      <key id="61569">down</key>
+      <key id="61572">pageup</key>
+      <key id="61573">pagedown</key>
+      <key id="61520">parentfolder</key>
+      <key id="61453">select</key>
+      <key id="61588">info</key>
+      <key id="61589">contextmenu</key>
+      <key id="61510">firstpage</key>
+      <key id="61516">lastpage</key>
+      <key id="61520">playpause</key>
+      <key id="61523">stop</key>
+      <key id="61626">skipnext</key>
+      <key id="61627">skipprevious</key>
+      <key id="61588">osd</key>
+      <key id="61596">mute</key>
+      <key id="61625">volumeup</key>
+      <key id="61597">volumedown</key>
+      <key id="61571">nextpicture</key>
+      <key id="61570">previouspicture</key>
+      <key id="61570">left</key><key id="61571">right</key>
+      <key id="61489">smallstepback</key>
+      <key id="61492">stepback</key>
+      <key id="61494">stepforward</key>
+      <key id="61497">bigstepforward</key>
+      <key id="61495">bigstepback</key>
+      <key id="61626">fastforward</key>
+      <key id="61627">rewind</key>
+    </keyboard>
+  </videos>
+  <osdaudiosettings>
+    <keyboard>
+      <key id="61596">mute</key>
+      <key id="61625">volumeup</key>
+      <key id="61597">volumedown</key>
+      <key id="61626">skipnext</key>
+      <key id="61627">skipprevious</key>
+    </keyboard>
+  </osdaudiosettings>
+  <fullscreenvideo>
+    <keyboard>
+      <key id="61568">up</key>
+      <key id="61569">down</key>
+      <key id="61572">pageup</key>
+      <key id="61573">pagedown</key>
+      <key id="61576">firstpage</key>
+      <key id="61577">lastpage</key>
+      <key id="61571">nextpicture</key>
+      <key id="61570">previouspicture</key>
+      <key id="61596">mute</key>
+      <key id="61625">volumeup</key>
+      <key id="61597">volumedown</key>
+    </keyboard>
+  </fullscreenvideo>
+</keymap>
diff --git a/system/playercorefactory.xml b/system/playercorefactory.xml
index be6b7219ab..1bebba4a54 100644
--- a/system/playercorefactory.xml
+++ b/system/playercorefactory.xml
@@ -11,30 +11,30 @@
   </players>
 
   <rules name="system rules">
-    <rule name="mms/udp" protocols="mms|mmsh|udp" player="VideoPlayer" />
+    <rule name="mms/udp" protocols="mms|mmsh|udp" player="GstPlayer" />
     <rule name="lastfm/shout" protocols="lastfm|shout" player="PAPlayer" />
     <rule name="rtmp" protocols="rtmp" player="videodefaultplayer" />
 
-    <!-- VideoPlayer can play standard rtsp streams -->
+    <!-- GstPlayer can play standard rtsp streams -->
     <rule name="rtsp" protocols="rtsp" filetypes="!(rm|ra)"  player="PAPlayer" />
 
     <!-- Internet streams -->
     <rule name="streams" internetstream="true">
-      <rule name="aacp/sdp" mimetypes="audio/aacp|application/sdp" player="VideoPlayer" />
+      <rule name="aacp/sdp" mimetypes="audio/aacp|application/sdp" player="GstPlayer" />
       <rule name="mp2" mimetypes="application/octet-stream" filetypes="mp2" player="PAPlayer" />
     </rule>
 
     <!-- DVDs -->
-    <rule name="dvd" dvd="true" player="VideoPlayer" />
-    <rule name="dvdimage" dvdimage="true" player="VideoPlayer" />
+    <rule name="dvd" dvd="true" player="GstPlayer" />
+    <rule name="dvdimage" dvdimage="true" player="GstPlayer" />
 
-    <!-- Only VideoPlayer can handle these normally -->
-    <rule name="sdp/asf" filetypes="sdp|asf" player="VideoPlayer" />
+    <!-- Only GstPlayer can handle these normally -->
+    <rule name="sdp/asf" filetypes="sdp|asf" player="GstPlayer" />
 
-    <!-- Pass these to VideoPlayer as we do not know if they are audio or video -->
-    <rule name="nsv" filetypes="nsv" player="VideoPlayer" />
+    <!-- Pass these to GstPlayer as we do not know if they are audio or video -->
+    <rule name="nsv" filetypes="nsv" player="GstPlayer" />
 
-    <!-- pvr radio channels should be played by VideoPlayer because they need buffering -->
-    <rule name="radio" filetypes="pvr" filename=".*/radio/.*" player="VideoPlayer" />
+    <!-- pvr radio channels should be played by GstPlayer because they need buffering -->
+    <rule name="radio" filetypes="pvr" filename=".*/radio/.*" player="GstPlayer" />
   </rules>
 </playercorefactory>
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a2448dc49e..054acd53bb 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -3297,13 +3297,16 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
   // if we have a stacked set of files, we need to setup our stack routines for
   // "seamless" seeking and total time of the movie etc.
   // will recall with restart set to true
-  if (item.IsStack())
+  if (item.IsStack()) {
+	      CLog::Log(LOGNOTICE, "CApplication::%s: item.IsStack()", __FUNCTION__);
     return PlayStack(item, bRestart);
+  }
 
   CPlayerOptions options;
 
   if( item.HasProperty("StartPercent") )
   {
+	  CLog::Log(LOGNOTICE, "CApplication::%s: item.HasProperty(StartPercent)", __FUNCTION__);
     double fallback = 0.0f;
     if(item.GetProperty("StartPercent").isString())
       fallback = (double)atof(item.GetProperty("StartPercent").asString().c_str());
@@ -3312,6 +3315,7 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
 
   if (bRestart)
   {
+	  CLog::Log(LOGNOTICE, "CApplication::%s: bRestart", __FUNCTION__);
     // have to be set here due to playstack using this for starting the file
     options.starttime = item.m_lStartOffset / 75.0;
     if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_itemCurrentFile->m_lStartOffset != 0)
@@ -3319,11 +3323,13 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
   }
   else
   {
+	  	  CLog::Log(LOGNOTICE, "CApplication::%s: no bRestart", __FUNCTION__);
     options.starttime = item.m_lStartOffset / 75.0;
     LoadVideoSettings(item);
 
     if (item.IsVideo())
     {
+	    CLog::Log(LOGNOTICE, "CApplication::%s: item.IsVideo()", __FUNCTION__);
       // open the d/b and retrieve the bookmarks for the current movie
       CVideoDatabase dbs;
       dbs.Open();
@@ -3395,10 +3401,12 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
   if (item.IsVideo() && playlist == PLAYLIST_VIDEO && g_playlistPlayer.GetPlaylist(playlist).size() > 1)
   { // playing from a playlist by the looks
     // don't switch to fullscreen if we are not playing the first item...
+	  CLog::Log(LOGNOTICE, "CApplication::%s: (item.IsVideo() && playlist == PLAYLIST_VIDEO && g_playlistPlayer.GetPlaylist(playlist).size() > 1", __FUNCTION__);
     options.fullscreen = !g_playlistPlayer.HasPlayedFirstFile() && g_advancedSettings.m_fullScreenOnMovieStart && !CMediaSettings::GetInstance().DoesVideoStartWindowed();
   }
   else if(m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
   {
+	  CLog::Log(LOGNOTICE, "CApplication::%s: m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0", __FUNCTION__);
     //! @todo - this will fail if user seeks back to first file in stack
     if(m_currentStackPosition == 0 || m_itemCurrentFile->m_lStartOffset == STARTOFFSET_RESUME)
       options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !CMediaSettings::GetInstance().DoesVideoStartWindowed();
@@ -3407,8 +3415,10 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
     // reset this so we don't think we are resuming on seek
     m_itemCurrentFile->m_lStartOffset = 0;
   }
-  else
+  else {
+	  CLog::Log(LOGNOTICE, "CApplication::%s: else m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0", __FUNCTION__);
     options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !CMediaSettings::GetInstance().DoesVideoStartWindowed();
+  }
 
   // reset VideoStartWindowed as it's a temp setting
   CMediaSettings::GetInstance().SetVideoStartWindowed(false);
@@ -3455,7 +3465,6 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
   m_ePlayState = PLAY_STATE_STARTING;
 
   m_pPlayer->CreatePlayer(newPlayer, *this);
-
   PlayBackRet iResult;
   if (m_pPlayer->HasPlayer())
   {
@@ -3487,24 +3496,37 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
 
     if(m_pPlayer->IsPlayingAudio())
     {
-      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+	    CLog::Log(LOGNOTICE, "CApplication::%s: m_pPlayer->IsPlayingAudio()", __FUNCTION__);
+      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO) {
+	      CLog::Log(LOGNOTICE, "CApplication::%s: g_windowManager.ActivateWindow(WINDOW_VISUALISATION);", __FUNCTION__);
         g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+      }
     }
 
 #ifdef HAS_VIDEO_PLAYBACK
     else if(m_pPlayer->IsPlayingVideo())
     {
+	    CLog::Log(LOGNOTICE, "CApplication::%s: m_pPlayer->IsPlayingVideo()", __FUNCTION__);
+	    CLog::Log(LOGNOTICE, "CApplication::%s: options.fullscreen=%s", __FUNCTION__, options.fullscreen == true ? "true":"false");
+	    CLog::Log(LOGNOTICE, "CApplication::%s: m_pPlayer->IsRenderingVideo()=%s", __FUNCTION__, m_pPlayer->IsRenderingVideo() == true ? "true":"false");
+	    CLog::Log(LOGNOTICE, "CApplication::%s: g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO=%s", __FUNCTION__, g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO == true ? "true":"false");
+	    
       // if player didn't manage to switch to fullscreen by itself do it here
       if (options.fullscreen && m_pPlayer->IsRenderingVideo() &&
-          g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
+          g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO ) {
+	      CLog::Log(LOGNOTICE, "CApplication::%s: SwitchToFullScreen(true);", __FUNCTION__);
        SwitchToFullScreen(true);
+      }
     }
 #endif
     else
     {
+	    CLog::Log(LOGNOTICE, "CApplication::%s: no video no audio", __FUNCTION__);
       if (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION ||
-          g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+          g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO) {
+	      CLog::Log(LOGNOTICE, "CApplication::%s: g_windowManager.PreviousWindow()", __FUNCTION__);
         g_windowManager.PreviousWindow();
+      }
     }
 
 #if !defined(TARGET_POSIX)
@@ -3527,6 +3549,7 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
     switch (m_ePlayState)
     {
       case PLAY_STATE_PLAYING:
+	CLog::Log(LOGNOTICE, "CApplication::%s: PLAY_STATE_PLAYING", __FUNCTION__);
         OnPlayBackStarted();
         break;
       // FIXME: it seems no meaning to callback started here if there was an started callback
@@ -3534,17 +3557,21 @@ PlayBackRet CApplication::PlayFile(CFileItem item, const std::string& player, bo
       //        first, it will delay send OnPlay announce, but then we callback stopped/ended
       //        which will send OnStop announce at once, so currently, just call stopped/ended.
       case PLAY_STATE_ENDED:
+	CLog::Log(LOGNOTICE, "CApplication::%s: PLAY_STATE_ENDED", __FUNCTION__);
         OnPlayBackEnded();
         break;
       case PLAY_STATE_STOPPED:
+	CLog::Log(LOGNOTICE, "CApplication::%s: PLAY_STATE_STOPPED", __FUNCTION__);
         OnPlayBackStopped();
         break;
       case PLAY_STATE_STARTING:
+	CLog::Log(LOGNOTICE, "CApplication::%s: PLAY_STATE_STARTING", __FUNCTION__);
         // neither started nor stopped/ended callback be called, that means the item still
         // not started, we need not make up any callback, just leave this and
         // let the player callback do its work.
         break;
       default:
+	CLog::Log(LOGNOTICE, "CApplication::%s: PLAY_STATE_UNKNOWN", __FUNCTION__);
         break;
     }
   }
@@ -4864,6 +4891,7 @@ double CApplication::GetTime() const
 // consistent with GetTime() and GetTotalTime().
 void CApplication::SeekTime( double dTime )
 {
+	CLog::Log(LOGNOTICE, "%s: dTime=%f", __FUNCTION__, dTime);
   if (m_pPlayer->IsPlaying() && (dTime >= 0.0))
   {
     if (!m_pPlayer->CanSeek()) return;
diff --git a/xbmc/ApplicationPlayer.cpp b/xbmc/ApplicationPlayer.cpp
index 9163bae34b..03bdec6f82 100644
--- a/xbmc/ApplicationPlayer.cpp
+++ b/xbmc/ApplicationPlayer.cpp
@@ -25,6 +25,8 @@
 #include "PlayListPlayer.h"
 #include "settings/MediaSettings.h"
 
+#include "utils/log.h"
+
 CApplicationPlayer::CApplicationPlayer()
 {
   m_iPlayerOPSeq = 0;
@@ -64,7 +66,11 @@ void CApplicationPlayer::ClosePlayerGapless(std::string &playername)
   if (!player)
     return;
 
-  bool gaplessSupported = player->m_type == "music" || player->m_type == "video";
+#if defined(HAVE_LIBGSTREAMER)
+    bool gaplessSupported = player->m_type == "music" || player->m_type == "video" || player->m_type == "gstreamer";
+#else
+    bool gaplessSupported = player->m_type == "music" || player->m_type == "video";
+#endif
   gaplessSupported = gaplessSupported && (playername == player->m_name);
   if (!gaplessSupported)
   {
@@ -120,6 +126,7 @@ PlayBackRet CApplicationPlayer::OpenFile(const CFileItem& item, const CPlayerOpt
     m_subtitleStreamUpdate.SetExpired();
     m_speedUpdate.SetExpired();
   }
+  CLog::Log(LOGNOTICE, "CApplicationPlayer::%s: iResult=%d %s", __FUNCTION__, iResult, iResult == PLAYBACK_CANCELED ? "PLAYBACK_CANCELED":"PLAYBACK_OK?" ); 
   return iResult;
 }
 
diff --git a/xbmc/cores/GstPlayer/CMakeLists.txt b/xbmc/cores/GstPlayer/CMakeLists.txt
new file mode 100644
index 0000000000..a40d69bb34
--- /dev/null
+++ b/xbmc/cores/GstPlayer/CMakeLists.txt
@@ -0,0 +1,9 @@
+set(SOURCES GstPlayer.cpp
+            GstPlayerAudio.cpp
+            GstPlayerVideo.cpp)
+
+set(HEADERS GstPlayer.h
+            GstPlayerAudio.h
+            GstPlayerVideo.h)
+
+core_add_library(gstplayer)
diff --git a/xbmc/cores/GstPlayer/GstPlayer.cpp b/xbmc/cores/GstPlayer/GstPlayer.cpp
new file mode 100644
index 0000000000..c5add8dc02
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayer.cpp
@@ -0,0 +1,769 @@
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GstPlayer.h"
+#include "GstPlayerVideo.h"
+#include "GstPlayerAudio.h"
+
+#include "system.h"
+#include "Util.h"
+#include "FileItem.h"
+#include "Application.h"
+#include "ServiceBroker.h"
+#include "CompileInfo.h"
+#include "GUIInfoManager.h"
+#include "URL.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/XMLUtils.h"
+#include "utils/log.h"
+#include "cores/DataCacheCore.h"
+#include "input/InputManager.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+#include "threads/SystemClock.h"
+#include "threads/SingleLock.h"
+#include "windowing/WindowingFactory.h"
+#include "guilib/GUIWindowManager.h"
+#include "filesystem/MusicDatabaseFile.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "pvr/PVRManager.h"
+
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+
+#include "cores/VideoPlayer/VideoPlayer.h"
+
+#include "cores/AudioEngine/AEFactory.h"
+
+#include "cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h"
+#include "settings/MediaSettings.h"
+#include "storage/MediaManager.h"
+
+using namespace PVR;
+using namespace XFILE;
+
+// Default time after which the item's playcount is incremented
+#define DEFAULT_PLAYCOUNT_MIN_TIME 10
+
+CGstPlayer::CGstPlayer(IPlayerCallback& callback)
+	: IPlayer(callback)
+	,CThread("GstPlayer")
+	,m_bAbortRequest(false)
+	,m_isRecording(false)
+	,m_playbackStartTime(0)
+	,m_playCountMinTime(DEFAULT_PLAYCOUNT_MIN_TIME)
+	,m_speed(1)
+	,m_totalTime(1)
+	,m_time(0)
+	,m_ready(true)
+//	,m_messenger("player")
+{
+	m_pInputStream = NULL;
+	m_canTempo = false;
+	m_processInfo.reset(CProcessInfo::CreateInstance());
+	
+	CAEFactory::Suspend();
+	  
+	while (!CAEFactory::IsSuspended())
+		Sleep(10);
+	
+	CreatePlayers();
+}
+
+void CGstPlayer::CreatePlayers()
+{
+	m_VideoPlayerAudio = new CGstPlayerAudio(*m_processInfo);
+	m_VideoPlayerVideo = new CGstPlayerVideo(this, *m_processInfo);
+}
+
+void CGstPlayer::DestroyPlayers()
+{
+	delete m_VideoPlayerVideo;
+	delete m_VideoPlayerAudio;
+}
+
+CGstPlayer::~CGstPlayer()
+{
+	CloseFile();
+	
+	SAFE_DELETE(m_pInputStream);
+	
+	DestroyPlayers();
+	
+	CAEFactory::Resume();
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s", __FUNCTION__ );
+}
+
+bool CGstPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
+{
+	if (IsPlaying())
+		CloseFile();
+	
+	m_bAbortRequest = false;
+	m_PlayerOptions = options;
+	m_item = file;
+	// Try to resolve the correct mime type
+	m_item.SetMimeTypeForInternetFile();
+	m_ready.Reset();
+	
+	Create();
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer%s: CGUIDialogBusy::WaitOnEvent", __FUNCTION__);
+	CGUIDialogBusy::WaitOnEvent(m_ready, g_advancedSettings.m_videoBusyDialogDelay_ms, false);
+	// Playback might have been stopped due to some error
+	if (m_bStop || m_bAbortRequest) {
+		CLog::Log(LOGNOTICE, "CGstPlayer::%s: m_bStop=%s || m_bAbortRequest=%s", __FUNCTION__, m_bStop == true ? "true":"false" ,m_bAbortRequest == true ? "true":"false" ); 
+		CloseFile();
+		return false;
+	}
+	return true;
+}
+
+bool CGstPlayer::CloseFile(bool reopen)
+{
+	m_bAbortRequest = true;
+	
+	g_PVRManager.CloseStream();
+	m_VideoPlayerVideo->CloseStream();
+	
+	if(m_pInputStream)
+		m_pInputStream->Abort();
+	
+	/* wait for the thread to terminate */
+	StopThread(true);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: reopen=%s", __FUNCTION__, reopen == true ? "true":"false");
+
+	return true;
+}
+
+bool CGstPlayer::OpenInputStream()
+{
+	if(m_pInputStream)
+		SAFE_DELETE(m_pInputStream);
+
+	CLog::Log(LOGNOTICE, "Creating InputStream");
+
+	// correct the filename if needed
+	std::string filename(m_item.GetPath());
+	if (URIUtils::IsProtocol(filename, "dvd") ||
+			StringUtils::EqualsNoCase(filename, "iso9660://video_ts/video_ts.ifo"))
+	{
+		m_item.SetPath(g_mediaManager.TranslateDevicePath(""));
+	}
+
+	m_pInputStream = CDVDFactoryInputStream::CreateInputStream(this, m_item, true);
+	if(m_pInputStream == NULL)
+	{
+		CLog::Log(LOGERROR, "CGstPlayer%s: - unable to create input stream for [%s]", __FUNCTION__, CURL::GetRedacted(m_item.GetPath()).c_str());
+		return false;
+	}
+
+	if (!m_pInputStream->Open())
+	{
+		CLog::Log(LOGERROR, "CGstPlayer%s: - error opening [%s]", __FUNCTION__, CURL::GetRedacted(m_item.GetPath()).c_str());
+		return false;
+	}
+
+	// find any available external subtitles for non dvd files
+	if (!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
+	&&	!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)
+	&&	!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+	{
+		// find any available external subtitles
+		std::vector<std::string> filenames;
+		CUtil::ScanForExternalSubtitles(m_item.GetPath(), filenames);
+
+		// load any subtitles from file item
+		std::string key("subtitle:1");
+		for(unsigned s = 1; m_item.HasProperty(key); key = StringUtils::Format("subtitle:%u", ++s))
+			filenames.push_back(m_item.GetProperty(key).asString());
+
+		for(unsigned int i=0;i<filenames.size();i++)
+		{
+			// if vobsub subtitle:
+			if (URIUtils::HasExtension(filenames[i], ".idx"))
+			{
+				std::string strSubFile;
+				if ( CUtil::FindVobSubPair( filenames, filenames[i], strSubFile ) )
+				{
+					CLog::Log(LOGNOTICE, "CGstPlayer%s: - AddSubtitleFile", __FUNCTION__);
+					//AddSubtitleFile(filenames[i], strSubFile);
+				}
+			}
+			else
+			{
+				if ( !CUtil::IsVobSub(filenames, filenames[i] ) )
+				{
+					CLog::Log(LOGNOTICE, "CGstPlayer%s: - AddSubtitleFile", __FUNCTION__);
+					//AddSubtitleFile(filenames[i]);
+				}
+			}
+		} // end loop over all subtitle files
+
+		CMediaSettings::GetInstance().GetCurrentVideoSettings().m_SubtitleCached = true;
+	}
+
+	SetAVDelay(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_AudioDelay);
+	SetSubTitleDelay(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_SubtitleDelay);
+	//m_clock.Reset();
+	//m_dvd.Clear();
+	//m_errorCount = 0;
+	//m_ChannelEntryTimeOut.SetInfinite();
+	
+	if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_FILE))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_FILE", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_DVD", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTTP))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_HTTP", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_MEMORY))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_MEMORY", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_FFMPEG", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_TV", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_MPLS))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_MPLS", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_BLURAY", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_PVRMANAGER", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_MULTIFILES))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_MULTIFILES", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_ADDON))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_ADDON", __FUNCTION__);
+	else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_NONE))
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_NONE", __FUNCTION__);
+	else 
+		CLog::Log(LOGNOTICE, "CGstPlayer%s: DVDSTREAM_TYPE_UNKNOWN", __FUNCTION__);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer%s: m_ready.Set()", __FUNCTION__);
+	m_ready.Set();
+
+	if (CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK) &&
+			!m_pInputStream->IsRealtime())
+		m_canTempo = true;
+	else
+		m_canTempo = false;
+
+	return true;
+}
+
+bool CGstPlayer::SwitchChannel(const CPVRChannelPtr &channel)
+{
+	if (g_PVRManager.IsPlayingChannel(channel))
+		return false; // desired channel already active, nothing to do.
+
+	if (!g_PVRManager.CheckParentalLock(channel))
+		return false;
+
+	/* set GUI info */
+	if (!g_PVRManager.PerformChannelSwitch(channel, true))
+		return false;
+
+	CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+	if (input && input->IsOtherStreamHack())
+	{
+		CLog::Log(LOGWARNING, "CGstPlayer::%s: input->IsOtherStreamHack()", __FUNCTION__);
+	}
+	if (input && input->SelectChannel(channel))
+	{
+		CLog::Log(LOGNOTICE, "CGstPlayer::%s: input->SelectChannel(channel)", __FUNCTION__);
+	}
+	else
+	{
+		CLog::Log(LOGWARNING, "CGstPlayer::%s - failed to switch channel. playback stopped", __FUNCTION__);
+		return false;
+		//CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
+	}
+	
+	//g_PVRManager.SetChannelPreview(false);
+	ShowPVRChannelInfo();
+      
+	return true;
+}
+
+void CGstPlayer::Process()
+{
+	if (!OpenInputStream())
+	{
+		m_bAbortRequest = true;
+		return;
+	}
+	
+	CDVDStreamInfo hint;
+	
+	hint.Clear();
+	hint.filename = m_pInputStream->GetFileName();
+	
+	CURL Url(hint.filename);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer%s: m_pInputStream->GetFileName(): %s", __FUNCTION__, hint.filename.c_str());
+
+	m_playbackStartTime = XbmcThreads::SystemClockMillis();
+	m_time = 0;
+	
+	//m_callback.OnPlayBackStarted();
+
+	if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && 
+		Url.IsLocalHost())
+	{
+		hint.filename = "";
+	}
+	
+	m_VideoPlayerVideo->OpenStream(hint, m_item);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer%s: m_bStop: %s", __FUNCTION__, m_bStop == true ? "true" : "false");
+	
+	m_bStop = true;
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer%s: m_bStop: %s", __FUNCTION__, m_bStop == true ? "true" : "false");
+
+	// We don't want to come back to an active screensaver
+	g_application.ResetScreenSaver();
+	g_application.WakeUpScreenSaverAndDPMS();
+
+	if (g_application.CurrentFileItem().IsStack() || 
+			m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+		m_callback.OnPlayBackStopped();
+	else
+		m_callback.OnPlayBackEnded();
+}
+
+void CGstPlayer::Pause()
+{
+	m_VideoPlayerVideo->Pause();
+}
+
+bool CGstPlayer::HasVideo() const
+{
+	return true;
+}
+
+bool CGstPlayer::HasAudio() const
+{
+	return false;
+}
+
+void CGstPlayer::SwitchToNextLanguage()
+{
+	m_VideoPlayerVideo->SwitchToNextLanguage();
+}
+
+void CGstPlayer::ToggleSubtitles()
+{
+	m_VideoPlayerVideo->ToggleSubtitles();
+}
+
+bool CGstPlayer::CanSeek()
+{
+	return m_VideoPlayerVideo->CanSeek();
+}
+
+void CGstPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
+{
+	m_VideoPlayerVideo->Seek(bPlus, bLargeStep, bChapterOverride);
+}
+
+void CGstPlayer::SwitchToNextAudioLanguage()
+{
+	m_VideoPlayerVideo->SwitchToNextAudioLanguage();
+}
+
+void CGstPlayer::SeekPercentage(float iPercent)
+{
+	m_VideoPlayerVideo->SeekPercentage(iPercent);
+}
+
+float CGstPlayer::GetPercentage()
+{
+	int64_t iTime = GetTime();
+	int64_t iTotalTime = GetTotalTime();
+
+	if (iTotalTime != 0)
+	{
+		//CLog::Log(LOGNOTICE, "CGstPlayer::%s: Percentage=%f", __FUNCTION__ , (iTime * 100 / (float)iTotalTime) );
+		return iTime * 100 / (float)iTotalTime;
+	}
+
+	return 0.0f;
+}
+
+void CGstPlayer::SetAVDelay(float fValue)
+{
+	m_VideoPlayerVideo->SetAVDelay(fValue);
+}
+
+float CGstPlayer::GetAVDelay()
+{
+	return m_VideoPlayerVideo->GetAVDelay();
+}
+
+void CGstPlayer::SetSubTitleDelay(float fValue)
+{
+	m_VideoPlayerVideo->SetSubTitleDelay(fValue);
+}
+
+float CGstPlayer::GetSubTitleDelay()
+{
+	return m_VideoPlayerVideo->GetSubTitleDelay();
+}
+
+void CGstPlayer::SeekTime(int64_t iTime)
+{
+	int seekOffset = (int)(iTime - GetTime());
+	
+	m_VideoPlayerVideo->SeekTime(iTime);
+	m_callback.OnPlayBackSeek((int)iTime, seekOffset);
+}
+
+bool CGstPlayer::SeekTimeRelative(int64_t iTime)
+{
+	bool res = m_VideoPlayerVideo->SeekTimeRelative(iTime);
+	
+	if(res)
+	{
+		int64_t abstime = GetTime() + iTime;
+		m_callback.OnPlayBackSeek((int)abstime, iTime);
+	}
+	
+	return res;
+}
+
+int64_t CGstPlayer::GetTime() // in milliseconds
+{
+	if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+	{
+		CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+		if (input)
+		{
+			return (int64_t)input->GetTime();
+		}
+		else
+			return 0;
+	}
+	else
+		return m_VideoPlayerVideo->GetTime();
+}
+
+int64_t CGstPlayer::GetTotalTime() // in milliseconds
+{
+	if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+	{
+		CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+		if (input)
+		{
+			return (int64_t)input->GetTotalTime();
+		}
+		else
+			return 0;
+	}
+	else
+		return m_VideoPlayerVideo->GetTotalTime();
+}
+
+bool CGstPlayer::CanRecord()
+{
+	if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+	{
+		CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+		if (input)
+		{
+			return input->CanRecord();
+		}
+		else
+			return false;
+	}
+	else
+		return false;
+}
+
+bool CGstPlayer::IsRecording()
+{
+	if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+	{
+		CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+		if (input)
+		{
+			return input->IsRecording();
+		}
+		else
+			return false;
+	}
+	else
+		return false;
+}
+
+void CGstPlayer::SetSpeed(float iSpeed)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: %f", __FUNCTION__, iSpeed);
+	m_speed = static_cast<int>(iSpeed);
+}
+
+float CGstPlayer::GetSpeed()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: %f", __FUNCTION__, m_speed);
+	return m_speed;
+}
+
+void CGstPlayer::ShowOSD(bool bOnoff)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: %s", __FUNCTION__, bOnoff == false ? "false":"true" );
+}
+
+std::string CGstPlayer::GetPlayerState()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s", __FUNCTION__);
+	return "";
+}
+
+bool CGstPlayer::SetPlayerState(const std::string& state)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: state:%s", __FUNCTION__, state.c_str());
+	return true;
+}
+
+bool CGstPlayer::Initialize(TiXmlElement* pConfig)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s", __FUNCTION__);
+	return true;
+}
+
+void CGstPlayer::Render(bool clear, uint32_t alpha, bool gui)
+{
+	//g_Windowing.ClearBuffers(0.0f);
+
+	//CLog::Log(LOGNOTICE, "CGstPlayer::%s: clear=%s, alpha=%d, gui=%s", __FUNCTION__, clear == false ? "false":"true", (int)alpha, gui == false ? "false":"true");
+}
+
+void CGstPlayer::ToggleOSD()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s:", __FUNCTION__);
+}
+
+void CGstPlayer::SetVolume(float volume)
+{
+	m_VideoPlayerAudio->SetVolume(volume);
+}
+
+void CGstPlayer::SetMute(bool bOnOff)
+{
+	m_VideoPlayerAudio->SetMute(bOnOff);
+}
+
+bool CGstPlayer::ShowPVRChannelInfo()
+{
+  bool bReturn(false);
+
+  if (CSettings::GetInstance().GetInt(CSettings::SETTING_PVRMENU_DISPLAYCHANNELINFO) > 0)
+  {
+    g_PVRManager.ShowPlayerInfo(CSettings::GetInstance().GetInt(CSettings::SETTING_PVRMENU_DISPLAYCHANNELINFO));
+
+    bReturn = true;
+  }
+
+  CServiceBroker::GetDataCacheCore().SignalVideoInfoChange();
+  CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+  return bReturn;
+}
+
+int CGstPlayer::GetAudioStreamCount()
+{
+	return m_VideoPlayerVideo->GetAudioStreamCount();
+}
+
+int CGstPlayer::GetVideoStreamCount()
+{
+	return m_VideoPlayerVideo->GetVideoStreamCount();
+}
+
+int CGstPlayer::GetSubtitleCount()
+{
+	return m_VideoPlayerVideo->GetSubtitleCount();
+}
+
+int CGstPlayer::GetAudioStream()
+{
+	return m_VideoPlayerVideo->GetAudioStream();
+}
+
+int CGstPlayer::GetVideoStream()
+{
+	return m_VideoPlayerVideo->GetVideoStream();
+}
+
+int CGstPlayer::GetSubtitle()
+{
+	return m_VideoPlayerVideo->GetSubtitle();
+}
+
+float CGstPlayer::GetRenderAspectRatio()
+{
+	return m_VideoPlayerVideo->GetRenderAspectRatio();
+}
+
+void CGstPlayer::OnPlaybackStarted()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s", __FUNCTION__);
+	
+	CURL Url(m_pInputStream->GetFileName());
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: startpercent=%f starttime=%f", __FUNCTION__, m_PlayerOptions.startpercent, m_PlayerOptions.starttime);
+	
+	if (m_PlayerOptions.startpercent > 0)
+	{
+		//CLog::Log(LOGNOTICE, "CGstPlayer::%s: m_PlayerOptions.startpercent set", __FUNCTION__);
+		m_VideoPlayerVideo->SeekPercentage(m_PlayerOptions.startpercent/(float) 100);
+		m_PlayerOptions.startpercent = 0.0f;
+	}
+	else if (m_PlayerOptions.starttime > 0)
+	{
+		//CLog::Log(LOGNOTICE, "CGstPlayer::%s: m_PlayerOptions.starttime set", __FUNCTION__);
+		m_VideoPlayerVideo->SeekTimeRelative((int64_t) m_PlayerOptions.starttime * 1000);
+		m_PlayerOptions.starttime = 0.0f;
+	}
+	
+	if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && 
+		//Url.IsLocalHost() && !IsRecording())
+		Url.IsLocalHost() && !g_PVRManager.IsRecording())
+	{
+		FILE *f = fopen("/proc/stb/fp/led0_pattern", "w");
+		if (f)
+		{
+			if (fprintf(f, "%08x", 0xffffffff) == 0)
+				CLog::Log(LOGNOTICE, "CGstPlayer::%s: switch off fake record LED", __FUNCTION__);
+			fclose(f);
+		}
+	}
+	m_callback.OnPlayBackStarted();
+	//m_ready.Set();
+}
+
+bool CGstPlayer::OnAction(const CAction &action)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: id=%d", __FUNCTION__, action.GetID());
+	switch (action.GetID())
+	{
+		case ACTION_SHOW_OSD:
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_SHOW_OSD", __FUNCTION__);
+			break;
+		case ACTION_SHOW_VIDEOMENU:
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_SHOW_VIDEOMENU", __FUNCTION__);
+			break;
+		case ACTION_PLAYER_PROCESS_INFO:
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_PLAYER_PROCESS_INFO", __FUNCTION__);
+			break;
+		case ACTION_SELECT_ITEM:
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_SELECT_ITEM", __FUNCTION__);
+			break;
+		case ACTION_CHANNEL_SWITCH:
+		{
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_CHANNEL_SWITCH", __FUNCTION__);
+			if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+			{
+				int channel = (int) action.GetAmount();
+				// Offset from key codes back to button number
+				CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+				if (input && input->IsOtherStreamHack())
+				{
+					CLog::Log(LOGWARNING, "CGstPlayer::%s: input->IsOtherStreamHack()", __FUNCTION__);
+				}
+				if(input && input->SelectChannelByNumber(channel))
+				{
+					CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_CHANNEL_SWITCH channel=%d", __FUNCTION__, channel);
+				}
+				
+				//g_infoManager.SetDisplayAfterSeek();
+				//g_PVRManager.SetChannelPreview(false);
+				ShowPVRChannelInfo();
+				return true;
+			}
+		}
+		break;
+		case ACTION_MOVE_UP:
+		case ACTION_NEXT_ITEM:
+		case ACTION_CHANNEL_UP:
+		{
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_MOVE_UP", __FUNCTION__);
+			if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+			{
+				/* bool bPreview(action.GetID() == ACTION_MOVE_UP && // only up/down shows a preview, all others do switch
+						CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_CONFIRMCHANNELSWITCH)); */
+				
+				CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+				if (input)
+				{
+					input->NextChannel(false);
+				}
+				//g_infoManager.SetDisplayAfterSeek();
+				//g_PVRManager.SetChannelPreview(false);
+				ShowPVRChannelInfo();
+				return true;
+			}
+		}
+		break;
+		case ACTION_MOVE_DOWN:
+		case ACTION_PREV_ITEM:
+		case ACTION_CHANNEL_DOWN:
+		{
+			CLog::Log(LOGNOTICE, "CGstPlayer::%s: ACTION_MOVE_DOWN", __FUNCTION__);
+			if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+			{
+				/* bool bPreview(action.GetID() == ACTION_MOVE_DOWN && // only up/down shows a preview, all others do switch
+					CSettings::GetInstance().GetBool(CSettings::SETTING_PVRPLAYBACK_CONFIRMCHANNELSWITCH)); */
+				
+				CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+				if (input)
+				{
+					input->PrevChannel(false);
+				}
+				//g_infoManager.SetDisplayAfterSeek();
+				//g_PVRManager.SetChannelPreview(false);
+				ShowPVRChannelInfo();
+				return true;
+			}
+		}
+		break;
+	}
+	return false;
+}
+
+void CGstPlayer::GetVideoResolution(unsigned int &width, unsigned int &height)
+{
+	RESOLUTION_INFO res = g_graphicsContext.GetResInfo();
+	width = res.iWidth;
+	height = res.iHeight;
+	
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: width=%d height=%d", __FUNCTION__, width, height);
+}
+
+void CGstPlayer::FrameMove() 
+{ 
+	//CLog::Log(LOGNOTICE, "CGstPlayer::%s", __FUNCTION__ );
+}
+
+bool CGstPlayer::IsPlaying() const
+{
+  return !m_bStop;
+}
diff --git a/xbmc/cores/GstPlayer/GstPlayer.h b/xbmc/cores/GstPlayer/GstPlayer.h
new file mode 100644
index 0000000000..aa18720864
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayer.h
@@ -0,0 +1,170 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include "system.h"
+
+#include "GstPlayerAudio.h"
+#include "GstPlayerVideo.h"
+#include "cores/IPlayer.h"
+#include "threads/Thread.h"
+#include "utils/log.h"
+#include "FileItem.h"
+
+#include "cores/VideoPlayer/IVideoPlayer.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStream.h"
+
+class CProcessInfo;
+class CGstPlayerAudio;
+class CGstPlayerVideo;
+class CInputStreamPVRManager;
+
+using namespace PVR;
+
+class IGstPlayerCallback
+{
+public:
+	virtual void OnPlaybackStarted() = 0;
+};
+
+class CGstPlayer : public IPlayer, public CThread, public IVideoPlayer, public IGstPlayerCallback
+{
+public:
+
+	virtual int OnDVDNavResult(void* pData, int iMessage) { return 0; };
+	virtual void GetVideoResolution(unsigned int &width, unsigned int &height);
+	
+	CGstPlayer(IPlayerCallback& callback);
+	virtual ~CGstPlayer();
+	virtual bool Initialize(TiXmlElement* pConfig);
+	virtual bool OpenFile(const CFileItem& file, const CPlayerOptions &options);
+	virtual bool CloseFile(bool reopen = false);
+	
+	//virtual bool IsPlaying() const { return m_isPlaying; };
+	virtual bool IsPlaying() const;
+	virtual void Pause() override;
+	virtual bool HasVideo() const;
+	virtual bool HasAudio() const;
+	virtual void ToggleOSD(); // empty
+	virtual void SwitchToNextLanguage();
+	virtual void ToggleSubtitles();
+	virtual bool CanSeek();
+	virtual void Seek(bool bPlus, bool bLargeStep, bool bChapterOverride);
+	virtual void SeekPercentage(float iPercent);
+	virtual float GetPercentage();
+	virtual void SetVolume(float volume);
+	virtual void SetMute(bool bOnOff);
+	
+	virtual bool SwitchChannel(const CPVRChannelPtr &channel);
+
+	virtual bool HasMenu() const { return true; };
+	virtual void SetDynamicRangeCompression(long drc) {}
+	virtual void SetContrast(bool bPlus) {}
+	virtual void SetBrightness(bool bPlus) {}
+	virtual void SetHue(bool bPlus) {}
+	virtual void SetSaturation(bool bPlus) {}
+	virtual void SwitchToNextAudioLanguage();
+	virtual bool CanRecord();
+	virtual bool IsRecording();
+	virtual bool Record(bool bOnOff) { return false; }
+	virtual void SetAVDelay(float fValue = 0.0f);
+	virtual float GetAVDelay();
+	
+	virtual void FrameMove();
+	virtual void Render(bool clear, uint32_t alpha, bool gui);
+	virtual void FlushRenderer() { CLog::Log(LOGNOTICE, "%s: ", __FUNCTION__ ); };
+	
+	virtual void SetRenderViewMode(int mode) { CLog::Log(LOGNOTICE, "%s: mode=%d", __FUNCTION__, mode); };
+	virtual float GetRenderAspectRatio();
+	virtual void TriggerUpdateResolution() { CLog::Log(LOGNOTICE, "%s: ", __FUNCTION__ ); };
+	
+	virtual bool IsRenderingVideo() { true; };
+	virtual bool IsRenderingGuiLayer() { true; };
+	virtual bool IsRenderingVideoLayer() { true; };
+	
+	virtual void SetSubTitleDelay(float fValue = 0.0f);
+	virtual float GetSubTitleDelay();
+
+	virtual void SeekTime(int64_t iTime);
+	virtual bool SeekTimeRelative(int64_t iTime);
+	
+	virtual int64_t GetTime();
+	virtual int64_t GetTotalTime();
+	virtual void SetSpeed(float iSpeed) override;
+	virtual float GetSpeed() override;
+	virtual void ShowOSD(bool bOnoff);
+	virtual void DoAudioWork() {};
+	
+	virtual std::string GetPlayerState();
+	virtual bool SetPlayerState(const std::string& state);
+	
+	virtual int GetAudioStreamCount();
+	virtual int GetVideoStreamCount();
+	virtual int GetSubtitleCount();
+	
+	virtual int GetAudioStream();
+	virtual int GetVideoStream();
+	virtual int GetSubtitle();
+	
+	virtual bool SupportsTempo() { return m_canTempo; };
+	
+	void OnPlaybackStarted();
+
+private:
+
+	virtual void Process();
+	virtual bool OnAction(const CAction &action);
+	
+	void CreatePlayers();
+	void DestroyPlayers();
+	
+	bool ShowPVRChannelInfo();
+	
+	bool m_bAbortRequest;
+	bool m_isPlaying;
+	bool m_isRecording;
+	
+	int64_t m_playbackStartTime;
+	int m_speed;
+	int m_totalTime;
+	int m_time;
+	int m_playCountMinTime;
+	
+	CPlayerOptions m_PlayerOptions;
+	std::unique_ptr<CProcessInfo> m_processInfo;
+	
+//	CDVDMessageQueue m_messenger;		 // thread messenger
+ 
+	CGstPlayerAudio *m_VideoPlayerAudio;
+	CGstPlayerVideo *m_VideoPlayerVideo;
+	
+	CEvent m_ready;
+	
+protected:
+	bool OpenInputStream();
+	
+	friend class CSelectionStreams;
+	
+	CFileItem m_item;
+	std::atomic_bool m_canTempo;
+	CDVDInputStream* m_pInputStream;  // input stream for current playing file
+};
diff --git a/xbmc/cores/GstPlayer/GstPlayerAudio.cpp b/xbmc/cores/GstPlayer/GstPlayerAudio.cpp
new file mode 100644
index 0000000000..673dec733b
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerAudio.cpp
@@ -0,0 +1,120 @@
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/SingleLock.h"
+#include "utils/XMLUtils.h"
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/dvb/audio.h>
+
+#include "system.h"
+#include "GstPlayerAudio.h"
+#include "utils/log.h"
+
+#include "threads/Thread.h"
+#include "threads/SystemClock.h"
+#include "cores/AudioEngine/AEFactory.h"
+
+#define AUDIO_DEV "/dev/dvb/adapter0/audio0"
+
+CGstPlayerAudio::CGstPlayerAudio(CProcessInfo &processInfo): m_processInfo(processInfo)
+{
+	m_processInfo.ResetAudioCodecInfo();
+#if 0
+	CAEFactory::Suspend();
+	/* wait for AE has completed suspended */
+	XbmcThreads::EndTime timer(1000);
+	while (!timer.IsTimePast() && !CAEFactory::IsSuspended())
+	{
+		usleep(80);
+	}
+	if (timer.IsTimePast())
+	{
+		CLog::Log(LOGERROR,"CGstPlayerAudio::%s: AudioEngine did not suspend before launching player", __FUNCTION__);
+	}
+#endif
+}
+
+CGstPlayerAudio::~CGstPlayerAudio()
+{
+#if 0
+	/* Resume AE processing of XBMC native audio */
+	if (!CAEFactory::Resume())
+	{
+		CLog::Log(LOGFATAL, "CGstPlayerAudio::%s: Failed to restart AudioEngine after return from player",__FUNCTION__);
+	}
+#endif
+}
+
+void CGstPlayerAudio::SetVolume(float volume)
+{
+	int vol = checkVolume(int(volume * 100));
+	audio_mixer_t mixer;
+	
+	vol = 63 - vol * 63 / 100;
+	
+	mixer.volume_left = vol;
+	mixer.volume_right = vol;
+
+	int fd = openMixer();
+	if (fd >= 0)
+	{
+		ioctl(fd, AUDIO_SET_MIXER, &mixer);
+		closeMixer(fd);
+	}
+	CLog::Log(LOGDEBUG, "%s: volume:%f set:%d (-1db)", __FUNCTION__, volume, vol);
+}
+
+void CGstPlayerAudio::SetMute(bool bOnOff)
+{
+	int fd = openMixer();
+	if (fd >= 0)
+	{
+		bool mute = bOnOff; //!m_muted;
+		if (!ioctl(fd, AUDIO_SET_MUTE, mute) == 0)
+			CLog::Log(LOGERROR, "%s: ioctl AUDIO_SET_MUTE failed", __FUNCTION__);
+		
+		closeMixer(fd);
+	}
+	else
+			CLog::Log(LOGERROR, "%s: i/o AUDIO_SET_MUTE failed", __FUNCTION__);
+	
+	CLog::Log(LOGDEBUG, "%s: bOnOff	:%s", __FUNCTION__, bOnOff == false ? "off":"on" ); 
+}
+
+int CGstPlayerAudio::openMixer()
+{
+	return open(AUDIO_DEV, O_RDWR);
+}
+
+void CGstPlayerAudio::closeMixer(int fd)
+{
+	if (fd >= 0) close(fd);
+}
+
+int CGstPlayerAudio::checkVolume(int vol)
+{
+	if (vol < 0)
+		vol = 0;
+	else if (vol > 100)
+		vol = 100;
+	return vol;
+}
diff --git a/xbmc/cores/GstPlayer/GstPlayerAudio.h b/xbmc/cores/GstPlayer/GstPlayerAudio.h
new file mode 100644
index 0000000000..0a350976bd
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerAudio.h
@@ -0,0 +1,43 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Thread.h"
+
+
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+
+class CGstPlayerAudio
+{
+public:
+	CGstPlayerAudio(CProcessInfo &processInfo);
+	~CGstPlayerAudio();
+	void SetVolume(float volume);
+	void SetMute(bool bOnOff);
+
+private:
+	int openMixer();
+	int checkVolume(int vol);
+	void closeMixer(int fd);
+	
+protected:
+	CProcessInfo &m_processInfo;
+};
diff --git a/xbmc/cores/GstPlayer/GstPlayerVideo.cpp b/xbmc/cores/GstPlayer/GstPlayerVideo.cpp
new file mode 100644
index 0000000000..2a173fcb82
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerVideo.cpp
@@ -0,0 +1,1176 @@
+/*
+ *			Copyright (C) 2005-2015 Team Kodi
+ *			http://kodi.tv
+ *
+ *	This Program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2, or (at your option)
+ *	any later version.
+ *
+ *	This Program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with Kodi; see the file COPYING.	If not, see
+ *	<http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <gst/gst.h>
+#include <gst/app/gstappsrc.h>
+#include <gst/pbutils/missing-plugins.h>
+
+#include "GstPlayerVideo.h"
+#include "system.h"
+#include "URL.h"
+#include "Util.h"
+#include "filesystem/SpecialProtocol.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/XMLUtils.h"
+#include "utils/log.h"
+#include "settings/AdvancedSettings.h"
+#include "messaging/ApplicationMessenger.h"
+
+#define HTTP_TIMEOUT 10
+
+#define CHUNK_SIZE 4096
+
+CGstPlayerVideo::CGstPlayerVideo(IGstPlayerCallback *callback, CProcessInfo &processInfo): m_callback(callback)
+	,m_processInfo(processInfo)
+	,m_aspect(0)
+	,m_width(0)
+	,m_height(0)
+	,m_offset(0)
+	,m_length(0)
+	,m_framerate(0)
+	,m_progressive(0)
+	,m_time(0)
+	,m_video(0)
+	,m_audio(0)
+	,m_text(0)
+	,m_totalTime(1)
+	,m_uri(NULL)
+	,m_loop(NULL)
+	,m_playbin(NULL)
+	,m_appsrc(NULL)
+	,m_pInputStream(NULL)
+	,m_extra_headers("")
+	,m_download_buffer_path("")
+	,m_notify_source_handler_id(0)
+	,m_notify_source_id(0)
+	,m_notify_element_added_handler_id(0)
+	,m_ignore_buffering_messages(0)
+	,m_use_prefillbuffer(false)
+	,m_is_live(false)
+	
+{
+	gst_init (NULL, FALSE);
+	m_processInfo.SetVideoDecoderName(("Gstreamer Version: %s", (const char *)gst_version_string()), true);
+	m_processInfo.SetAudioDecoderName(("Gstreamer Version: %s", (const char *)gst_version_string()));
+	m_useragent = g_advancedSettings.m_userAgent.c_str();
+	m_buffer_size = 5LL * 1024LL * 1024LL;
+	m_sourceinfo.is_video = TRUE;
+	m_paused = false;
+	m_first_paused = false;
+}
+
+CGstPlayerVideo::~CGstPlayerVideo()
+{
+	CloseStream();
+	
+	if(m_pInputStream)
+		SAFE_DELETE(m_pInputStream);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+bool CGstPlayerVideo::OpenStream(CDVDStreamInfo &hints, const CFileItem &file)
+{
+	m_item = file;
+	m_processInfo.ResetVideoCodecInfo();
+	m_sourceinfo.is_streaming = FALSE;
+	m_sourceinfo.is_hls = TRUE;
+	
+	if(m_pInputStream)
+		SAFE_DELETE(m_pInputStream);
+	
+	std::string url(hints.filename);
+	
+	if (url.empty())
+		return CreateFakePipeline();
+	
+	if(StringUtils::EndsWith(url, ".m3u8"))
+		m_sourceinfo.is_hls = TRUE;
+	
+	if(StringUtils::StartsWith(url, "smb://") || StringUtils::StartsWith(url, "upnp://") || StringUtils::StartsWith(url, "nfs://"))
+	{
+		//m_sourceinfo.is_streaming = TRUE;
+
+		m_pInputStream = new CDVDInputStreamFile(m_item);
+		
+		m_uri = g_strdup((const gchar *) "appsrc://");
+	}
+	
+	else if(url.find("://") != std::string::npos)
+	{
+		m_sourceinfo.is_streaming = TRUE;
+		size_t pos = url.find('#');
+		
+		if (pos != std::string::npos && (StringUtils::StartsWith(url, "http") || StringUtils::StartsWith(url, "rtsp")))
+		{
+			m_extra_headers = url.substr(pos + 1);
+			pos = m_extra_headers.find("User-Agent=");
+			if (pos != std::string::npos)
+			{
+				size_t hpos_start = pos + 11;
+				size_t hpos_end = m_extra_headers.find('&', hpos_start);
+				if (hpos_end != std::string::npos)
+					m_useragent = m_extra_headers.substr(hpos_start, hpos_end - hpos_start);
+				else
+					m_useragent = m_extra_headers.substr(hpos_start);
+			}
+		}
+		m_uri = g_strdup((const gchar *) url.c_str());
+	}
+	
+	else if(StringUtils::StartsWith(url, "/"))
+		m_uri = g_filename_to_uri((const gchar *) url.c_str(), NULL, NULL);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: is_streaming: %s", __FUNCTION__, m_sourceinfo.is_streaming ? "true" : "false");
+	
+	return CreatePipeline();
+}
+
+void CGstPlayerVideo::CloseStream()
+{
+	DestroyPipeline();
+}
+
+void CGstPlayerVideo::DestroyPipeline()
+{
+	if (m_playbin != NULL)
+	{
+		GstStateChangeReturn ret;
+		
+		if(m_notify_source_handler_id)
+		{
+			g_signal_handler_disconnect(m_playbin, m_notify_source_handler_id);
+			m_notify_source_handler_id = 0;
+		}
+		
+		if(m_notify_element_added_handler_id)
+		{
+			g_signal_handler_disconnect(m_playbin, m_notify_element_added_handler_id);
+			m_notify_element_added_handler_id = 0;
+		}
+		
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_playbin));
+		gst_bus_set_sync_handler(bus, NULL, NULL, NULL);
+		gst_object_unref(bus);
+		
+		ret = gst_element_set_state(m_playbin, GST_STATE_NULL);
+		if (ret != GST_STATE_CHANGE_SUCCESS)
+			CLog::Log(LOGFATAL, "CGstPlayerVideo::%s: Failed to set pipeline to GST_STATE_NULL!", __FUNCTION__);
+		else
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: set pipeline to GST_STATE_NULL!", __FUNCTION__);
+
+		gst_object_unref(GST_OBJECT(m_playbin));
+		m_appsrc = NULL;
+		m_playbin = NULL;
+	}
+	
+	if(m_pInputStream)
+	{
+		m_pInputStream->Close();
+		SAFE_DELETE(m_pInputStream);
+		printf("CGstPlayerVideo::%s: SAFE_DELETE m_pInputStream", __FUNCTION__);
+	}
+	
+	if (m_uri != NULL)
+	{
+		g_free(m_uri);
+		m_uri = NULL;
+	}
+	
+	if (m_loop != NULL)
+	{
+		g_main_loop_quit(m_loop);
+	}
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: clean", __FUNCTION__);
+}
+
+bool CGstPlayerVideo::CreateFakePipeline()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: running pipeline...", __FUNCTION__);
+	
+	m_callback->OnPlaybackStarted();
+	
+	m_loop = g_main_loop_new(NULL, FALSE);
+	g_main_loop_run(m_loop);
+	
+	g_main_loop_unref(m_loop);
+	m_loop = NULL;
+	
+	return true;
+}
+
+bool CGstPlayerVideo::CreatePipeline()
+{
+	m_loop = g_main_loop_new(NULL, FALSE);
+	m_playbin = gst_element_factory_make("playbin", "playbin");
+	
+	if(m_playbin)
+	{
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: m_uri: '%s'", __FUNCTION__, m_uri);
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: running pipeline...", __FUNCTION__);
+
+		int flags = GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO;
+		if(m_pInputStream)
+		{
+			if (m_pInputStream->Open())
+			{
+				m_length = (gsize) m_item.m_dwSize;
+				//m_length = (gsize) abs(m_pInputStream->GetLength());
+				m_offset = 0;
+				m_pInputStream->Seek(0, SEEK_SET);
+				m_notify_source_handler_id = g_signal_connect(m_playbin, "deep-notify::source", G_CALLBACK (DeepNotifySource), this);
+				CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: m_length=%d m_pInputStream->GetLength()=%d\n", __FUNCTION__,(int)m_length, m_pInputStream->GetLength());
+				printf("CGstPlayerVideo::%s: m_pInputStream->GetLength() %d\n", __FUNCTION__,(int)m_length);
+			}
+			else
+			{
+				if (m_loop != NULL) 
+				{
+					g_main_loop_unref(m_loop);
+					m_loop = NULL;
+				}
+				printf("CGstPlayerVideo::%s: m_pInputStream->Open()  Can not open File!\n", __FUNCTION__);
+				CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Can not open File!",__FUNCTION__);
+				return false;
+			}
+				
+		}
+		
+		else if ( m_sourceinfo.is_streaming )
+		{
+			m_download_buffer_path = CSpecialProtocol::TranslatePath(CUtil::GetNextFilename("special://temp/filecache%03d.cache", 999));
+			
+
+			m_notify_source_handler_id = g_signal_connect(m_playbin, "notify::source", G_CALLBACK (NotifySource), this);
+			
+			if (m_download_buffer_path.empty())
+			{
+				CLog::Log(LOGERROR, "CGstPlayerVideo::%s: - Unable to generate a new filename for cache file", __FUNCTION__);
+			}
+			else
+			{
+				CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: m_download_buffer_path: %s", __FUNCTION__, m_download_buffer_path.c_str());
+			
+				if (access(m_download_buffer_path.c_str(), X_OK) >= 0)
+				{
+					CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: using cache file (buffer): %s", __FUNCTION__, m_download_buffer_path.c_str());
+					/* It looks like /hdd points to a valid mount, so we can store a download buffer on it */
+					m_use_prefillbuffer = true;
+					flags |= GST_PLAY_FLAG_DOWNLOAD;
+					m_notify_element_added_handler_id = g_signal_connect(m_playbin, "element-added", G_CALLBACK(handleElementAdded), this);
+					/* limit file size */
+					g_object_set(m_playbin, "ring-buffer-max-size", (guint64)(8LL * 1024LL * 1024LL), NULL);
+				}
+				else
+				{
+					CLog::Log(LOGERROR, "CGstPlayerVideo::%s: - Unable to access cache file %s", __FUNCTION__, m_download_buffer_path.c_str());
+					m_download_buffer_path = "";
+				}
+			}
+		
+			flags |= GST_PLAY_FLAG_BUFFERING;
+			/* increase the default 2 second / 2 MB buffer limitations to 10s / 10MB */
+			g_object_set(m_playbin, "buffer-duration", (gint64)(5LL * GST_SECOND), NULL);
+			g_object_set(m_playbin, "buffer-size", m_buffer_size, NULL);
+		
+			if(m_sourceinfo.is_hls)
+				g_object_set(m_playbin, "connection-speed", (guint64)(4495000LL), NULL);
+		}
+		
+		g_object_set(G_OBJECT(m_playbin), "uri", m_uri, NULL);
+		g_object_set(G_OBJECT(m_playbin), "flags", flags, NULL);
+
+		GstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(m_playbin));
+		gst_bus_set_sync_handler(bus, gstBusSyncHandler, this, NULL);
+		gst_object_unref(bus);
+
+		GstStateChangeReturn ready;
+		ready = gst_element_set_state (m_playbin, GST_STATE_READY);
+
+		switch(ready)
+		{
+		case GST_STATE_CHANGE_FAILURE:
+			CLog::Log(LOGFATAL, "CGstPlayerVideo::%s: failed to start pipeline",__FUNCTION__);
+			DestroyPipeline();
+			return false;
+			break;
+		case GST_STATE_CHANGE_SUCCESS:
+			gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+			printf("CGstPlayerVideo::%s:GST_STATE_PLAYING\n", __FUNCTION__);
+			m_is_live = false;
+			m_first_paused = true;
+			break;
+		case GST_STATE_CHANGE_NO_PREROLL:
+			gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+			printf("CGstPlayerVideo::%s: GST_STATE_PLAYING\n", __FUNCTION__);
+			m_is_live = true;
+			break;
+		default:
+			return false;
+			break;
+		}
+		
+		g_main_loop_run(m_loop);
+		
+		g_main_loop_unref(m_loop);
+		m_loop = NULL;
+		
+		DestroyPipeline();
+	}
+	else
+	{
+		if (m_loop != NULL) 
+		{
+			g_main_loop_unref(m_loop);
+			m_loop = NULL;
+		}
+		CLog::Log(LOGFATAL, "CGstPlayerVideo::%s: Failed to create pipeline!",__FUNCTION__);
+		return false;
+	}
+	
+	return true;
+}
+
+void CGstPlayerVideo::Pause()
+{
+	if(m_playbin)
+	{
+		GstState currentState;
+		
+		gst_element_get_state(GST_ELEMENT(m_playbin), &currentState, 0, 0);
+		
+		if(currentState == GST_STATE_PAUSED)
+		{
+			gst_element_set_state(GST_ELEMENT(m_playbin), GST_STATE_PLAYING);
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: set play", __FUNCTION__ );
+		}
+		else
+		{
+			gst_element_set_state(GST_ELEMENT(m_playbin), GST_STATE_PAUSED);
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: set pause", __FUNCTION__ );
+		}
+	}
+}
+
+void CGstPlayerVideo::SwitchToNextLanguage()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+void CGstPlayerVideo::ToggleSubtitles()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+bool CGstPlayerVideo::CanSeek()
+{
+	if(m_pInputStream)
+		return false;
+	//CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: true",	__FUNCTION__ );
+	return true;
+}
+
+void CGstPlayerVideo::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
+{
+	if(m_playbin)
+	{
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: bPlus=%s bLargeStep=%s bChapterOverride=%s", __FUNCTION__, bPlus == false ? "off":"on" , bLargeStep == false ? "off":"on" , bChapterOverride == false ? "off":"on" ); 
+	}
+}
+
+void CGstPlayerVideo::SwitchToNextAudioLanguage()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+void CGstPlayerVideo::SeekPercentage(float iPercent)
+{
+	CLog::Log(LOGERROR, "CGstPlayerVideo::%s: iPercent=%f", __FUNCTION__, iPercent);
+	
+	if(m_playbin)
+	{
+		
+		gint64 position;
+	
+		if (!gst_element_query_position (GST_ELEMENT(m_playbin), GST_FORMAT_TIME, &position))
+		{
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Position query failed...", __FUNCTION__);
+			
+			return;
+		}
+		/* no position, seek to 1 second, this could EOS */
+		if (position == -1)
+		{
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: position=-1", __FUNCTION__);
+			
+			return;
+		}
+
+
+		int val = (int) GetTotalTime() * iPercent;
+		
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: iPercent=%f seek to %d milliseconds", __FUNCTION__, iPercent, val);
+
+		if(val<0)
+			return;
+
+		GstClockTime nanoSec = (GstClockTime) (val * GST_MSECOND);
+		if (!gst_element_seek(m_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, nanoSec, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: seek", __FUNCTION__ );
+		//else:
+		//	m_callback.OnPlayBackSeek((int)abstime, iTime);
+	}
+}
+
+void CGstPlayerVideo::SetAVDelay(float fValue)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+float CGstPlayerVideo::GetAVDelay()
+{
+	//CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+	return 0.0f;
+}
+
+void CGstPlayerVideo::SetSubTitleDelay(float fValue)
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+}
+
+float CGstPlayerVideo::GetSubTitleDelay()
+{
+	//CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__ );
+	return 0.0f;
+}
+
+void CGstPlayerVideo::SeekTime(int64_t iTime)
+{
+	int seekOffset = (int)(iTime - GetTime());
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: seekOffset=%d", __FUNCTION__, seekOffset);
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	
+	printf("CGstPlayerVideo::%s: seekOffset=%d", __FUNCTION__, seekOffset);
+	printf("CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	printf("CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	
+	if (seekOffset >= 0)
+	{
+		GstClockTime nanoSec = (GstClockTime) ((int)seekOffset * GST_MSECOND);
+		if (!gst_element_seek(m_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, nanoSec, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: seek", __FUNCTION__ );
+	}
+}
+
+bool CGstPlayerVideo::SeekTimeRelative(int64_t iTime)
+{
+	int64_t abstime = GetTime() + iTime;
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: abstime=%d", __FUNCTION__, abstime);
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	printf("CGstPlayerVideo::%s: abstime=%d", __FUNCTION__, abstime);
+	printf("CGstPlayerVideo::%s: iTime=%d", __FUNCTION__, iTime);
+	printf("CGstPlayerVideo::%s: GetTime()=%d", __FUNCTION__, GetTime());
+	
+	if (abstime >= 0)
+	{
+		GstClockTime nanoSec = (GstClockTime) ((int)abstime * GST_MSECOND);
+		if (!gst_element_seek(m_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, nanoSec, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
+			CLog::Log(LOGERROR, "CGstPlayerVideo::%s: seek", __FUNCTION__ );
+
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: abstime=%d", __FUNCTION__, abstime);
+	}
+	
+	return true;
+}
+
+int64_t CGstPlayerVideo::GetTime() // in milliseconds
+{
+	gint64 position;
+	
+	if (!gst_element_query_position (GST_ELEMENT(m_playbin), GST_FORMAT_TIME, &position))
+	{
+		m_time = (int64_t) 1000;
+		CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Position query failed...", __FUNCTION__);
+	}
+	/* no position, seek to 1 second, this could EOS */
+	if (position == -1)
+	{
+		m_time = (int64_t) 1000;
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: milliseconds=1000 position=-1", __FUNCTION__);
+	}
+	else
+	{
+		m_time = (int64_t) GST_TIME_AS_MSECONDS(position);
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: milliseconds=%d", __FUNCTION__, (int) m_time);
+	}
+	
+	if(m_pInputStream)
+	{
+		m_time = (int64_t) (((GetTotalTime() * 1000) / m_length) * m_offset) / 1000;
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: (appsrc) m_offset=%d m_length=%d m_pInputStream->GetLength()=%d", __FUNCTION__, (int) m_offset, (int) m_length, m_pInputStream->GetLength());
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: (appsrc) milliseconds=%d", __FUNCTION__, (int) m_time);
+		return m_time;
+	}
+	
+	return m_time;
+
+}
+
+int64_t CGstPlayerVideo::GetTotalTime() // in milliseconds
+{
+	gint64 duration = 0;
+	
+	if (!gst_element_query_duration(GST_ELEMENT(m_playbin), GST_FORMAT_TIME, &duration))
+	{
+		CLog::Log(LOGERROR, "CGstPlayerVideo::%s: Time duration query failed", __FUNCTION__);
+		
+		m_totalTime = 1;
+	}
+	else
+	{
+		/* no duration, seek to 1 second, this could EOS */
+		if (duration != -1)
+			m_totalTime = GST_TIME_AS_MSECONDS(duration)/1000;
+		else
+			m_totalTime = 1;
+		
+	}
+
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: %d", __FUNCTION__, m_totalTime * 1000);
+	
+	return (int64_t) m_totalTime * 1000;
+	
+}
+
+std::string CGstPlayerVideo::GetPlayerState()
+{
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s", __FUNCTION__);
+	
+	return "";
+}
+
+void CGstPlayerVideo::OnPipelineStart()
+{
+	gint i;
+	GstTagList *tags;
+	gchar *str;
+	guint rate;
+
+	g_object_get (m_playbin, "n-video", &m_video, NULL);
+	g_object_get (m_playbin, "n-audio", &m_audio, NULL);
+	g_object_get (m_playbin, "n-text", &m_text, NULL);
+	
+	//m_processInfo.SetAudioChannels(m_audio);
+	//m_processInfo.SetAudioSampleRate(GST_TAG_NOMINAL_BITRATE)
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: %d video stream(s), %d audio stream(s), %d text stream(s)", 
+		 __FUNCTION__,
+		(int)m_video,
+		(int)m_audio,
+		(int)m_text);
+	
+	for (i = 0; i < m_video; i++) {
+		tags = NULL;
+		/* Retrieve the stream's video tags */
+		g_signal_emit_by_name (m_playbin, "get-video-tags", i, &tags);
+		if (tags) {
+			gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &str);
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: video stream: %d codec: %s", 
+				__FUNCTION__,
+				(int)i,
+				(char *) str ? str : "unknown");
+			g_free (str);
+			gst_tag_list_free (tags);
+		}
+	}
+	
+	for (i = 0; i < m_audio; i++) {
+		tags = NULL;
+		/* Retrieve the stream's audio tags */
+		g_signal_emit_by_name (m_playbin, "get-audio-tags", i, &tags);
+		if (tags) {
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: audio stream: %d", 
+				__FUNCTION__,
+				(int)i);
+			if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &str)) {
+				CLog::Log(LOGNOTICE, "	codec: %s", (char *)str);
+				g_free (str);
+			}
+			if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {
+				CLog::Log(LOGNOTICE, "	language: %s", (char *)str);
+				g_free (str);
+			}
+			if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &rate)) {
+				CLog::Log(LOGNOTICE, "	bitrate: %d", (int)rate);
+			}
+			gst_tag_list_free (tags);
+		}
+	}
+	
+	for (i = 0; i < m_text; i++) {
+		tags = NULL;
+		/* Retrieve the stream's subtitle tags */
+		g_signal_emit_by_name (m_playbin, "get-text-tags", i, &tags);
+		if (tags) {
+			CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: subtitle stream: %d", 
+				__FUNCTION__,
+				(int)i);
+
+			if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {
+				CLog::Log(LOGNOTICE, "	language: %s", (char *)str);
+				g_free (str);
+			}
+			gst_tag_list_free (tags);
+		}
+	}
+	
+	g_object_get (m_playbin, "current-video", &m_current_video, NULL);
+	g_object_get (m_playbin, "current-audio", &m_current_audio, NULL);
+	g_object_get (m_playbin, "current-text", &m_current_text, NULL);
+	
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: current video stream: %d, current audio stream: %d, current text stream: %d", 
+		 __FUNCTION__,
+		(int)m_current_video,
+		(int)m_current_audio,
+		(int)m_current_text);
+}
+
+float CGstPlayerVideo::GetRenderAspectRatio()
+{
+	CLog::Log(LOGNOTICE, "%s: m_aspect: %d.0f", __FUNCTION__, (int)m_aspect); 
+	return (float) (1.0f * (int)m_aspect);
+	
+}
+
+void CGstPlayerVideo::NotifySource(GObject *object, GParamSpec *unused, gpointer user_data)
+{
+	GstElement *source = NULL;
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	g_object_get(object, "source", &source, NULL);
+	if (source)
+	{
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "timeout") != 0)
+		{
+			GstElementFactory *factory = gst_element_get_factory(source);
+			if (factory)
+			{
+				const gchar *sourcename = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(factory));
+				if (!strcmp(sourcename, "souphttpsrc"))
+				{
+					g_object_set(G_OBJECT(source), "timeout", HTTP_TIMEOUT, NULL);
+				}
+			}
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "ssl-strict") != 0)
+		{
+			g_object_set(G_OBJECT(source), "ssl-strict", FALSE, NULL);
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "user-agent") != 0 && !_this->m_useragent.empty())
+		{
+			g_object_set(G_OBJECT(source), "user-agent", _this->m_useragent.c_str(), NULL);
+		}
+		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "extra-headers") != 0 && !_this->m_extra_headers.empty())
+		{
+			GstStructure *extras = gst_structure_new_empty("extras");
+			size_t pos = 0;
+			while (pos != std::string::npos)
+			{
+				std::string name, value;
+				size_t start = pos;
+				size_t len = std::string::npos;
+				pos = _this->m_extra_headers.find('=', pos);
+				if (pos != std::string::npos)
+				{
+					len = pos - start;
+					pos++;
+					name = _this->m_extra_headers.substr(start, len);
+					start = pos;
+					len = std::string::npos;
+					pos = _this->m_extra_headers.find('&', pos);
+					if (pos != std::string::npos)
+					{
+						len = pos - start;
+						pos++;
+					}
+					value = _this->m_extra_headers.substr(start, len);
+				}
+				if (!name.empty() && !value.empty())
+				{
+					GValue header;
+					CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: setting extra-header '%s:%s'",
+						  __FUNCTION__, 
+						name.c_str(), 
+						value.c_str());
+					memset(&header, 0, sizeof(GValue));
+					g_value_init(&header, G_TYPE_STRING);
+					g_value_set_string(&header, value.c_str());
+					gst_structure_set_value(extras, name.c_str(), &header);
+				}
+				else
+				{
+					CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: Invalid header format %s",
+								__FUNCTION__,
+								_this->m_extra_headers.c_str());
+					break;
+				}
+			}
+			if (gst_structure_n_fields(extras) > 0)
+			{
+				g_object_set(G_OBJECT(source), "extra-headers", extras, NULL);
+			}
+			gst_structure_free(extras);
+		}
+		gst_object_unref(source);
+	}
+}
+
+void CGstPlayerVideo::DeepNotifySource(GObject *object, GObject *orig, GParamSpec *pspec, gpointer user_data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	g_object_get (orig, pspec->name, &_this->m_appsrc, NULL);
+	printf("CGstPlayerVideo::%s: appsrc %p\n", __FUNCTION__, _this->m_appsrc);
+
+	g_object_set (_this->m_appsrc, "size", (gint64) _this->m_length, NULL);
+
+	gst_util_set_object_arg (G_OBJECT (_this->m_appsrc), "do-timestamp", "true");
+	//gst_util_set_object_arg (G_OBJECT (_this->m_appsrc), "format", "time");
+	gst_util_set_object_arg (G_OBJECT (_this->m_appsrc), "stream-type", "seekable");
+	
+	g_signal_connect (_this->m_appsrc, "need-data", G_CALLBACK (startFeed), user_data);
+	g_signal_connect (_this->m_appsrc, "seek-data", G_CALLBACK (seekData), user_data);
+	g_signal_connect (_this->m_appsrc, "enough-data", G_CALLBACK (stopFeed), user_data);
+}
+
+void CGstPlayerVideo::startFeed(GstElement * playbin, guint size, gpointer user_data)
+{
+	printf("CGstPlayerVideo::%s:", __FUNCTION__);
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	if (_this->m_notify_source_id == 0)
+	{
+		_this->m_notify_source_id = g_idle_add ((GSourceFunc) readData, user_data);
+	}
+}
+
+/* This callback is called when appsrc has enough data and we can stop sending.
+ * We remove the idle handler from the mainloop */
+void CGstPlayerVideo::stopFeed(GstElement * playbin, gpointer user_data)
+{
+	printf("CGstPlayerVideo::%s:", __FUNCTION__);
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	if (_this->m_notify_source_id != 0)
+	{
+		g_source_remove (_this->m_notify_source_id);
+		_this->m_notify_source_id = 0;
+	}
+}
+
+gboolean CGstPlayerVideo::seekData(GstElement * appsrc, guint64 position, gpointer user_data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	printf("CGstPlayerVideo::seekData: offset=%"G_GUINT64_FORMAT " m_offset=%d m_length=%d", position, _this->m_offset, _this->m_length);
+	CLog::Log(LOGNOTICE, "CGstPlayerVideo::seekData: offset=%"G_GUINT64_FORMAT " m_offset=%d m_length=%d", position, _this->m_offset, _this->m_length);
+	_this->m_offset = position;
+
+	return TRUE;
+}
+
+gboolean CGstPlayerVideo::readData(gpointer user_data)
+{
+	printf("CGstPlayerVideo::%s:", __FUNCTION__);
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	
+	GstMapInfo map;
+	GstBuffer *buffer = NULL;
+	guint len;
+	GstFlowReturn ret;
+
+	if (_this->m_offset >= _this->m_length) {
+		/* we are EOS, send end-of-stream and remove the source */
+		CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s: end-of-stream", __FUNCTION__);
+		g_signal_emit_by_name (_this->m_appsrc, "end-of-stream", &ret);
+		return FALSE;
+	}
+
+	len = CHUNK_SIZE;
+	if (_this->m_offset + len > _this->m_length)
+		len = _this->m_length - _this->m_offset;
+	
+	/* read the next chunk */
+	buffer = gst_buffer_new_allocate(NULL, len, NULL);
+			
+	gst_buffer_map (buffer, &map, GST_MAP_WRITE);
+	
+	_this->m_pInputStream->Seek(_this->m_offset, SEEK_SET);
+	_this->m_pInputStream->Read(map.data, len);
+
+	printf("CGstPlayerVideo::%s:feed buffer %p, offset %" G_GUINT64_FORMAT "-%u", __FUNCTION__, buffer, _this->m_offset, len);
+	g_signal_emit_by_name (_this->m_appsrc, "push-buffer", buffer, &ret);
+	gst_buffer_unmap(buffer, &map);
+	if (ret != GST_FLOW_OK) {
+		/* some error, stop sending data */
+		return FALSE;
+	}
+
+	_this->m_offset += len;
+
+	return TRUE;
+}
+
+void CGstPlayerVideo::handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo*)user_data;
+	if (_this)
+	{
+		gchar *elementname = gst_element_get_name(element);
+
+		if (g_str_has_prefix(elementname, "queue2"))
+		{
+			if (_this->m_download_buffer_path != "")
+			{
+				g_object_set(G_OBJECT(element), "temp-template", _this->m_download_buffer_path.c_str(), NULL);
+			}
+			else
+			{
+				g_object_set(G_OBJECT(element), "temp-template", NULL, NULL);
+			}
+		}
+		else if (g_str_has_prefix(elementname, "uridecodebin")
+			|| g_str_has_prefix(elementname, "decodebin"))
+		{
+			/*
+			 * Listen for queue2 element added to uridecodebin/decodebin2 as well.
+			 * Ignore other bins since they may have unrelated queues
+			 */
+			g_signal_connect(element, "element-added", G_CALLBACK(handleElementAdded), user_data);
+		}
+		g_free(elementname);
+	}
+}
+
+GstBusSyncReply CGstPlayerVideo::gstBusSyncHandler(GstBus *bus, GstMessage *msg, gpointer data)
+{
+	CGstPlayerVideo *_this = (CGstPlayerVideo *)data;
+	
+	if (_this) _this->handleMessage(msg);
+	
+	return GST_BUS_DROP;
+}
+
+void CGstPlayerVideo::handleMessage(GstMessage *msg)
+{
+	if (!msg)
+		return;
+#if 0
+	gchar *sourceName;
+	GstObject *source;
+	source = GST_MESSAGE_SRC(msg);
+	if (!GST_IS_OBJECT(source))
+		return;
+	
+	sourceName = gst_object_get_name(source);
+#endif
+	GstState state, pending, old_state, new_state;
+	GstStateChangeReturn ret;
+	GstStateChange transition;
+	
+	switch (GST_MESSAGE_TYPE(msg))
+	{
+		case GST_MESSAGE_EOS:
+		{
+			g_print("CGstPlayerVideo::%s: End of stream\n", __FUNCTION__);
+			g_main_loop_quit(m_loop);
+			break;
+		}
+
+		case GST_MESSAGE_BUFFERING:
+		{
+			if (m_sourceinfo.is_streaming)
+			{
+				//GstBufferingMode mode;
+				gst_message_parse_buffering(msg, &(m_bufferInfo.bufferPercent));
+				// eDebug("[eServiceMP3] Buffering %u percent done", m_bufferInfo.bufferPercent);
+				//gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
+				//m_event((iPlayableService*)this, evBuffering);
+				/*
+				 * we don't react to buffer level messages, unless we are configured to use a prefill buffer
+				 * (even if we are not configured to, we still use the buffer, but we rely on it to remain at the
+				 * healthy level at all times, without ever having to pause the stream)
+				 *
+				 * Also, it does not make sense to pause the stream if it is a live stream
+				 * (in which case the sink will not produce data while paused, so we won't
+				 * recover from an empty buffer)
+				 */
+				if (m_use_prefillbuffer && !m_is_live && !m_sourceinfo.is_hls && --m_ignore_buffering_messages <= 0)
+				{
+					if (m_bufferInfo.bufferPercent == 100)
+					{
+						GstState state, pending;
+						/* avoid setting to play while still in async state change mode */
+						gst_element_get_state(m_playbin, &state, &pending, 5 * GST_SECOND);
+						if (state != GST_STATE_PLAYING && !m_first_paused)
+						{
+							g_print("CGstPlayerVideo::%s: *** PREFILL BUFFER action start playing *** pending state was %s", 
+								__FUNCTION__ , 
+								pending == GST_STATE_VOID_PENDING ? "NO_PENDING" : "A_PENDING_STATE" );
+							gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+						}
+						/*
+						 * when we start the pipeline, the contents of the buffer will immediately drain
+						 * into the (hardware buffers of the) sinks, so we will receive low buffer level
+						 * messages right away.
+						 * Ignore the first few buffering messages, giving the buffer the chance to recover
+						 * a bit, before we start handling empty buffer states again.
+						 */
+						m_ignore_buffering_messages = 10;
+					}
+					else if (m_bufferInfo.bufferPercent == 0 && !m_first_paused)
+					{
+						g_print("CGstPlayerVideo::%s: *** PREFILLBUFFER action start pause ***", 
+							__FUNCTION__);
+						gst_element_set_state (m_playbin, GST_STATE_PAUSED);
+						m_ignore_buffering_messages = 0;
+					}
+					else
+					{
+						m_ignore_buffering_messages = 0;
+					}
+				}
+				
+			}
+			break;
+		}
+#if 1
+		case GST_MESSAGE_STATE_CHANGED:
+		{
+			g_print("CGstPlayerVideo::%s: Message STATE_CHANGED\n", __FUNCTION__);
+			GstState old_state, new_state;
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+			
+			if (GST_MESSAGE_SRC (msg) == GST_OBJECT_CAST (m_playbin) && 
+				new_state == GST_STATE_PLAYING)
+			{
+				OnPipelineStart();
+				m_callback->OnPlaybackStarted();
+			}
+
+			g_print("CGstPlayerVideo::%s: Element %s changed state from %s to %s.\n", 
+				__FUNCTION__,
+				GST_OBJECT_NAME(msg->src),
+				gst_element_state_get_name (old_state),
+				gst_element_state_get_name (new_state));
+			break;
+		}
+#else
+		case GST_MESSAGE_STATE_CHANGED:
+		{
+			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_playbin))
+				break;
+			
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+			
+			if(old_state == new_state)
+				break;
+			
+			g_print("CGstPlayerVideo::%s:  ****STATE TRANSITION %s -> %s ****\n",
+				__FUNCTION__,
+				gst_element_state_get_name(old_state), 
+				gst_element_state_get_name(new_state));
+			
+			transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+			
+			
+			g_print("CGstPlayerVideo::%s:  ****TRANSITION %d ****\n",
+				__FUNCTION__,
+				transition);
+			
+			switch(transition)
+			{
+				case GST_STATE_CHANGE_NULL_TO_READY:
+				{
+					g_print("CGstPlayerVideo::%s:  STATE IS: GST_STATE_CHANGE_NULL_TO_READY ****\n",
+						__FUNCTION__);
+
+				}	break;
+				
+				case GST_STATE_CHANGE_READY_TO_PAUSED:
+				{
+					g_print("CGstPlayerVideo::%s:  STATE IS: GST_STATE_CHANGE_READY_TO_PAUSED ****\n",
+						__FUNCTION__);
+				}	break;
+				
+				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+				{
+					g_print("CGstPlayerVideo::%s:  STATE IS: GST_STATE_CHANGE_PAUSED_TO_PLAYING ****\n",
+						__FUNCTION__);
+					m_paused = false;
+					if (!m_first_paused)
+					{
+						g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PAUSED_TO_PLAYING !m_first_paused\n",
+						__FUNCTION__);
+					}
+					else
+					{
+						g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PAUSED_TO_PLAYING m_first_paused\n",
+						__FUNCTION__);
+						OnPipelineStart();
+						m_callback->OnPlaybackStarted();
+					}
+					m_first_paused = false;
+				}	break;
+				
+				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+				{
+					m_paused = true;
+					g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PLAYING_TO_PAUSED\n",
+						__FUNCTION__);
+				}	break;
+				
+				case GST_STATE_CHANGE_PAUSED_TO_READY:
+				{
+					g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_PAUSED_TO_READY\n",
+						__FUNCTION__);
+				}	break;
+				
+				case GST_STATE_CHANGE_READY_TO_NULL:
+				{
+					g_print("CGstPlayerVideo::%s: GST_STATE_CHANGE_READY_TO_NULL\n",
+						__FUNCTION__);
+				}	break;
+			}
+			break;
+		}
+#endif
+
+		case GST_MESSAGE_ELEMENT:
+		{
+			const GstStructure *msgstruct = gst_message_get_structure(msg);
+			if (msgstruct)
+			{
+				if ( gst_is_missing_plugin_message(msg) )
+				{
+					GstCaps *caps = NULL;
+					gst_structure_get (msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL);
+					if (caps)
+					{
+						std::string codec = (const char*) gst_caps_to_string(caps);
+						gchar *description = gst_missing_plugin_message_get_description(msg);
+						if ( description )
+						{
+							CLog::Log(LOGERROR, "CGstPlayerVideo::%s: missing codec: %s",
+								__FUNCTION__,
+								codec.c_str());
+							CLog::Log(LOGERROR, "CGstPlayerVideo::%s: GStreamer plugin: %s not available!",
+								__FUNCTION__,
+								(const char*)description);
+							g_free(description);
+						}
+						gst_caps_unref(caps);
+					}
+				}
+				else
+				{
+					const gchar *eventname = gst_structure_get_name(msgstruct);
+					if ( eventname )
+					{
+						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
+						{
+							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
+							gst_structure_get_int (msgstruct, "width", &m_width);
+							gst_structure_get_int (msgstruct, "height", &m_height);
+							if (strstr(eventname, "Changed"))
+							{
+								m_processInfo.SetVideoDimensions((int)m_width, (int)m_height);
+							}
+						}
+						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
+						{
+							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
+							if (strstr(eventname, "Changed"))
+								m_processInfo.SetVideoFps((float)m_framerate * 1.0f);
+						}
+						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
+						{
+							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
+							//if (strstr(eventname, "Changed"))
+								//m_processInfo.SetVideoDeintMethod("progressive: %d", (int)m_progressive);
+						}
+						else if (!strcmp(eventname, "redirect"))
+						{
+							const char *uri = gst_structure_get_string(msgstruct, "new-location");
+							CLog::Log(LOGNOTICE, "CGstPlayerVideo::%s redirect to %s",
+								__FUNCTION__,
+								uri);
+							gst_element_set_state (m_playbin, GST_STATE_NULL);
+							g_object_set(m_playbin, "uri", uri, NULL);
+							gst_element_set_state (m_playbin, GST_STATE_PLAYING);
+						}
+					}
+				}
+			}
+			break;
+		}
+
+		case GST_MESSAGE_ERROR:
+		{
+			GError *err;
+			gst_message_parse_error (msg, &err, NULL);
+			if(err)
+			{
+				g_printerr ("CGstPlayerVideo::%s: Error - %s\n", __FUNCTION__, err->message);
+				g_error_free (err);
+				g_main_loop_quit(m_loop);
+			}
+			break;
+		}
+		
+		case GST_MESSAGE_TAG:
+		{
+			GstTagList *tags;
+			gst_message_parse_tag(msg, &tags);
+			
+			if(tags)
+			{
+				gchar *value;
+				if(gst_tag_list_get_string(tags, GST_TAG_TITLE, &value))
+				{
+					g_print("CGstPlayerVideo::%s: Info - %s\n", __FUNCTION__, value);
+					g_free(value);
+				}
+				gst_tag_list_free(tags);
+			}
+			break;
+		}
+			
+		default:
+			g_print("CGstPlayerVideo::%s: %"GST_PTR_FORMAT"\n", __FUNCTION__, msg);
+			break;
+	}
+	//g_free (sourceName);
+}
diff --git a/xbmc/cores/GstPlayer/GstPlayerVideo.h b/xbmc/cores/GstPlayer/GstPlayerVideo.h
new file mode 100644
index 0000000000..5e0ade3050
--- /dev/null
+++ b/xbmc/cores/GstPlayer/GstPlayerVideo.h
@@ -0,0 +1,170 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include <vector>
+#include <gst/gst.h>
+#include <gst/app/gstappsrc.h>
+
+#include "GstPlayerAudio.h"
+#include "utils/log.h"
+#include "cores/IPlayer.h"
+#include "GstPlayer.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+//#include "cores/VideoPlayer/DVDInputStreams/DVDInputStreamMemory.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.h"
+#include "cores/VideoPlayer/DVDInputStreams/DVDInputStream.h"
+
+#include "DVDStreamInfo.h"
+//#include "DVDMessageQueue.h"
+
+#undef FALSE
+#define FALSE 0
+
+class CProcessInfo;
+class IGstPlayerCallback;
+
+typedef enum {
+	GST_PLAY_FLAG_VIDEO		= (1 << 0),
+	GST_PLAY_FLAG_AUDIO		= (1 << 1),
+	GST_PLAY_FLAG_TEXT		= (1 << 2),
+	GST_PLAY_FLAG_VIS		= (1 << 3),
+	GST_PLAY_FLAG_SOFT_VOLUME	= (1 << 4),
+	GST_PLAY_FLAG_NATIVE_AUDIO	= (1 << 5),
+	GST_PLAY_FLAG_NATIVE_VIDEO	= (1 << 6),
+	GST_PLAY_FLAG_DOWNLOAD		= (1 << 7),
+	GST_PLAY_FLAG_BUFFERING		= (1 << 8),
+	GST_PLAY_FLAG_DEINTERLACE	= (1 << 9)
+} GstPlayFlags;
+
+class CGstPlayerVideo
+{
+public:
+	CGstPlayerVideo(IGstPlayerCallback *callback, CProcessInfo &processInfo);
+	~CGstPlayerVideo();
+	bool OpenStream(CDVDStreamInfo &hints, const CFileItem& file);
+	void CloseStream();
+	void Pause();
+	void SwitchToNextLanguage();
+	void ToggleSubtitles();
+	bool CanSeek();
+	void Seek(bool bPlus, bool bLargeStep, bool bChapterOverride);
+	void SwitchToNextAudioLanguage();
+	void SeekPercentage(float iPercent);
+	void SetAVDelay(float fValue);
+	float GetAVDelay();
+	void SetSubTitleDelay(float fValue);
+	float GetSubTitleDelay();
+	void SeekTime(int64_t iTime);
+	bool SeekTimeRelative(int64_t iTime);
+	int64_t GetTime();
+	int64_t GetTotalTime();
+	std::string GetPlayerState();
+	float GetRenderAspectRatio();
+	
+	int GetAudioStreamCount() { CLog::Log(LOGNOTICE, "%s: m_audio: %d", __FUNCTION__, m_audio); return (int)m_audio; };
+	int GetVideoStreamCount() { CLog::Log(LOGNOTICE, "%s: m_video: %d", __FUNCTION__, m_video); return (int)m_video; };
+	int GetSubtitleCount()    { CLog::Log(LOGNOTICE, "%s: m_text: %d", __FUNCTION__, m_text); return (int)m_text; };
+	
+	int GetAudioStream() { CLog::Log(LOGNOTICE, "%s: m_current_audio: %d", __FUNCTION__, m_current_audio); return (int)m_current_audio; };
+	int GetVideoStream() { CLog::Log(LOGNOTICE, "%s: m_current_video: %d", __FUNCTION__, m_current_video); return (int)m_current_video; };
+	int GetSubtitle()    { CLog::Log(LOGNOTICE, "%s: m_current_text: %d", __FUNCTION__, m_current_text); return (int)m_current_text; };
+	
+	struct sourceStream
+	{
+//		audiotype_t audiotype;
+//		containertype_t containertype;
+		gboolean is_audio;
+		gboolean is_video;
+		gboolean is_streaming;
+		gboolean is_hls;
+		sourceStream()
+			: /*audiotype(atUnknown), containertype(ctNone), */is_audio(FALSE), is_video(FALSE), is_streaming(FALSE), is_hls(FALSE)
+		{
+		}
+	};
+	
+	struct bufferInfo
+	{
+		gint bufferPercent;
+		gint avgInRate;
+		gint avgOutRate;
+		gint64 bufferingLeft;
+		bufferInfo()
+			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
+		{
+		}
+	};
+	
+private:
+	bool CreateFakePipeline();
+	bool CreatePipeline();
+	void DestroyPipeline();
+	
+	static void handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data);
+	static void NotifySource(GObject *object, GParamSpec *unused, gpointer user_data);
+	static void DeepNotifySource(GObject *object, GObject *orig, GParamSpec *pspec, gpointer user_data);
+	static void stopFeed(GstElement * playbin, gpointer user_data);
+	static void startFeed(GstElement * playbin, guint size, gpointer user_data);
+	static gboolean readData(gpointer user_data); 
+	static gboolean seekData(GstElement * appsrc, guint64 position, gpointer user_data);
+	static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *msg, gpointer data);
+	void handleMessage(GstMessage *msg);
+	void OnPipelineStart();
+	
+	int m_totalTime;
+	int m_time;
+	int m_playCountMinTime;
+	int m_buffer_size;
+	int m_ignore_buffering_messages;
+	
+	bufferInfo m_bufferInfo;
+	sourceStream m_sourceinfo;
+	
+	std::string m_useragent;
+	std::string m_extra_headers;
+	std::string m_download_buffer_path;
+	
+	bool m_use_prefillbuffer;
+	bool m_is_live;
+	bool m_first_paused;
+	bool m_paused;
+	
+	IGstPlayerCallback *m_callback;
+	
+	gchar *m_uri;
+	GMainLoop *m_loop;
+	GstElement *m_playbin, *m_appsrc;
+	gint m_aspect, m_width, m_height, m_framerate, m_progressive, m_video, m_audio, m_text, m_current_video, m_current_audio, m_current_text;
+	gulong m_notify_source_handler_id;
+	guint m_notify_element_added_handler_id, m_notify_source_id;
+	gsize m_length;
+	
+	guint64 m_offset;
+	
+protected:
+	CFileItem m_item;
+	CProcessInfo &m_processInfo;
+	//CDVDInputStreamMemory *m_pInputStream;  // input stream for current playing file
+	CDVDInputStreamFile *m_pInputStream;
+
+};
diff --git a/xbmc/cores/GstPlayer/Makefile b/xbmc/cores/GstPlayer/Makefile
new file mode 100644
index 0000000000..6d19c36d24
--- /dev/null
+++ b/xbmc/cores/GstPlayer/Makefile
@@ -0,0 +1,8 @@
+SRCS=GstPlayer.cpp
+SRCS+=GstPlayerAudio.cpp
+SRCS+=GstPlayerVideo.cpp
+
+LIB=GstPlayer.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamMemory.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamMemory.h
index 4f07647109..8498ec077d 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamMemory.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamMemory.h
@@ -33,6 +33,7 @@ public:
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool IsEOF();
   virtual int64_t GetLength();
+  virtual bool Pause(double dTime) { return false; };
 
 protected:
   uint8_t* m_pData;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
index f310338fe1..6ada073a72 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
@@ -51,6 +51,9 @@ CDVDInputStreamPVRManager::CDVDInputStreamPVRManager(IVideoPlayer* pPlayer, cons
   m_ScanTimeout.Set(0);
   m_isOtherStreamHack = false;
   m_demuxActive = false;
+#if defined(HAVE_LIBGSTREAMER)
+  m_isLocalHost = false;
+#endif
 
   m_StreamProps = new PVR_STREAM_PROPERTIES;
 }
@@ -154,8 +157,18 @@ bool CDVDInputStreamPVRManager::Open()
   std::string transFile = ThisIsAHack(m_item.GetPath());
   if(transFile.substr(0, 6) != "pvr://")
   {
+#if defined(HAVE_LIBGSTREAMER)
+    CURL pvrHost(transFile);
+    if (pvrHost.IsLocalHost())
+    {  
+      m_isLocalHost = true;
+      m_isOtherStreamHack = false;
+    }
+    else
+      m_isOtherStreamHack = true;
+#else
     m_isOtherStreamHack = true;
-    
+#endif
     m_item.SetPath(transFile);
     m_item.SetMimeTypeForInternetFile();
 
@@ -314,13 +327,21 @@ bool CDVDInputStreamPVRManager::NextChannel(bool preview/* = false*/)
   unsigned int newchannel;
   if (!preview && IsOtherStreamHack())
   {
+	CLog::Log(LOGNOTICE, "CGstPlayer::%s: !preview && IsOtherStreamHack()", __FUNCTION__);  
     CPVRChannelPtr channel(g_PVRManager.GetCurrentChannel());
     CFileItemPtr item(g_PVRChannelGroups->Get(channel->IsRadio())->GetSelectedGroup()->GetByChannelUp(channel));
     if (item)
+    {
+	 CLog::Log(LOGNOTICE, "CGstPlayer::%s: !preview && IsOtherStreamHack()", __FUNCTION__);     
       return CloseAndOpen(item->GetPath());
+    }
   }
   else if (!m_isRecording)
+  {
+	  CLog::Log(LOGNOTICE, "CGstPlayer::%s: !m_isRecording", __FUNCTION__);  
     return g_PVRManager.ChannelUp(&newchannel, preview);
+  }
+  CLog::Log(LOGNOTICE, "CGstPlayer::%s: return false", __FUNCTION__);  
   return false;
 }
 
@@ -468,6 +489,13 @@ bool CDVDInputStreamPVRManager::IsRealtime()
   return g_PVRClients->IsRealTimeStream();
 }
 
+#if defined(HAVE_LIBGSTREAMER)
+bool CDVDInputStreamPVRManager::IsLocalHost()
+{
+  return m_isLocalHost;
+}
+#endif
+    
 inline CDVDInputStream::IDemux* CDVDInputStreamPVRManager::GetIDemux()
 {
   if (m_demuxActive)
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h
index baf819f149..f1c4b9c7f0 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h
@@ -70,6 +70,9 @@ public:
 
   bool CanRecord();
   bool IsRecording();
+#if defined(HAVE_LIBGSTREAMER)
+  bool IsLocalHost();
+#endif
   void Record(bool bOnOff);
   bool CanSeek() override;
   bool CanPause() override;
@@ -121,6 +124,9 @@ protected:
   PVR_STREAM_PROPERTIES *m_StreamProps;
   std::map<int, std::shared_ptr<CDemuxStream>> m_streamMap;
   bool m_isRecording;
+#if defined(HAVE_LIBGSTREAMER)
+  bool m_isLocalHost;
+#endif
 };
 
 
diff --git a/xbmc/cores/playercorefactory/PlayerCoreConfig.h b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
index 15a6570a27..22cc2465c4 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreConfig.h
+++ b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
@@ -30,6 +30,10 @@
 #endif
 #include "utils/log.h"
 
+#if defined(HAVE_LIBGSTREAMER)
+  #include "cores/GstPlayer/GstPlayer.h"
+#endif
+
 class CPlayerCoreConfig
 {
 public:
@@ -93,6 +97,12 @@ public:
     {
       pPlayer = new PAPlayer(callback);
     }
+#if defined(HAVE_LIBGSTREAMER)
+    else if (m_type.compare("gstreamer") == 0)
+    {
+      pPlayer = new CGstPlayer(callback);
+    }
+#endif
     else if (m_type.compare("external") == 0)
     {
       pPlayer = new CExternalPlayer(callback);
diff --git a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp b/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
index 896b865895..1e41a59a0e 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
+++ b/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
@@ -34,6 +34,10 @@
 #include "utils/XMLUtils.h"
 #include <sstream>
 
+#if defined(HAVE_LIBGSTREAMER)
+  #include "cores/GstPlayer/GstPlayer.h"
+#endif
+
 #define PLAYERCOREFACTORY_XML "playercorefactory.xml"
 
 CPlayerCoreFactory::CPlayerCoreFactory()
@@ -315,6 +319,12 @@ bool CPlayerCoreFactory::LoadConfiguration(const std::string &file, bool clear)
     m_vecCoreSelectionRules.clear();
 
     // Builtin players
+#if defined(HAVE_LIBGSTREAMER)
+    CPlayerCoreConfig* GstPlayer = new CPlayerCoreConfig("GstPlayer", "gstreamer", nullptr);
+    GstPlayer->m_bPlaysAudio = true;
+    GstPlayer->m_bPlaysVideo = true;
+    m_vecPlayerConfigs.push_back(GstPlayer);
+#endif
     CPlayerCoreConfig* VideoPlayer = new CPlayerCoreConfig("VideoPlayer", "video", nullptr);
     VideoPlayer->m_bPlaysAudio = true;
     VideoPlayer->m_bPlaysVideo = true;
@@ -323,6 +333,7 @@ bool CPlayerCoreFactory::LoadConfiguration(const std::string &file, bool clear)
     CPlayerCoreConfig* paplayer = new CPlayerCoreConfig("PAPlayer", "music", nullptr);
     paplayer->m_bPlaysAudio = true;
     m_vecPlayerConfigs.push_back(paplayer);
+    
   }
 
   if (!pConfig || strcmpi(pConfig->Value(), "playercorefactory") != 0)
@@ -347,6 +358,10 @@ bool CPlayerCoreFactory::LoadConfiguration(const std::string &file, bool clear)
         internaltype = "video";
       else if (type == "paplayer")
         internaltype = "music";
+#if defined(HAVE_LIBGSTREAMER)
+      else if (type == "gstplayer")
+        internaltype = "gstreamer";
+#endif
       else if (type == "externalplayer")
         internaltype = "external";
 
diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index c8fe0706d1..2efaae47e3 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -22,6 +22,7 @@
 #include "guilib/GUIProgressControl.h"
 #include "guilib/GUIWindowManager.h"
 #include "threads/Thread.h"
+#include "utils/log.h"
 
 #define PROGRESS_CONTROL 10
 
@@ -60,25 +61,31 @@ bool CGUIDialogBusy::Wait(IRunnable *runnable)
 
 bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 100 */, bool allowCancel /* = true */)
 {
+	CLog::Log(LOGNOTICE, "CGUIDialogBusy::%s: displaytime=%d allowCancel=%s", __FUNCTION__, displaytime, allowCancel == true ? "true":"false" ); 
   bool cancelled = false;
   if (!event.WaitMSec(displaytime))
   {
+	  CLog::Log(LOGNOTICE, "CGUIDialogBusy::%s: !event.WaitMSec(displaytime)", __FUNCTION__); 
     // throw up the progress
     CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
     if (dialog)
     {
+	  CLog::Log(LOGNOTICE, "CGUIDialogBusy::%s: dialog->Open();", __FUNCTION__);   
       dialog->Open();
 
+      int timer =0;
       while(!event.WaitMSec(1))
       {
+	      CLog::Log(LOGNOTICE, "CGUIDialogBusy::%s: !event.WaitMSec timer=%d;", __FUNCTION__,++timer);
         dialog->ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())
         {
+		CLog::Log(LOGNOTICE, "CGUIDialogBusy::%s: allowCancel && dialog->IsCanceled();", __FUNCTION__);
           cancelled = true;
           break;
         }
       }
-      
+      CLog::Log(LOGNOTICE, "CGUIDialogBusy::%s: dialog->Close();", __FUNCTION__);
       dialog->Close();
     }
   }
diff --git a/xbmc/pvr/PVRManager.cpp b/xbmc/pvr/PVRManager.cpp
index 18f8fbdd32..4a8791aacd 100644
--- a/xbmc/pvr/PVRManager.cpp
+++ b/xbmc/pvr/PVRManager.cpp
@@ -1407,8 +1407,12 @@ bool CPVRManager::PlayMedia(const CFileItem& item)
     CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PLAY, -1, -1, static_cast<void*>(l));
     return true;
   }
-
+  
+#if defined(HAVE_LIBGSTREAMER)
+  return g_application.PlayFile(pvrItem, "gstplayer", false) == PLAYBACK_OK;
+#else
   return g_application.PlayFile(pvrItem, "videoplayer", false) == PLAYBACK_OK;
+#endif
 }
 
 void CPVRManager::UpdateCurrentChannel(void)
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index aa802635ba..1a97840edd 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -140,7 +140,7 @@ void CAdvancedSettings::Initialize()
 
   m_videoPPFFmpegDeint = "linblenddeint";
   m_videoPPFFmpegPostProc = "ha:128:7,va,dr";
-  m_videoDefaultPlayer = "VideoPlayer";
+  m_videoDefaultPlayer = "GstPlayer";
   m_videoIgnoreSecondsAtStart = 3*60;
   m_videoIgnorePercentAtEnd   = 8.0f;
   m_videoPlayCountMinimumPercent = 90.0f;
diff --git a/xbmc/video/windows/GUIWindowFullScreen.cpp b/xbmc/video/windows/GUIWindowFullScreen.cpp
index 4d2a37edeb..dc7e666848 100644
--- a/xbmc/video/windows/GUIWindowFullScreen.cpp
+++ b/xbmc/video/windows/GUIWindowFullScreen.cpp
@@ -45,6 +45,8 @@
 #include "guiinfo/GUIInfoLabels.h"
 #include "video/ViewModeSettings.h"
 
+#include "utils/log.h"
+
 #include <stdio.h>
 #include <algorithm>
 #if defined(TARGET_DARWIN)
@@ -117,33 +119,39 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
 
   switch (action.GetID())
   {
-  case ACTION_SHOW_OSD:
+  case ACTION_SHOW_OSD:{
+	  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_SHOW_OSD...", __FUNCTION__);
     ToggleOSD();
-    return true;
+    return true;}
 
-  case ACTION_TRIGGER_OSD:
+  case ACTION_TRIGGER_OSD: {
+	  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_TRIGGER_OSD...", __FUNCTION__);
     TriggerOSD();
-    return true;
+    return true;}
 
   case ACTION_SHOW_GUI:
     {
+	  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_SHOW_GUI...", __FUNCTION__);
       // switch back to the menu
       g_windowManager.PreviousWindow();
       return true;
     }
     break;
 
-  case ACTION_SHOW_OSD_TIME:
+  case ACTION_SHOW_OSD_TIME: {
+	  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_SHOW_OSD_TIME...", __FUNCTION__);
     m_bShowCurrentTime = !m_bShowCurrentTime;
     g_infoManager.SetShowTime(m_bShowCurrentTime);
     return true;
-    break;
+    break;}
 
   case ACTION_SHOW_INFO:
     {
       CGUIDialogFullScreenInfo* pDialog = (CGUIDialogFullScreenInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_FULLSCREEN_INFO);
+      CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_SHOW_INFO...", __FUNCTION__);
       if (pDialog)
       {
+	     CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_SHOW_INFO...if (pDialog)", __FUNCTION__); 
         CFileItem item(g_application.CurrentFileItem());
         pDialog->Open();
         return true;
@@ -152,11 +160,13 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
     }
 
   case ACTION_ASPECT_RATIO:
+	  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_ASPECT_RATIO...", __FUNCTION__);
     { // toggle the aspect ratio mode (only if the info is onscreen)
       if (m_bShowViewModeInfo)
       {
 #ifdef HAS_VIDEO_PLAYBACK
         g_application.m_pPlayer->SetRenderViewMode(CViewModeSettings::GetNextQuickCycleViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode));
+	CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_ASPECT_RATIO...if (m_bShowViewModeInfo)", __FUNCTION__);
 #endif
       }
       m_bShowViewModeInfo = true;
@@ -166,6 +176,7 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
     break;
   case ACTION_SHOW_PLAYLIST:
     {
+	  //  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ACTION_SHOW_PLAYLIST...", __FUNCTION__);
       CFileItem item(g_application.CurrentFileItem());
       if (item.HasPVRChannelInfoTag())
         g_windowManager.ActivateWindow(WINDOW_DIALOG_PVR_OSD_CHANNELS);
@@ -185,6 +196,7 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
 
 void CGUIWindowFullScreen::ClearBackground()
 {
+//	CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ", __FUNCTION__);
   if (g_application.m_pPlayer->IsRenderingVideoLayer())
 #ifdef HAS_IMXVPU
     g_graphicsContext.Clear((16 << 16)|(8 << 8)|16);
@@ -195,6 +207,7 @@ void CGUIWindowFullScreen::ClearBackground()
 
 void CGUIWindowFullScreen::OnWindowLoaded()
 {
+//	CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ", __FUNCTION__);
   CGUIWindow::OnWindowLoaded();
   // override the clear colour - we must never clear fullscreen
   m_clearBackground = 0;
@@ -204,6 +217,7 @@ void CGUIWindowFullScreen::OnWindowLoaded()
   {
     if( pProgress->GetInfo() == 0 || !pProgress->HasVisibleCondition())
     {
+	  //  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: pProgress->GetInfo() == 0", __FUNCTION__);
       pProgress->SetInfo(PLAYER_PROGRESS);
       pProgress->SetVisibleCondition("player.displayafterseek");
       pProgress->SetVisible(true);
@@ -213,6 +227,7 @@ void CGUIWindowFullScreen::OnWindowLoaded()
   CGUILabelControl* pLabel = dynamic_cast<CGUILabelControl*>(GetControl(LABEL_BUFFERING));
   if(pLabel && !pLabel->HasVisibleCondition())
   {
+	  //CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: !pLabel->HasVisibleCondition()", __FUNCTION__);
     pLabel->SetVisibleCondition("player.caching");
     pLabel->SetVisible(true);
   }
@@ -220,6 +235,7 @@ void CGUIWindowFullScreen::OnWindowLoaded()
   pLabel = dynamic_cast<CGUILabelControl*>(GetControl(LABEL_CURRENT_TIME));
   if(pLabel && !pLabel->HasVisibleCondition())
   {
+	  //CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: !pLabel->HasVisibleCondition()", __FUNCTION__);
     pLabel->SetVisibleCondition("player.displayafterseek");
     pLabel->SetVisible(true);
     pLabel->SetLabel("$INFO(VIDEOPLAYER.TIME) / $INFO(VIDEOPLAYER.DURATION)");
@@ -232,6 +248,7 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
   {
   case GUI_MSG_WINDOW_INIT:
     {
+	  //  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: GUI_MSG_WINDOW_INIT...", __FUNCTION__);
       // check whether we've come back here from a window during which time we've actually
       // stopped playing videos
       if (message.GetParam1() == WINDOW_INVALID && !g_application.m_pPlayer->IsPlayingVideo())
@@ -255,6 +272,7 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
     }
   case GUI_MSG_WINDOW_DEINIT:
     {
+	  //  CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: GUI_MSG_WINDOW_DEINIT...", __FUNCTION__);
       // close all active modal dialogs
       g_windowManager.CloseInternalModalDialogs(true);
 
@@ -270,6 +288,7 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
     }
   case GUI_MSG_SETFOCUS:
   case GUI_MSG_LOSTFOCUS:
+	  //CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: FOCUS", __FUNCTION__);
     if (message.GetSenderId() != WINDOW_FULLSCREEN_VIDEO) return true;
     break;
   }
@@ -299,6 +318,7 @@ EVENT_RESULT CGUIWindowFullScreen::OnMouseEvent(const CPoint &point, const CMous
 
 void CGUIWindowFullScreen::FrameMove()
 {
+//	 CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s:", __FUNCTION__);
   float playspeed = g_application.m_pPlayer->GetPlaySpeed();
   if (playspeed < 0.75 || playspeed > 1.55)
     g_infoManager.SetDisplayAfterSeek();
@@ -316,6 +336,7 @@ void CGUIWindowFullScreen::FrameMove()
   if (m_bShowViewModeInfo)
   {
     RESOLUTION_INFO res = g_graphicsContext.GetResInfo();
+    CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: RESOLUTION_INFO", __FUNCTION__);
 
     {
       // get the "View Mode" string
@@ -374,6 +395,7 @@ void CGUIWindowFullScreen::FrameMove()
 
   if (m_bShowViewModeInfo)
   {
+	  //CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: if (m_bShowViewModeInfo)", __FUNCTION__);
     SET_CONTROL_VISIBLE(LABEL_ROW1);
     SET_CONTROL_VISIBLE(LABEL_ROW2);
     SET_CONTROL_VISIBLE(LABEL_ROW3);
@@ -381,6 +403,7 @@ void CGUIWindowFullScreen::FrameMove()
   }
   else
   {
+	  //CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: !if (m_bShowViewModeInfo)", __FUNCTION__);
     SET_CONTROL_HIDDEN(LABEL_ROW1);
     SET_CONTROL_HIDDEN(LABEL_ROW2);
     SET_CONTROL_HIDDEN(LABEL_ROW3);
@@ -418,6 +441,7 @@ void CGUIWindowFullScreen::RenderEx()
 
 void CGUIWindowFullScreen::SeekChapter(int iChapter)
 {
+	CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ", __FUNCTION__);
   g_application.m_pPlayer->SeekChapter(iChapter);
 
   // Make sure gui items are visible.
@@ -426,6 +450,7 @@ void CGUIWindowFullScreen::SeekChapter(int iChapter)
 
 void CGUIWindowFullScreen::ToggleOSD()
 {
+	CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ", __FUNCTION__);
   CGUIDialogVideoOSD *pOSD = (CGUIDialogVideoOSD *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_OSD);
   if (pOSD)
   {
@@ -440,6 +465,7 @@ void CGUIWindowFullScreen::ToggleOSD()
 
 void CGUIWindowFullScreen::TriggerOSD()
 {
+	CLog::Log(LOGNOTICE, "CGUIWindowFullScreen::%s: ", __FUNCTION__);
   CGUIDialogVideoOSD *pOSD = (CGUIDialogVideoOSD *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_OSD);
   if (pOSD && !pOSD->IsDialogRunning())
   {
-- 
2.17.0.windows.1

