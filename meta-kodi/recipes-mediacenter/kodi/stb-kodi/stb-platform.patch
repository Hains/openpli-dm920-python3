From a01405f76d7bf21e2f68b96512a256e390c47faf Mon Sep 17 00:00:00 2001
From: captain <openatv@gmail.com>
Date: Wed, 16 May 2018 12:45:11 +0200
Subject: [PATCH 1/5] stb-platform

---
 Makefile.in                                  |  20 +-
 configure.ac                                 | 167 +++++++++++++-
 m4/xbmc_arch.m4                              |  36 +++
 project/cmake/scripts/linux/ArchSetup.cmake  |   6 +-
 tools/depends/configure.ac                   |  80 +++++++
 tools/depends/target/ffmpeg/autobuild.sh     |  16 +-
 xbmc/addons/AddonManager.cpp                 |  12 +
 xbmc/platform/xbmc.cpp                       |   9 +
 xbmc/system_gl.h                             |   3 +
 xbmc/utils/DreamboxUtils.cpp                 | 102 +++++++++
 xbmc/utils/DreamboxUtils.h                   |  24 ++
 xbmc/utils/Makefile.in                       |   4 +
 xbmc/windowing/egl/EGLNativeTypeDreambox.cpp | 191 ++++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeDreambox.h   |  61 +++++
 xbmc/windowing/egl/EGLNativeTypeGB.cpp       | 189 +++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeGB.h         |  56 +++++
 xbmc/windowing/egl/EGLNativeTypeMali.cpp     | 149 ++++++++++++
 xbmc/windowing/egl/EGLNativeTypeMali.h       |  53 +++++
 xbmc/windowing/egl/EGLNativeTypeNexTV.cpp    | 229 +++++++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeNexTV.h      | 196 ++++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeDags.cpp     | 358 ++++++++++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeDags.h       | 196 ++++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeV3D.cpp      | 161 +++++++++++++
 xbmc/windowing/egl/EGLNativeTypeV3D.h        |  59 +++++
 xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp  | 208 +++++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h    | 129 +++++++++++
 xbmc/windowing/egl/EGLNativeTypeVuplus.cpp   | 180 +++++++++++++++
 xbmc/windowing/egl/EGLNativeTypeVuplus.h     |  60 +++++
 xbmc/windowing/egl/EGLWrapper.cpp            |  35 +++
 xbmc/windowing/egl/Makefile.in               |  21 ++
 28 files changed, 2446 insertions(+), 10 deletions(-)
 create mode 100644 xbmc/utils/DreamboxUtils.cpp
 create mode 100644 xbmc/utils/DreamboxUtils.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeDreambox.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeDreambox.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeGB.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeGB.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeMali.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeMali.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeNexTV.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeNexTV.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeDags.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeDags.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeV3D.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeV3D.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeVuplus.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeVuplus.h

diff --git a/Makefile.in b/Makefile.in
index 3c5de7c367..984fd00091 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -423,6 +423,24 @@ MAINOBJS+=xbmc/platform/darwin/osx/sdlmain.a
 endif
 endif # USE_ANDROID
 
+ifeq (@USE_VUPLUS@,1)
+ifeq (@USE_VUPLUS_ARM_LIB@,1)
+LIBS+= -lKodiGLESPL -ldvb_base -lnxpl -ldvb_client
+VUPLUS_EXTLIBS=${null}
+endif
+ifeq (@USE_VUPLUS_MIPSEL_LIB@,1)
+VUPLUS_SUPPORT=$(shell cd ../xbmc-support; pwd)
+VUPLUS_EXTLIBS= xbmc/windowing/egl/gles_init.a -ldvb_base -lnxpl -ldvb_client -L$(VUPLUS_SUPPORT) -lxbmc_base
+endif
+else
+VUPLUS_EXTLIBS=${null}
+endif
+
+ifeq (@USE_GB@,1)
+GB_EXTLIBS= xbmc/windowing/egl/gles_init.a
+else
+GB_EXTLIBS=${null}
+endif
 
 OBJSXBMC =$(DIRECTORY_ARCHIVES)
 OBJSXBMC:=$(filter-out $(DYNOBJSXBMC), $(OBJSXBMC))
@@ -450,7 +468,7 @@ endif
 ifeq ($(findstring osx,@ARCH@), osx)
 	$(SILENT_LD) $(CXX) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,-all_load,-ObjC $(MAINOBJS) $(DYNOBJSXBMC) $(NWAOBJSXBMC) $(OBJSXBMC) $(LIBS) -rdynamic
 else
-	$(SILENT_LD) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,--start-group $(MAINOBJS) $(DYNOBJSXBMC) $(OBJSXBMC) -Wl,--end-group $(NWAOBJSXBMC) $(LIBS) -rdynamic
+	$(SILENT_LD) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o @APP_NAME_LC@.bin $(MAINOBJS) -Wl,--start-group $(MAINOBJS) $(DYNOBJSXBMC) $(OBJSXBMC) -Wl,--end-group $(NWAOBJSXBMC) $(LIBS) -rdynamic $(VUPLUS_EXTLIBS) $(GB_EXTLIBS)
 endif
 
 @APP_NAME_LC@-xrandr: xbmc-xrandr.c
diff --git a/configure.ac b/configure.ac
index 71e942b..aba6530 100644
--- a/configure.ac
+++ b/configure.ac
@@ -681,6 +681,88 @@ case $use_platform in
      use_neon=yes
      use_cpu=cortex-a7
      ;;
+  dags-cortexa15)
+     USE_DAGS=1
+     target_platform=target_v3d
+     target_videoplatform=target_dags
+     use_cpu=cortex-a15
+     ;;
+  dreambox-cortexa15)
+     USE_DREAMBOX=1
+     target_platform=target_v3d
+     target_videoplatform=target_dreambox
+     use_cpu=cortex-a15
+     ;;
+  dreambox-mipsel)
+     USE_DREAMBOX=1
+     target_platform=target_v3d
+     target_videoplatform=target_dreambox
+     use_neon=yes
+     use_gles=yes
+     use_sdl=no
+     ;;
+  vuplus-cortexa15)
+     USE_VUPLUS=1
+     USE_VUPLUS_ARM_LIB=1
+     target_platform=target_v3d
+     target_videoplatform=target_vuplus
+     target_videoplatform_arch=target_vuplus_arm
+     use_cpu=cortex-a15
+     ;;
+  vuplus-mipsel)
+     USE_VUPLUS=1
+     USE_VUPLUS_MIPSEL_LIB=1
+     target_platform=target_v3d
+     target_videoplatform=target_vuplus
+     target_videoplatform_arch=target_vuplus_mipsel
+     use_neon=yes
+     use_gles=yes
+     use_sdl=no
+     ;;
+  v3d-cortexa15)
+     USE_V3DNXPL=1
+     target_platform=target_v3d
+     target_videoplatform=target_v3dnxpl
+     use_cpu=cortex-a15
+     ;;
+  v3d-mipsel)
+     USE_V3DNXPL=1
+     target_platform=target_v3d
+     target_videoplatform=target_v3dnxpl
+     use_neon=yes
+     use_gles=yes
+     use_sdl=no
+     ;;
+  xcore-mipsel)
+     USE_XCORE=1
+     target_platform=target_v3d
+     target_videoplatform=target_xcore
+     use_gles=yes
+     use_sdl=no
+     ;;
+  nextv-cortexa15)
+     USE_NEXTV=1
+     target_platform=target_v3d
+     target_videoplatform=target_nextv
+     use_cpu=cortex-a15
+     ;;
+  GB-cortexa15)
+     USE_GB=1
+     target_platform=target_v3d
+     target_videoplatform=target_GB
+     use_cpu=cortex-a15
+     ;;
+  mali-cortexa15)
+     USE_MALI=1
+     target_platform=target_mali
+     target_videoplatform=target_mali
+     use_cpu=cortex-a15
+     ;;
+  aml-aarch64)
+     add_codecs=amcodec
+     target_videoplatform=target_aml
+     ;;
+
 esac
 
 if test "$target_platform" = "target_raspberry_pi" ; then
@@ -696,6 +778,20 @@ if test "$target_platform" = "target_raspberry_pi" ; then
      CXXFLAGS="$CXXFLAGS"
 fi
 
+if test "$target_platform" = "target_v3d" ; then
+     use_openmax=no
+     CORE_SYSTEM_NAME=linux
+     CFLAGS="$CFLAGS"
+     CXXFLAGS="$CXXFLAGS"
+fi
+
+if test "$target_platform" = "target_mali" ; then
+     use_openmax=no
+     CORE_SYSTEM_NAME=linux
+     CFLAGS="$CFLAGS"
+     CXXFLAGS="$CXXFLAGS"
+fi
+
 if test "$host_vendor" = "apple"; then
   use_avahi=no
   use_alsa=no
@@ -819,6 +915,15 @@ elif test "$use_arch" = "arm"; then
       [ CFLAGS="$SAVE_CFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"
         CXXFLAGS="$CXXFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"
         use_cpu=cortex-a8])
+  elif test "$use_cpu" = "cortex-a15"; then
+    # Compile for ARMv7ve architecture
+    SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="-mfpu=neon-vfpv4"
+    AC_COMPILE_IFELSE(
+      [AC_LANG_SOURCE([int foo;])],
+      [ CFLAGS="$SAVE_CFLAGS -Wno-psabi -Wa,-march=armv7ve -mtune=cortex-a15 -mfpu=neon-vfpv4 -mvectorize-with-neon-quad"
+        CXXFLAGS="$CXXFLAGS -Wno-psabi -Wa,-march=armv7ve -mtune=cortex-a15 -mfpu=neon-vfpv4 -mvectorize-with-neon-quad"
+        use_cpu=cortex-a15])
   else
     if test "$use_neon" = "yes"; then
       CFLAGS="$CFLAGS -mfpu=neon -mvectorize-with-neon-quad"
@@ -912,6 +1017,9 @@ if test "x$have_builtin_sync_val_compare_and_swap" = "xyes"; then
         [Define to 1 if your compiler supports the __sync_val_compare_and_swap() intrinsic.])
 fi
 
+# check if libatomic is available
+AC_CHECK_LIB([atomic], [__atomic_add_fetch_8], [LIBS="$LIBS -latomic"],)
+
 # Check for u16string/u32string declarations
 AC_LANG_PUSH([C++])
 AC_CHECK_TYPES([std::u16string, std::u32string], [], [], [[#include <string>]])
@@ -944,16 +1052,50 @@ if test "$use_gles" = "yes"; then
     AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
     AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
     AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
-  else
-    if test "$target_platform" = "target_raspberry_pi"; then
+  elif test "$target_platform" = "target_raspberry_pi"; then
       AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
       AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
       AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
       LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm -lmmal -lmmal_core -lmmal_util -lvcsm"
-    else
+  elif test "$target_videoplatform" = "target_v3dnxpl" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES v3dnxpl support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lnxpl -lnexus"
+  elif test "$target_videoplatform" = "target_vuplus" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES vuplus support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2"
+  elif test "$target_videoplatform" = "target_xcore" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
+      AC_MSG_RESULT(== WARNING: OpenGLES xcore support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lv3dplatform"
+  elif test "$target_videoplatform" = "target_nextv" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES nextv support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lnexus -lnxpl -lnxclient"
+  elif test "$target_videoplatform" = "target_dags" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES dags support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lnexus -lnxpl -lnxclient"
+  elif test "$target_videoplatform" = "target_GB" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES GB support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lnxpl -lnexus -lnxclient"
+  elif test "$target_videoplatform" = "target_mali" ; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES mali support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lmali"
+  else
       AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
       AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
-    fi
   fi
 else
   if test "$use_gl" = "yes"; then
@@ -1056,7 +1198,7 @@ int main() {
   )])
 AC_LANG_POP([C++])
 
-if test "${target_platform}" = "target_linux" || test "${target_platform}" = "target_raspberry_pi" || test "${target_platform}" = "target_android"; then
+if test "${target_platform}" = "target_linux" || test "${target_platform}" = "target_raspberry_pi" || test "${target_platform}" = "target_android" || test "${target_platform}" = "target_v3d" || test "${target_platform}" = "target_mali"; then
   PKG_CHECK_MODULES([UUID], [uuid],, AC_MSG_ERROR(libuuid not found))
 fi
 
@@ -1556,7 +1698,14 @@ if test "${USE_STATIC_FFMPEG}" = "1"; then
       pkg_cfg_prefix=${SYSROOT}
   fi
 
-  if test "$cross_compiling" != "yes"; then
+  if test "$with_ffmpeg" = "stb"; then
+    AC_MSG_NOTICE("FFmpeg installation forced by user - installing our version")
+    CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" NM="$NM" AR="$AR" \
+    AS="$AS" STRIP="$STRIP" CC="$CC" CXX="$CXX" LD="$CCLD" RANLIB="$RANLIB" \
+    ${ffmpeg_build}/autobuild.sh ${FFMPEG_OPTS} ${PARALLEL_MAKE} --arch=generic
+    export PKG_CONFIG_PATH="${ffmpeg_build}/ffmpeg-install/lib/pkgconfig:$PKG_CONFIG_PATH"
+
+  elif test "$cross_compiling" != "yes"; then
     if test "$use_debug" != "yes"; then
       FFMPEG_OPTS="-r"
     fi
@@ -1611,11 +1760,17 @@ if test "$FFMPEG_FOUND" != "true"; then
   PKG_CHECK_MODULES([FFMPEG], [$FFMPEG_LIBNAMES],
     [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"; FFMPEG_FOUND="true"],
     [AC_MSG_ERROR("ffmpeg not found")])
+    if test "$with_ffmpeg" = "stb"; then
+      FFMPEG_LIBS=$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --libs libavcodec 2>/dev/null)
+      FFMPEG_CFLAGS=$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --cflags libavcodec 2>/dev/null)
+      INCLUDES="$INCLUDES $FFMPEG_CFLAGS"
+      LIBS="$LIBS $FFMPEG_LIBS"
+    fi
 fi
 
 if test "${USE_STATIC_FFMPEG}" = "1"; then
   # get the libdir for static linking
-  FFMPEG_LIBDIR=${pkg_cfg_prefix}$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --static --variable=libdir libavcodec)
+  FFMPEG_LIBDIR=$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --static --variable=libdir libavcodec)
   GNUTLS_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors gnutls)
 
   # check if static libs are available
@@ -2330,6 +2485,16 @@ AC_SUBST(HAVE_SSE4)
 AC_SUBST(USE_MMAL)
 AC_SUBST(USE_X11)
 AC_SUBST(USE_OPTICAL_DRIVE)
+AC_SUBST(USE_V3DNXPL)
+AC_SUBST(USE_DREAMBOX)
+AC_SUBST(USE_XCORE)
+AC_SUBST(USE_VUPLUS)
+AC_SUBST(USE_VUPLUS_ARM_LIB)
+AC_SUBST(USE_VUPLUS_MIPSEL_LIB)
+AC_SUBST(USE_NEXTV)
+AC_SUBST(USE_DAGS)
+AC_SUBST(USE_GB)
+AC_SUBST(USE_MALI)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
diff --git a/m4/xbmc_arch.m4 b/m4/xbmc_arch.m4
index d28f263..634f046 100644
--- a/m4/xbmc_arch.m4
+++ b/m4/xbmc_arch.m4
@@ -80,4 +80,43 @@ fi
 if test "$target_platform" = "target_raspberry_pi" ; then
   AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_ARMEL -DTARGET_RASPBERRY_PI")
 fi
+
+if test "$target_videoplatform" = "target_xcore" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_XCORE")
+fi
+
+if test "$target_videoplatform" = "target_v3dnxpl" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_V3DNXPL")
+fi
+
+if test "$target_videoplatform" = "target_dreambox" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_DREAMBOX")
+fi
+
+if test "$target_videoplatform_arch" = "target_vuplus_arm" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_VUPLUS -DTARGET_VUPLUS_ARM")
+fi
+
+if test "$target_videoplatform_arch" = "target_vuplus_mipsel" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_VUPLUS -DTARGET_VUPLUS_MIPSEL")
+fi
+
+if test "$target_videoplatform" = "target_nextv" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_NEXTV")
+fi
+
+if test "$target_videoplatform" = "target_dags" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_DAGS")
+fi
+
+if test "$target_videoplatform" = "target_GB" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_V3D -DTARGET_GB")
+fi
+
+if test "$target_videoplatform" = "target_mali" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_STB_EXTEND -DTARGET_MALI")
+fi
+if test "$target_videoplatform" = "target_aml" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_STB -DTARGET_AML")
+fi
 ])
diff --git a/project/cmake/scripts/linux/ArchSetup.cmake b/project/cmake/scripts/linux/ArchSetup.cmake
index c0cc1bf283..dd20f6141c 100644
--- a/project/cmake/scripts/linux/ArchSetup.cmake
+++ b/project/cmake/scripts/linux/ArchSetup.cmake
@@ -13,7 +13,11 @@ else()
     set(ARCH i486-linux)
     set(NEON False)
     add_options(CXX ALL_BUILDS "-msse")
-  elseif(CPU MATCHES arm)
+  elseif(CPU MATCHES cortex-a15)
+    set(ARCH arm)
+    set(NEON True)
+    set(NEON_FLAGS "-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4 -mvectorize-with-neon-quad")
+  elseif(CPU MATCHES arm )
     set(ARCH arm)
     set(NEON True)
     set(NEON_FLAGS "-mfpu=neon -mvectorize-with-neon-quad")
diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index 3626ea5..a108894 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -408,6 +408,94 @@ case $use_platform in
      platform_cxxflags="-fPIC -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4"
      platform_ldflags="-lpthread"
      ;;
+  v3d-mipsel)
+    use_cpu=$host_cpu
+    use_toolchain="${use_toolchain:-/usr}"
+    platform_cflags="-Os -fPIC -DPIC"
+    platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
+    platform_cxxflags="$platform_cflags"
+    platform_os="linux"
+  ;;
+  xcore-mipsel)
+    use_cpu=$host_cpu
+    use_toolchain="${use_toolchain:-/usr}"
+    platform_cflags="-Os -fPIC -DPIC"
+    platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
+    platform_cxxflags="$platform_cflags"
+    platform_os="linux"
+  ;;
+  v3d-cortexa15)
+     target_platform=v3d
+     use_neon=yes
+     use_cpu=cortex-a15
+     platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
+  dags-cortexa15)
+    target_platform=v3d
+    use_neon=yes
+    use_cpu=cortex-a15
+    platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+    platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+    platform_ldflags="-lpthread"
+  ;;
+  dreambox-cortexa15)
+     target_platform=v3d
+     use_neon=yes
+     use_cpu=cortex-a15
+     platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
+  dreambox-mipsel)
+    use_cpu=$host_cpu
+    use_toolchain="${use_toolchain:-/usr}"
+    platform_cflags="-Os -fPIC -DPIC"
+    platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
+    platform_cxxflags="$platform_cflags"
+    platform_os="linux"
+  ;;
+  vuplus-cortexa15)
+     target_platform=v3d
+     use_neon=yes
+     use_cpu=cortex-a15
+     platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
+  vuplus-mipsel)
+    use_cpu=$host_cpu
+    use_toolchain="${use_toolchain:-/usr}"
+    platform_cflags="-Os -fPIC -DPIC"
+    platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
+    platform_cxxflags="$platform_cflags"
+    platform_os="linux"
+  ;;
+  nextv-cortexa15)
+    target_platform=v3d
+    use_neon=yes
+    use_cpu=cortex-a15
+    platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+    platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+    platform_ldflags="-lpthread"
+  ;;
+  GB-cortexa15)
+     target_platform=v3d
+     use_neon=yes
+     use_cpu=cortex-a15
+     platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
+  mali-cortexa15)
+     target_platform=mali
+     use_neon=yes
+     use_cpu=cortex-a15
+     platform_cflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a15 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
 esac
 
 if test "$target_platform" = "raspberry-pi" ; then
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index 5c2976278e..db8897cb42 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -116,7 +116,7 @@ then
 fi
 
 [ -f ${ARCHIVE} ] ||
-  curl -Ls --create-dirs -f -o ${ARCHIVE} ${BASE_URL}/${VERSION}.tar.gz ||
+  curl -k -Ls --create-dirs -f -o ${ARCHIVE} ${BASE_URL}/${VERSION}.tar.gz ||
   { echo "error fetching ${BASE_URL}/${VERSION}.tar.gz" ; exit 3; }
 [ $downloadonly ] && exit 0
 
@@ -134,6 +134,20 @@ tar --strip-components=1 -xf $MYDIR/${ARCHIVE}
 
 CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 ./configure --prefix=$FFMPEG_PREFIX \
+	--bindir="$FFMPEG_PREFIX/bin" \
+	--libdir="$FFMPEG_PREFIX/lib" \
+	--incdir="$FFMPEG_PREFIX/include" \
+	--pkgconfigdir="$FFMPEG_PREFIX/lib/pkgconfig" \
+	--target-os=linux \
+	--enable-cross-compile \
+	--nm="$NM" \
+	--ar="$AR" \
+	--as="$AS" \
+	--strip="$STRIP" \
+	--cc="$CC" \
+	--cxx="$CXX" \
+	--ld="$CCLD" \
+	--ranlib="$RANLIB" \
 	--extra-version="kodi-${VERSION}" \
 	--disable-devices \
 	--disable-ffplay \
diff --git a/xbmc/addons/AddonManager.cpp b/xbmc/addons/AddonManager.cpp
index 0f0da4f917..1b672bc996 100644
--- a/xbmc/addons/AddonManager.cpp
+++ b/xbmc/addons/AddonManager.cpp
@@ -924,6 +924,12 @@ bool CAddonMgr::PlatformSupportsAddon(const cp_plugin_info_t *plugin)
 #elif defined(TARGET_RASPBERRY_PI)
     "rbpi",
     "linux",
+#elif defined(TARGET_MALI)
+    "mali",
+    "linux",
+#elif defined(TARGET_V3D)
+    "v3d",
+    "linux",
 #elif defined(TARGET_FREEBSD)
     "freebsd",
     "linux",
@@ -1016,6 +1022,12 @@ std::string CAddonMgr::GetPlatformLibraryName(cp_cfg_element_t *base) const
 #elif defined(TARGET_RASPBERRY_PI)
   libraryName = GetExtValue(base, "@library_rbpi");
   if (libraryName.empty())
+#elif defined(TARGET_V3D)
+  libraryName = GetExtValue(base, "@library_v3d");
+  if (libraryName.empty())
+#elif defined(TARGET_MALI)
+  libraryName = GetExtValue(base, "@library_mali");
+  if (libraryName.empty())
 #endif
   libraryName = GetExtValue(base, "@library_linux");
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
diff --git a/xbmc/platform/xbmc.cpp b/xbmc/platform/xbmc.cpp
index 34e5ea67d4..94a6ee22cd 100644
--- a/xbmc/platform/xbmc.cpp
+++ b/xbmc/platform/xbmc.cpp
@@ -21,6 +21,11 @@
 #include "Application.h"
 #include "settings/AdvancedSettings.h"
 
+#if defined(TARGET_XCORE)
+#include <v3dplatform.h>
+V3D_PlatformHandle g_v3dPlatformHandle;
+#endif
+
 #ifdef TARGET_RASPBERRY_PI
 #include "linux/RBP.h"
 #endif
@@ -54,6 +59,10 @@ extern "C" int XBMC_Run(bool renderGUI, CFileItemList &playlist)
     CMessagePrinter::DisplayError("ERROR: Unable to create application. Exiting");
     return status;
   }
+  
+#if defined(TARGET_XCORE)
+  V3D_RegisterDisplayPlatform(&g_v3dPlatformHandle, NULL);
+#endif
 
 #ifdef TARGET_RASPBERRY_PI
   if(!g_RBP.Initialize())
diff --git a/xbmc/system_gl.h b/xbmc/system_gl.h
index 0eae1af4da..44369f86d8 100644
--- a/xbmc/system_gl.h
+++ b/xbmc/system_gl.h
@@ -45,6 +45,9 @@
   #if defined(TARGET_DARWIN)
     #include <OpenGLES/ES2/gl.h>
     #include <OpenGLES/ES2/glext.h>
+  #elif defined(TARGET_V3DNXPL)
+    #include <GLES3/gl31.h>
+    #include <GLES2/gl2ext.h>
   #else
     #include <GLES2/gl2.h>
     #include <GLES2/gl2ext.h>
diff --git a/xbmc/utils/DreamboxUtils.cpp b/xbmc/utils/DreamboxUtils.cpp
new file mode 100644
index 0000000000..52c4c2fbe5
--- /dev/null
+++ b/xbmc/utils/DreamboxUtils.cpp
@@ -0,0 +1,102 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DreamboxUtils.h"
+#include "guilib/gui3d.h"
+#include "utils/StringUtils.h"
+
+bool dreambox_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
+{
+  if (!res)
+    return false;
+
+  res->iWidth = 0;
+  res->iHeight = 0;
+  res->iScreenWidth = 0;
+  res->iScreenHeight = 0;
+
+  if (!mode)
+    return false;
+
+  std::string fromMode = mode;
+  StringUtils::Trim(fromMode);
+
+  const char types[] = { 'p', 'i', 'x' };
+  for (unsigned int i = 0; i < 3; i++) {
+    std::size_t pos = fromMode.find(types[i]);
+    if (pos == 0 || pos == std::string::npos)
+      continue;
+
+    std::string t1 = fromMode.substr(0, pos);
+    if (!StringUtils::IsInteger(t1))
+      return false;
+
+    std::string t2 = fromMode.substr(pos + 1);
+    if (types[i] == 'x') {
+      if (StringUtils::IsInteger(t2)) {
+        res->iScreenWidth = StringUtils::ReturnDigits(t1);
+        res->iScreenHeight = StringUtils::ReturnDigits(t2);
+      }
+    } else {
+      res->iScreenHeight = StringUtils::ReturnDigits(t1);
+
+      if (t2.empty())
+        res->fRefreshRate = 60;
+      else if (StringUtils::IsInteger(t2))
+        res->fRefreshRate = StringUtils::ReturnDigits(t2);
+
+      if (types[i] == 'p')
+        res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+      else
+        res->dwFlags = D3DPRESENTFLAG_INTERLACED;
+
+      if (res->iScreenHeight == 480)
+        res->iScreenWidth = 640;
+      else if (res->iScreenHeight == 576)
+        res->iScreenWidth = 720;
+      else if (res->iScreenHeight == 720)
+        res->iScreenWidth = 1280;
+      else if (res->iScreenHeight == 1080)
+        res->iScreenWidth = 1920;
+      else if (res->iScreenHeight == 2160)
+        res->iScreenWidth = 3840;
+
+      break;
+    }
+  }
+
+  if (res->iScreenHeight > 1080) {
+    res->iWidth = 1920;
+    res->iHeight = 1080;
+  } else {
+    res->iWidth = res->iScreenWidth;
+    res->iHeight = res->iScreenHeight;
+  }
+
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->strId         = fromMode;
+  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+    res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
diff --git a/xbmc/utils/DreamboxUtils.h b/xbmc/utils/DreamboxUtils.h
new file mode 100644
index 0000000000..99fe568801
--- /dev/null
+++ b/xbmc/utils/DreamboxUtils.h
@@ -0,0 +1,24 @@
+#pragma once
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "guilib/Resolution.h"
+
+bool dreambox_mode_to_resolution(const char *mode, RESOLUTION_INFO *res);
diff --git a/xbmc/utils/Makefile.in b/xbmc/utils/Makefile.in
index 7ec1b21f1d..55de71a98b 100644
--- a/xbmc/utils/Makefile.in
+++ b/xbmc/utils/Makefile.in
@@ -83,6 +83,10 @@ ifeq (@USE_OPENGLES@,1)
 SRCS += AMLUtils.cpp
 endif
 
+ifeq (@USE_DREAMBOX@,1)
+SRCS += DreamboxUtils.cpp
+endif
+
 ifeq (@USE_LIBAMCODEC@,1)
 SRCS += ScreenshotAML.cpp
 endif
diff --git a/xbmc/windowing/egl/EGLNativeTypeDreambox.cpp b/xbmc/windowing/egl/EGLNativeTypeDreambox.cpp
new file mode 100644
index 0000000000..f43320a564
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDreambox.cpp
@@ -0,0 +1,191 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeTypeDreambox.h"
+#include "guilib/gui3d.h"
+#include "utils/DreamboxUtils.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeDreambox::CEGLNativeTypeDreambox()
+{
+  m_nativeWindow = (XBNativeWindowType)0L;
+}
+
+CEGLNativeTypeDreambox::~CEGLNativeTypeDreambox()
+{
+}
+
+bool CEGLNativeTypeDreambox::CheckCompatibility()
+{
+  std::string name;
+  SysfsUtils::GetString("/proc/stb/info/model", name);
+  return name == "dm820" || name == "dm900" || name == "dm920" || name == "dm7080";
+}
+
+void CEGLNativeTypeDreambox::Initialize()
+{
+}
+
+void CEGLNativeTypeDreambox::Destroy()
+{
+}
+
+bool CEGLNativeTypeDreambox::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::CreateNativeWindow()
+{
+  RESOLUTION_INFO res;
+  if (GetNativeResolution(&res))
+    SetFramebufferResolution(res.iWidth, res.iHeight);
+  else
+    SetFramebufferResolution(1280, 720);
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType *)&m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType *)&m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::DestroyNativeWindow()
+{
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  std::string mode;
+  SysfsUtils::GetString("/proc/stb/video/videomode", mode);
+  return dreambox_mode_to_resolution(mode.c_str(), res);
+}
+
+bool CEGLNativeTypeDreambox::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  // Don't set the same mode as current
+  std::string mode;
+  SysfsUtils::GetString("/proc/stb/video/videomode", mode);
+  if (res.strId == mode)
+    return false;
+
+  return SetDisplayResolution(res.strId.c_str());
+}
+
+bool CEGLNativeTypeDreambox::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  std::string valstr;
+  SysfsUtils::GetString("/proc/stb/video/videomode_choices", valstr);
+  std::vector<std::string> probe_str = StringUtils::Split(valstr, " ");
+
+  resolutions.clear();
+  RESOLUTION_INFO res;
+  for (std::vector<std::string>::const_iterator i = probe_str.begin(); i != probe_str.end(); ++i)
+  {
+    if (dreambox_mode_to_resolution(i->c_str(), &res))
+      resolutions.push_back(res);
+  }
+
+  return resolutions.size() > 0;
+}
+
+bool CEGLNativeTypeDreambox::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  // check display/mode, it gets defaulted at boot
+  if (!GetNativeResolution(res))
+  {
+    // punt to 720p if we get nothing
+    dreambox_mode_to_resolution("720p", res);
+  }
+
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::ShowWindow(bool show)
+{
+  SysfsUtils::SetInt("/proc/stb/video/alpha", show ? 255 : 0);
+  return true;
+}
+
+bool CEGLNativeTypeDreambox::SetDisplayResolution(const char *mode)
+{
+  // switch display resolution
+  SysfsUtils::SetString("/proc/stb/video/videomode", mode);
+
+  RESOLUTION_INFO res;
+  dreambox_mode_to_resolution(mode, &res);
+  SetFramebufferResolution(res);
+
+  return true;
+}
+
+void CEGLNativeTypeDreambox::SetFramebufferResolution(const RESOLUTION_INFO &res) const
+{
+  SetFramebufferResolution(res.iScreenWidth, res.iScreenHeight);
+}
+
+void CEGLNativeTypeDreambox::SetFramebufferResolution(int width, int height) const
+{
+  const char fbdev[] = "/dev/fb0";
+  int fd;
+
+  fd = open(fbdev, O_RDWR | O_CLOEXEC);
+  if (fd >= 0)
+  {
+    struct fb_var_screeninfo vinfo;
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &vinfo) == 0)
+    {
+      vinfo.xres = width;
+      vinfo.yres = height;
+      vinfo.xres_virtual = width;
+      vinfo.yres_virtual = height * 2;
+      vinfo.bits_per_pixel = 32;
+      vinfo.activate = FB_ACTIVATE_ALL;
+      ioctl(fd, FBIOPUT_VSCREENINFO, &vinfo);
+    }
+    close(fd);
+  }
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeDreambox.h b/xbmc/windowing/egl/EGLNativeTypeDreambox.h
new file mode 100644
index 0000000000..d5410a1131
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDreambox.h
@@ -0,0 +1,61 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+#include <vector>
+
+#include "EGLNativeType.h"
+class CEGLNativeTypeDreambox : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeDreambox();
+  virtual ~CEGLNativeTypeDreambox();
+  virtual std::string GetNativeName() const { return "dreambox"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+protected:
+  bool SetDisplayResolution(const char *resolution);
+  void SetupVideoScaling(const char *mode);
+  void DisableFreeScale();
+
+private:
+  void SetFramebufferResolution(const RESOLUTION_INFO &res) const;
+  void SetFramebufferResolution(int width, int height) const;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeGB.cpp b/xbmc/windowing/egl/EGLNativeTypeGB.cpp
new file mode 100644
index 0000000000..b70e870bac
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeGB.cpp
@@ -0,0 +1,189 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeGB.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+#include "linux/DllBCM.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+#include "gles_init.h"
+
+CEGLNativeTypeGB::CEGLNativeTypeGB()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeGB::~CEGLNativeTypeGB()
+{
+}  
+
+bool CEGLNativeTypeGB::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeGB::Initialize()
+{
+}
+
+void CEGLNativeTypeGB::Destroy()
+{
+}
+
+bool CEGLNativeTypeGB::CreateNativeDisplay()
+{
+
+  GLES_Native_Init();
+  return GLES_Native_CreateNativeDisplay(&m_nativeDisplay);
+
+}
+
+bool CEGLNativeTypeGB::CreateNativeWindow()
+{
+
+  m_nativeWindow = GLES_Native_CreateNativeWindow();
+   
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeGB::DestroyNativeDisplay()
+{
+	GLES_Native_DestroyNativeDisplay();
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeGB::DestroyNativeWindow()
+{
+  GLES_Native_DestroyNativeWindow();
+  m_nativeWindow = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeGB::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeGB::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].iScreen      = 0;
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), (float)50,m_desktopRes.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[0].iSubtitles   = (int)(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].iScreen      = 0;
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[1].dwFlags      |=  D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50,m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[1].iSubtitles   = (int)(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].iScreen      = 0;
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[2].dwFlags      |=  D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50,m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[2].iSubtitles   = (int)(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+  
+  return true;
+}
+
+bool CEGLNativeTypeGB::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeGB::ShowWindow(bool show)
+{
+  GLES_Native_ShowWindow(m_nativeWindow, show);
+  return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeGB.h b/xbmc/windowing/egl/EGLNativeTypeGB.h
new file mode 100644
index 0000000000..9cf0839bfd
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeGB.h
@@ -0,0 +1,56 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+class CEGLNativeTypeGB : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeGB();
+  virtual ~CEGLNativeTypeGB();
+  virtual std::string GetNativeName() const { return "GB"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeMali.cpp b/xbmc/windowing/egl/EGLNativeTypeMali.cpp
new file mode 100644
index 0000000000..20535004ab
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeMali.cpp
@@ -0,0 +1,149 @@
+/*
+ *      Copyright (C) 2011-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "EGLNativeTypeMali.h"
+#include <EGL/egl.h>
+#include "utils/log.h"
+
+#include <linux/fb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+bool CEGLNativeTypeMali::_GetNativeResolution(RESOLUTION_INFO *res) const {
+  struct fb_var_screeninfo vinfo;
+  int fd;
+  
+  fd = open("/dev/fb0", O_RDWR, 0);
+  if (fd < 0) {
+    return false;
+  }
+  
+  if (ioctl(fd, FBIOGET_VSCREENINFO, &vinfo) < 0) {
+    return false;
+  }
+  close(fd);
+
+  res->iScreen       = 0;
+  res->bFullScreen   = false;
+  res->dwFlags       = 0;
+  res->fRefreshRate  = 60;
+  res->iWidth        = vinfo.xres;
+  res->iHeight       = vinfo.yres;
+  res->iScreenWidth  = vinfo.xres;
+  res->iScreenHeight = vinfo.yres;
+  res->fPixelRatio   = 1;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+
+  return true;
+}
+
+CEGLNativeTypeMali::CEGLNativeTypeMali() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CEGLNativeTypeMali()\n");
+}
+
+CEGLNativeTypeMali::~CEGLNativeTypeMali() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::~CEGLNativeTypeMali()\n");
+}
+
+bool CEGLNativeTypeMali::CheckCompatibility() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CheckCompatibility()\n");
+  return true;
+}
+
+void CEGLNativeTypeMali::Initialize() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::Initialize()\n");
+}
+
+void CEGLNativeTypeMali::Destroy() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::Destroy()\n");
+}
+
+bool CEGLNativeTypeMali::CreateNativeDisplay() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CreateNativeDisplay()\n");
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeMali::CreateNativeWindow() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::CreateNativeWindow()\n");
+  m_nativeWindow = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetNativeDisplay()\n");
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetNativeWindow(XBNativeWindowType **nativeWindow) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetNativeWindow()\n");
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeMali::DestroyNativeWindow() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::DestroyNativeWindow()\n");
+  m_nativeWindow = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeMali::DestroyNativeDisplay() {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::DestroyNativeDisplay()\n");
+  m_nativeDisplay = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetNativeResolution(RESOLUTION_INFO *res) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetNativeResolution()\n");
+  return _GetNativeResolution(res);
+}
+
+bool CEGLNativeTypeMali::SetNativeResolution(const RESOLUTION_INFO &res) {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::SetNativeResolution()\n");
+  return true;
+}
+
+bool CEGLNativeTypeMali::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions) {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::ProbeResolutions()\n");
+  resolutions.clear();
+
+  RESOLUTION_INFO res;
+  if(_GetNativeResolution(&res)) {
+    resolutions.push_back(res);
+    return true;
+  }
+  return true;
+}
+
+bool CEGLNativeTypeMali::GetPreferredResolution(RESOLUTION_INFO *res) const {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::GetPreferredResolution()\n");
+  _GetNativeResolution(res);
+  return false;
+}
+
+bool CEGLNativeTypeMali::ShowWindow(bool show) {
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeMali::ShowWindow()\n");
+  return false;
+}
\ No newline at end of file
diff --git a/xbmc/windowing/egl/EGLNativeTypeMali.h b/xbmc/windowing/egl/EGLNativeTypeMali.h
new file mode 100644
index 0000000000..d11125a17e
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeMali.h
@@ -0,0 +1,53 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+class CEGLNativeTypeMali : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeMali();
+  virtual ~CEGLNativeTypeMali();
+  virtual std::string GetNativeName() const { return "mali"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+ private:
+  bool _GetNativeResolution(RESOLUTION_INFO *res) const;
+};
\ No newline at end of file
diff --git a/xbmc/windowing/egl/EGLNativeTypeNexTV.cpp b/xbmc/windowing/egl/EGLNativeTypeNexTV.cpp
new file mode 100644
index 0000000000..6f4338d523
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeNexTV.cpp
@@ -0,0 +1,229 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeNexTV.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+#include "linux/DllBCM.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeNexTV::CEGLNativeTypeNexTV()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeNexTV::~CEGLNativeTypeNexTV()
+{
+}  
+
+bool CEGLNativeTypeNexTV::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeNexTV::Initialize()
+{
+}
+
+void CEGLNativeTypeNexTV::Destroy()
+{
+}
+
+bool CEGLNativeTypeNexTV::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::CreateNativeWindow()
+{
+  NxClient_Join(NULL);
+
+  NXPL_RegisterNexusDisplayPlatform(&nxpl_handle, nexus_display);
+  NXPL_NativeWindowInfoEXT nativeWindow;
+
+  NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+
+  nativeWindow.x = 0;
+  nativeWindow.y = 0;
+  nativeWindow.width = 1280;
+  nativeWindow.height = 720;
+  nativeWindow.stretch = false;
+  nativeWindow.clientID = 0;
+  nativeWindow.zOrder = 0;
+
+  m_nativeWindow = NXPL_CreateNativeWindowEXT(&nativeWindow);
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)	return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  if (!nativeWindow)	return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::DestroyNativeDisplay()
+{
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeNexTV::DestroyNativeWindow()
+{
+  NXPL_DestroyNativeWindow(m_nativeWindow);
+
+  NXPL_UnregisterNexusDisplayPlatform(nxpl_handle);
+  NxClient_Uninit();
+
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return SetDisplayResolution();
+}
+
+bool CEGLNativeTypeNexTV::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].iScreen      = 0;
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].fPixelRatio   = 1.0f;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].iScreen      = 0;
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].fPixelRatio   = 1.0f;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].iScreen      = 0;
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].fPixelRatio   = 1.0f;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopResAll[3].iScreen      = 0;
+  m_desktopResAll[3].bFullScreen  = true;
+  m_desktopResAll[3].iWidth       = 1280;
+  m_desktopResAll[3].iHeight      = 720;
+  m_desktopResAll[3].iScreenWidth = 1920;
+  m_desktopResAll[3].iScreenHeight= 1080;
+  m_desktopResAll[3].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[3].fRefreshRate = 50;
+  m_desktopResAll[3].fPixelRatio   = 1.0f;
+  m_desktopResAll[3].strMode = StringUtils::Format("%dx%d", 1920, 1080);
+  m_desktopResAll[3].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[3].strMode.c_str(), (float)50, m_desktopResAll[3].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[3].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[3].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[3].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[3]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::ShowWindow(bool show)
+{
+  NXPL_ShowNativeWindowEXT(m_nativeWindow, show);
+  return true;
+}
+
+bool CEGLNativeTypeNexTV::SetDisplayResolution()
+{
+	NXPL_NativeWindowInfoEXT nativeWindow;
+
+	NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+	nativeWindow.x = nativeWindow.y = 0;
+	nativeWindow.width = m_desktopRes.iWidth;
+	nativeWindow.height = m_desktopRes.iHeight;
+	
+	NXPL_UpdateNativeWindowEXT(m_nativeWindow, &nativeWindow);
+
+	return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeNexTV.h b/xbmc/windowing/egl/EGLNativeTypeNexTV.h
new file mode 100644
index 0000000000..ae4c5baf74
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeNexTV.h
@@ -0,0 +1,196 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+#define NEXUS_DISPLAYHANDLE void*
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *NXPL_PlatformHandle;
+
+typedef enum NEXUS_BlendFactor
+{
+    NEXUS_BlendFactor_eZero
+} NEXUS_BlendFactor;
+
+typedef struct NEXUS_BlendEquation
+{
+    NEXUS_BlendFactor a;
+    NEXUS_BlendFactor b;
+    bool              subtract_cd;
+    NEXUS_BlendFactor c;
+    NEXUS_BlendFactor d;
+    bool              subtract_e;
+    NEXUS_BlendFactor e;
+} NEXUS_BlendEquation;
+
+typedef struct
+{
+   uint32_t             width;
+   uint32_t             height;
+   uint32_t             x;
+   uint32_t             y;
+   bool                 stretch;
+   uint32_t             clientID;
+   uint32_t             zOrder;
+   NEXUS_BlendEquation  colorBlend;
+   NEXUS_BlendEquation  alphaBlend;
+   uint32_t             magic;
+} NXPL_NativeWindowInfoEXT;
+
+/* FOR NXCLINET */
+typedef unsigned NEXUS_Error;
+
+#define NXCLIENT_MAX_NAME 32
+
+/***************************************************************************
+Summary:
+Autheticated ID for client/server communication.
+
+Description:
+For non-secure environments, the certificate could be a simple ID.
+For secure environments, this should use encrypted using standard public-key cryptography.
+***************************************************************************/
+typedef struct NEXUS_Certificate
+{
+    unsigned char data[256];
+    unsigned length;
+} NEXUS_Certificate;
+
+/**
+Summary:
+Client modes
+
+See nexus/docs/Nexus_MultiProcess.pdf for full discussion of process isolation and multi-process application design.
+**/
+typedef enum NEXUS_ClientMode
+{
+    NEXUS_ClientMode_eUnprotected, /* deprecated */
+    NEXUS_ClientMode_eVerified,    /* verify handle value, but not owner. unsynchronized caller may compromise nexus settings. */
+    NEXUS_ClientMode_eProtected,   /* full handle verification. access to full API. if client crashes, server is protected. */
+    NEXUS_ClientMode_eUntrusted,   /* full handle verification. access to limited API. see nexus/build/common/tools/nexus_untrusted_api.txt. if client crashes, server is protected. */
+    NEXUS_ClientMode_eMax
+} NEXUS_ClientMode;
+
+/**
+Summary:
+Join with Nexus server application (using app ipc) and Nexus driver (using Nexus multiprocess)
+
+Description:
+This dynamically registers a client with both nexus and the server app.
+NxClient_Join can be called from multiple processes, or multiple times from the same process.
+
+NxClient_Join is reference counted within the same process. You must call NxClient_Uninit an equal
+number of times to detach from nexus and the server app.
+**/
+typedef struct NxClient_JoinSettings
+{
+    char name[NXCLIENT_MAX_NAME];
+    bool tunnelCapable; /* deprecated */
+    unsigned timeout; /* in seconds. if unable to join, try again for this number of seconds. defaults to 0. */
+    unsigned session; /* set index to choose which session in a multi-session server configuration */
+    bool ignoreStandbyRequest; /* deprecated. see NxClient_RegisterAcknowledgeStandby() instead. */
+    NEXUS_ClientMode mode; /* requested client mode. server may reject the request. */
+    NEXUS_Certificate certificate; /* allows NEXUS_ClientMode_eProtected (aka trusted) status if server requires */
+} NxClient_JoinSettings;
+
+extern void NxClient_GetDefaultJoinSettings(NxClient_JoinSettings *pSettings);
+
+extern NEXUS_Error NxClient_Join(const NxClient_JoinSettings *pSettings);
+
+extern void NxClient_Uninit(void);
+
+
+/* Register a display for exclusive use. The client application should not use the display until
+ * calling NXPL_UnregisterNexusDisplayPlatform.
+ * It will register its own memory, h/w and display APIs suitable for basic exclusive mode rendering on
+ * a Nexus display.
+ * Fills in the NXPL platform handle, which must be passed back into the unregister function.
+ */
+void NXPL_RegisterNexusDisplayPlatform(NXPL_PlatformHandle *handle, NEXUS_DISPLAYHANDLE display);
+
+/* Unregister a display for exclusive use. The client application can the use the Nexus display again. */
+void NXPL_UnregisterNexusDisplayPlatform(NXPL_PlatformHandle handle);
+
+/* Generate a default NXPL_NativeWindowInfoEXT */
+void NXPL_GetDefaultNativeWindowInfoEXT(NXPL_NativeWindowInfoEXT *info);
+
+/* Create a 'native window' of the given size. This is really just a small structure that holds the size
+ * of the window that EGL will write into. */
+void *NXPL_CreateNativeWindowEXT(const NXPL_NativeWindowInfoEXT *info);
+
+/* Destroy a 'native window' */
+void NXPL_DestroyNativeWindow(void *nativeWin);
+
+/* Show/hide a 'native window' */
+void NXPL_ShowNativeWindowEXT(void *native,bool show);
+
+/* Update a 'native window' */
+void NXPL_UpdateNativeWindowEXT(void *native, NXPL_NativeWindowInfoEXT * nativeWindow);
+
+int NEXUS_Platform_AuthenticatedJoin(const void *settings);
+#define NEXUS_Platform_Join() NEXUS_Platform_AuthenticatedJoin(NULL)
+
+#ifdef __cplusplus
+}
+#endif
+
+class CEGLNativeTypeNexTV : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeNexTV();
+  virtual ~CEGLNativeTypeNexTV();
+  virtual std::string GetNativeName() const { return "NexTV"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[4];
+
+  NXPL_PlatformHandle nxpl_handle = 0;
+  NEXUS_DISPLAYHANDLE  nexus_display = 0;
+
+  bool SetDisplayResolution();
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3D.cpp b/xbmc/windowing/egl/EGLNativeTypeV3D.cpp
new file mode 100644
index 0000000000..227e24a604
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3D.cpp
@@ -0,0 +1,161 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeV3D.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+#include "linux/DllBCM.h"
+#include <v3dplatform.h>
+
+extern V3D_PlatformHandle g_v3dPlatformHandle;
+
+using namespace std;
+
+bool CEGLNativeTypeV3D::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeV3D::Initialize()
+{
+}
+
+void CEGLNativeTypeV3D::Destroy()
+{
+}
+
+bool CEGLNativeTypeV3D::CreateNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeV3D::CreateNativeWindow()
+{
+  V3D_NativeWindowInfo info;
+  m_nativeWindow = V3D_CreateNativeWindow(&info);
+  if (!m_nativeWindow) {
+    return false;
+  }
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeWindow()
+{
+  V3D_DestroyNativeWindow(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].iScreen      = 0;
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), 50., "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].iScreen      = 0;
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), 50., "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].iScreen      = 0;
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), 50., "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ShowWindow(bool show)
+{
+  return V3D_SetVisible(g_v3dPlatformHandle, show);
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3D.h b/xbmc/windowing/egl/EGLNativeTypeV3D.h
new file mode 100644
index 0000000000..c0ee8f93aa
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3D.h
@@ -0,0 +1,59 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+class CEGLNativeTypeV3D : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeV3D() {
+    m_nativeDisplay = 0;
+    m_nativeWindow = 0;
+  }
+  virtual ~CEGLNativeTypeV3D() {};
+  virtual std::string GetNativeName() const { return "V3D"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp
new file mode 100644
index 0000000000..14249a9537
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.cpp
@@ -0,0 +1,208 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeV3DNXPL.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+#include "linux/DllBCM.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeV3D::CEGLNativeTypeV3D()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeV3D::~CEGLNativeTypeV3D()
+{
+}  
+
+bool CEGLNativeTypeV3D::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeV3D::Initialize()
+{
+}
+
+void CEGLNativeTypeV3D::Destroy()
+{
+}
+
+bool CEGLNativeTypeV3D::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::CreateNativeWindow()
+{
+  NEXUS_Platform_Join();
+  NXPL_RegisterNexusDisplayPlatform(&nxpl_handle, nexus_display);
+  NXPL_NativeWindowInfoEXT nativeWindow;
+
+  NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+
+  nativeWindow.x = 0;
+  nativeWindow.y = 0;
+  nativeWindow.width = 1280;
+  nativeWindow.height = 720;
+  nativeWindow.stretch = false;
+  nativeWindow.clientID = 0;
+  nativeWindow.zOrder = 0;
+
+  m_nativeWindow = NXPL_CreateNativeWindowEXT(&nativeWindow);
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeDisplay()
+{
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeV3D::DestroyNativeWindow()
+{
+  NXPL_DestroyNativeWindow(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].iScreen      = 0;
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].fPixelRatio   = 1.0f;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].iScreen      = 0;
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].fPixelRatio   = 1.0f;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].iScreen      = 0;
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].fPixelRatio   = 1.0f;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopResAll[3].iScreen      = 0;
+  m_desktopResAll[3].bFullScreen  = true;
+  m_desktopResAll[3].iWidth       = 1280;
+  m_desktopResAll[3].iHeight      = 720;
+  m_desktopResAll[3].iScreenWidth = 1920;
+  m_desktopResAll[3].iScreenHeight= 1080;
+  m_desktopResAll[3].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[3].fRefreshRate = 50;
+  m_desktopResAll[3].fPixelRatio   = 1.0f;
+  m_desktopResAll[3].strMode = StringUtils::Format("%dx%d", 1920, 1080);
+  m_desktopResAll[3].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[3].strMode.c_str(), (float)50, m_desktopResAll[3].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  m_desktopResAll[3].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[3].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[3].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[3]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeV3D::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeV3D::ShowWindow(bool show)
+{
+  NXPL_ShowNativeWindowEXT(m_nativeWindow, show);
+  return true;
+}
\ No newline at end of file
diff --git a/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h
new file mode 100644
index 0000000000..1d253f4bb4
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeV3DNXPL.h
@@ -0,0 +1,129 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+#define NEXUS_DISPLAYHANDLE void*
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *NXPL_PlatformHandle;
+
+typedef enum NEXUS_BlendFactor
+{
+    NEXUS_BlendFactor_eZero
+} NEXUS_BlendFactor;
+
+typedef struct NEXUS_BlendEquation
+{
+    NEXUS_BlendFactor a;
+    NEXUS_BlendFactor b;
+    bool              subtract_cd;
+    NEXUS_BlendFactor c;
+    NEXUS_BlendFactor d;
+    bool              subtract_e;
+    NEXUS_BlendFactor e;
+} NEXUS_BlendEquation;
+
+typedef struct
+{
+   uint32_t             width;
+   uint32_t             height;
+   uint32_t             x;
+   uint32_t             y;
+   bool                 stretch;
+   uint32_t             clientID;
+   uint32_t             zOrder;
+   NEXUS_BlendEquation  colorBlend;
+   NEXUS_BlendEquation  alphaBlend;
+   uint32_t             magic;
+} NXPL_NativeWindowInfoEXT;
+
+/* Register a display for exclusive use. The client application should not use the display until
+ * calling NXPL_UnregisterNexusDisplayPlatform.
+ * It will register its own memory, h/w and display APIs suitable for basic exclusive mode rendering on
+ * a Nexus display.
+ * Fills in the NXPL platform handle, which must be passed back into the unregister function.
+ */
+void NXPL_RegisterNexusDisplayPlatform(NXPL_PlatformHandle *handle, NEXUS_DISPLAYHANDLE display);
+
+/* Unregister a display for exclusive use. The client application can the use the Nexus display again. */
+void NXPL_UnregisterNexusDisplayPlatform(NXPL_PlatformHandle handle);
+
+/* Generate a default NXPL_NativeWindowInfoEXT */
+void NXPL_GetDefaultNativeWindowInfoEXT(NXPL_NativeWindowInfoEXT *info);
+
+/* Create a 'native window' of the given size. This is really just a small structure that holds the size
+ * of the window that EGL will write into. */
+void *NXPL_CreateNativeWindowEXT(const NXPL_NativeWindowInfoEXT *info);
+
+/* Destroy a 'native window' */
+void NXPL_DestroyNativeWindow(void *nativeWin);
+
+/* Show/hide a 'native window' */
+void NXPL_ShowNativeWindowEXT(void *native,bool show);
+
+int NEXUS_Platform_AuthenticatedJoin(const void *settings);
+#define NEXUS_Platform_Join() NEXUS_Platform_AuthenticatedJoin(NULL)
+
+#ifdef __cplusplus
+}
+#endif
+
+class CEGLNativeTypeV3D : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeV3D();
+  virtual ~CEGLNativeTypeV3D();
+  virtual std::string GetNativeName() const { return "V3D"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[4];
+
+  NXPL_PlatformHandle nxpl_handle = 0;
+  NEXUS_DISPLAYHANDLE  nexus_display = 0;
+
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeVuplus.cpp b/xbmc/windowing/egl/EGLNativeTypeVuplus.cpp
new file mode 100644
index 0000000000..d0894b0a0a
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeVuplus.cpp
@@ -0,0 +1,180 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeVuplus.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+#include "linux/DllBCM.h"
+
+#include <stdio.h>
+#include <malloc.h>
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined(TARGET_VUPLUS_ARM)
+#include "KodiGLESPL.h"
+#else
+#include "gles_init.h"
+#endif
+
+using namespace std;
+
+bool CEGLNativeTypeVuplus::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeVuplus::Initialize()
+{
+}
+
+void CEGLNativeTypeVuplus::Destroy()
+{
+}
+
+bool CEGLNativeTypeVuplus::CreateNativeDisplay()
+{
+  GLES_Native_Init();
+  return GLES_Native_CreateNativeDisplay(&m_nativeDisplay);
+}
+
+bool CEGLNativeTypeVuplus::CreateNativeWindow()
+{
+  m_nativeWindow = GLES_Native_CreateNativeWindow();
+  if (!m_nativeWindow) {
+	  return false;
+  }
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}  
+
+bool CEGLNativeTypeVuplus::DestroyNativeDisplay()
+{
+  GLES_Native_DestroyNativeDisplay();
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::DestroyNativeWindow()
+{
+  GLES_Native_DestroyNativeWindow();
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  m_desktopRes = res;
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  m_desktopResAll[0].iScreen      = 0;
+  m_desktopResAll[0].bFullScreen  = true;
+  m_desktopResAll[0].iWidth       = 1280;
+  m_desktopResAll[0].iHeight      = 720;
+  m_desktopResAll[0].iScreenWidth = 1280;
+  m_desktopResAll[0].iScreenHeight= 720;
+  m_desktopResAll[0].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+  m_desktopResAll[0].fRefreshRate = 50;
+  m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopRes.strMode.c_str(), (float)50,m_desktopRes.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[0].iSubtitles   = (int)(0.965 * m_desktopResAll[0].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[0]);
+
+  m_desktopResAll[1].iScreen      = 0;
+  m_desktopResAll[1].bFullScreen  = true;
+  m_desktopResAll[1].iWidth       = 1280;
+  m_desktopResAll[1].iHeight      = 720;
+  m_desktopResAll[1].iScreenWidth = 1280;
+  m_desktopResAll[1].iScreenHeight= 720;
+  m_desktopResAll[1].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[1].dwFlags      |=  D3DPRESENTFLAG_MODE3DSBS;
+  m_desktopResAll[1].fRefreshRate = 50;
+  m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50,m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[1].iSubtitles   = (int)(0.965 * m_desktopResAll[1].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[1]);
+
+  m_desktopResAll[2].iScreen      = 0;
+  m_desktopResAll[2].bFullScreen  = true;
+  m_desktopResAll[2].iWidth       = 1280;
+  m_desktopResAll[2].iHeight      = 720;
+  m_desktopResAll[2].iScreenWidth = 1280;
+  m_desktopResAll[2].iScreenHeight= 720;
+  m_desktopResAll[2].dwFlags      =  D3DPRESENTFLAG_PROGRESSIVE;
+
+  m_desktopResAll[2].dwFlags      |=  D3DPRESENTFLAG_MODE3DTB;
+  m_desktopResAll[2].fRefreshRate = 50;
+  m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+  m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50,m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  m_desktopResAll[2].iSubtitles   = (int)(0.965 * m_desktopResAll[2].iHeight);
+
+  CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+  resolutions.push_back(m_desktopResAll[2]);
+
+  m_desktopRes = m_desktopResAll[0];
+
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeVuplus::ShowWindow(bool show)
+{
+  return false;
+}
+
+
diff --git a/xbmc/windowing/egl/EGLNativeTypeVuplus.h b/xbmc/windowing/egl/EGLNativeTypeVuplus.h
new file mode 100644
index 0000000000..40dfe978f9
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeVuplus.h
@@ -0,0 +1,60 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+class CEGLNativeTypeVuplus : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeVuplus()
+  {
+	  m_nativeWindow = 0;
+	  m_nativeDisplay = 0;
+  };
+  virtual ~CEGLNativeTypeVuplus() {};
+  virtual std::string GetNativeName() const { return "vuplus"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[3];
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeDags.cpp b/xbmc/windowing/egl/EGLNativeTypeDags.cpp
new file mode 100644
index 0000000..6d4ff40
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDags.cpp
@@ -0,0 +1,344 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "EGLNativeTypeDags.h"
+#include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+#include "linux/DllBCM.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <EGL/egl.h>
+
+CEGLNativeTypeDags::CEGLNativeTypeDags()
+{
+  m_nativeDisplay = NULL;
+  m_nativeWindow = NULL;
+}
+
+CEGLNativeTypeDags::~CEGLNativeTypeDags()
+{
+}  
+
+bool CEGLNativeTypeDags::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeDags::Initialize()
+{
+}
+
+void CEGLNativeTypeDags::Destroy()
+{
+}
+
+bool CEGLNativeTypeDags::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeDags::CreateNativeWindow()
+{
+  NxClient_Join(NULL);
+
+  NXPL_RegisterNexusDisplayPlatform(&nxpl_handle, nexus_display);
+  NXPL_NativeWindowInfoEXT nativeWindow;
+
+  NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+
+  nativeWindow.x = 0;
+  nativeWindow.y = 0;
+  nativeWindow.width = 1280;
+  nativeWindow.height = 720;
+  nativeWindow.stretch = false;
+  nativeWindow.clientID = 0;
+  nativeWindow.zOrder = 0;
+  
+  m_nativeWindow = NXPL_CreateNativeWindowEXT(&nativeWindow);
+  if (!m_nativeWindow)
+    return false;
+  return true;
+}
+
+bool CEGLNativeTypeDags::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)	return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeDags::GetNativeWindow(XBNativeDisplayType **nativeWindow) const
+{
+  if (!nativeWindow)	return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeDags::DestroyNativeDisplay()
+{
+    m_nativeDisplay = NULL;
+    return true;
+}
+
+bool CEGLNativeTypeDags::DestroyNativeWindow()
+{
+  NXPL_DestroyNativeWindow(m_nativeWindow);
+
+  NXPL_UnregisterNexusDisplayPlatform(nxpl_handle);
+  NxClient_Uninit();
+
+  return true;
+}
+
+bool CEGLNativeTypeDags::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopRes;
+  return true;
+}
+
+bool CEGLNativeTypeDags::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+        m_desktopRes = res;
+        return true;
+}
+
+bool CEGLNativeTypeDags::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+        int tmp_resolution = 0;
+        std::string mode;
+        SysfsUtils::GetString("/proc/stb/video/videomode", mode);
+
+        std::string fromMode = mode;        
+        StringUtils::Trim(fromMode);
+
+        const char types[] = { 'p', 'i', 'x' };
+        for (unsigned int i = 0; i < 3; i++) {
+                std::size_t pos = fromMode.find(types[i]);
+                if (pos == 0 || pos == std::string::npos)
+                        continue;
+                std::string t1 = fromMode.substr(0, pos);
+                if (!StringUtils::IsInteger(t1))
+                        return false;
+                tmp_resolution = StringUtils::ReturnDigits(t1);
+        }
+
+        resolutions.clear();
+
+        if ( tmp_resolution == 480 )
+                {
+                        m_desktopResAll[0].iScreen      = 0;
+                        m_desktopResAll[0].bFullScreen  = true;
+                        m_desktopResAll[0].iWidth       = 640;
+                        m_desktopResAll[0].iHeight      = 480;
+                        m_desktopResAll[0].iScreenWidth = 640;
+                        m_desktopResAll[0].iScreenHeight= 480;
+                        m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+                        m_desktopResAll[0].fRefreshRate = 50;
+                        m_desktopResAll[0].fPixelRatio   = 1.0f;
+                        m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 640, 480);
+                        m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[0]);
+
+                        m_desktopResAll[1].iScreen      = 0;
+                        m_desktopResAll[1].bFullScreen  = true;
+                        m_desktopResAll[1].iWidth       = 640;
+                        m_desktopResAll[1].iHeight      = 480;
+                        m_desktopResAll[1].iScreenWidth = 640;
+                        m_desktopResAll[1].iScreenHeight= 480;
+                        m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+                        m_desktopResAll[1].fRefreshRate = 50;
+                        m_desktopResAll[1].fPixelRatio   = 1.0f;
+                        m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 640, 480);
+                        m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[1]);
+
+                        m_desktopResAll[2].iScreen      = 0;
+                        m_desktopResAll[2].bFullScreen  = true;
+                        m_desktopResAll[2].iWidth       = 640;
+                        m_desktopResAll[2].iHeight      = 480;
+                        m_desktopResAll[2].iScreenWidth = 640;
+                        m_desktopResAll[2].iScreenHeight= 480;
+                        m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+                        m_desktopResAll[2].fRefreshRate = 50;
+                        m_desktopResAll[2].fPixelRatio   = 1.0f;
+                        m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 640, 480);
+                        m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[2]);
+                }
+        else if ( tmp_resolution == 576 )
+                {
+                        m_desktopResAll[0].iScreen      = 0;
+                        m_desktopResAll[0].bFullScreen  = true;
+                        m_desktopResAll[0].iWidth       = 720;
+                        m_desktopResAll[0].iHeight      = 576;
+                        m_desktopResAll[0].iScreenWidth = 720;
+                        m_desktopResAll[0].iScreenHeight= 576;
+                        m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+                        m_desktopResAll[0].fRefreshRate = 50;
+                        m_desktopResAll[0].fPixelRatio   = 1.0f;
+                        m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 720, 576);
+                        m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[0]);
+
+                        m_desktopResAll[1].iScreen      = 0;
+                        m_desktopResAll[1].bFullScreen  = true;
+                        m_desktopResAll[1].iWidth       = 720;
+                        m_desktopResAll[1].iHeight      = 576;
+                        m_desktopResAll[1].iScreenWidth = 720;
+                        m_desktopResAll[1].iScreenHeight= 576;
+                        m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+                        m_desktopResAll[1].fRefreshRate = 50;
+                        m_desktopResAll[1].fPixelRatio   = 1.0f;
+                        m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 720, 576);
+                        m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[1]);
+
+                        m_desktopResAll[2].iScreen      = 0;
+                        m_desktopResAll[2].bFullScreen  = true;
+                        m_desktopResAll[2].iWidth       = 720;
+                        m_desktopResAll[2].iHeight      = 576;
+                        m_desktopResAll[2].iScreenWidth = 720;
+                        m_desktopResAll[2].iScreenHeight= 576;
+                        m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+                        m_desktopResAll[2].fRefreshRate = 50;
+                        m_desktopResAll[2].fPixelRatio   = 1.0f;
+                        m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 720, 576);
+                        m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[2]);
+                }
+        else
+                {
+                        m_desktopResAll[0].iScreen      = 0;
+                        m_desktopResAll[0].bFullScreen  = true;
+                        m_desktopResAll[0].iWidth       = 1280;
+                        m_desktopResAll[0].iHeight      = 720;
+                        m_desktopResAll[0].iScreenWidth = 1280;
+                        m_desktopResAll[0].iScreenHeight= 720;
+                        m_desktopResAll[0].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE;
+                        m_desktopResAll[0].fRefreshRate = 50;
+                        m_desktopResAll[0].fPixelRatio   = 1.0f;
+                        m_desktopResAll[0].strMode = StringUtils::Format("%dx%d", 1280, 720);
+                        m_desktopResAll[0].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen", m_desktopResAll[0].strMode.c_str(), (float)50, m_desktopResAll[0].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[0].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[0].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[0].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[0]);
+
+                        m_desktopResAll[1].iScreen      = 0;
+                        m_desktopResAll[1].bFullScreen  = true;
+                        m_desktopResAll[1].iWidth       = 1280;
+                        m_desktopResAll[1].iHeight      = 720;
+                        m_desktopResAll[1].iScreenWidth = 1280;
+                        m_desktopResAll[1].iScreenHeight= 720;
+                        m_desktopResAll[1].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DSBS;
+                        m_desktopResAll[1].fRefreshRate = 50;
+                        m_desktopResAll[1].fPixelRatio   = 1.0f;
+                        m_desktopResAll[1].strMode = StringUtils::Format("%dx%d", 1280, 720);
+                        m_desktopResAll[1].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DSBS", m_desktopResAll[1].strMode.c_str(), (float)50, m_desktopResAll[1].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[1].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[1].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[1].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[1]);
+
+                        m_desktopResAll[2].iScreen      = 0;
+                        m_desktopResAll[2].bFullScreen  = true;
+                        m_desktopResAll[2].iWidth       = 1280;
+                        m_desktopResAll[2].iHeight      = 720;
+                        m_desktopResAll[2].iScreenWidth = 1280;
+                        m_desktopResAll[2].iScreenHeight= 720;
+                        m_desktopResAll[2].dwFlags      = D3DPRESENTFLAG_PROGRESSIVE | D3DPRESENTFLAG_MODE3DTB;
+                        m_desktopResAll[2].fRefreshRate = 50;
+                        m_desktopResAll[2].fPixelRatio   = 1.0f;
+                        m_desktopResAll[2].strMode = StringUtils::Format("%dx%d", 1280, 720);
+                        m_desktopResAll[2].strMode = StringUtils::Format("%s @ %.2f%s - Full Screen 3DTB", m_desktopResAll[2].strMode.c_str(), (float)50, m_desktopResAll[2].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+                        m_desktopResAll[2].iSubtitles   = static_cast<int>(0.965 * m_desktopResAll[2].iHeight);
+
+                        CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s\n", m_desktopResAll[2].strMode.c_str());
+
+                        resolutions.push_back(m_desktopResAll[2]);
+                }
+  
+        m_desktopRes = m_desktopResAll[0];
+
+        SetDisplayResolution(tmp_resolution);
+
+        return true;
+}
+
+bool CEGLNativeTypeDags::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  *res = m_desktopResAll[0];
+  return true;
+}
+
+bool CEGLNativeTypeDags::ShowWindow(bool show)
+{
+  NXPL_ShowNativeWindowEXT(m_nativeWindow, show);
+  return true;
+}
+
+bool CEGLNativeTypeDags::SetDisplayResolution(int tmp_resolution)
+{
+        NXPL_NativeWindowInfoEXT nativeWindow;
+
+        NXPL_GetDefaultNativeWindowInfoEXT(&nativeWindow);
+        nativeWindow.x = nativeWindow.y = 0;
+        nativeWindow.width = m_desktopRes.iWidth;
+        nativeWindow.height = m_desktopRes.iHeight;
+
+        if (tmp_resolution == 1080 || tmp_resolution == 2160)
+                nativeWindow.stretch = true;
+        
+        NXPL_UpdateNativeWindowEXT(m_nativeWindow, &nativeWindow);
+
+        return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeDags.h b/xbmc/windowing/egl/EGLNativeTypeDags.h
new file mode 100644
index 0000000..9d2176a
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeDags.h
@@ -0,0 +1,199 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+
+#include <vector>
+#include <string>
+
+#define NEXUS_DISPLAYHANDLE void*
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *NXPL_PlatformHandle;
+
+typedef enum NEXUS_BlendFactor
+{
+    NEXUS_BlendFactor_eZero
+} NEXUS_BlendFactor;
+
+typedef struct NEXUS_BlendEquation
+{
+    NEXUS_BlendFactor a;
+    NEXUS_BlendFactor b;
+    bool              subtract_cd;
+    NEXUS_BlendFactor c;
+    NEXUS_BlendFactor d;
+    bool              subtract_e;
+    NEXUS_BlendFactor e;
+} NEXUS_BlendEquation;
+
+typedef struct
+{
+   uint32_t             width;
+   uint32_t             height;
+   uint32_t             x;
+   uint32_t             y;
+   bool                 stretch;
+   uint32_t             clientID;
+   uint32_t             zOrder;
+   NEXUS_BlendEquation  colorBlend;
+   NEXUS_BlendEquation  alphaBlend;
+   uint32_t             magic;
+} NXPL_NativeWindowInfoEXT;
+
+/* FOR NXCLINET */
+typedef unsigned NEXUS_Error;
+
+#define NXCLIENT_MAX_NAME 32
+
+/***************************************************************************
+Summary:
+Autheticated ID for client/server communication.
+
+Description:
+For non-secure environments, the certificate could be a simple ID.
+For secure environments, this should use encrypted using standard public-key cryptography.
+***************************************************************************/
+typedef struct NEXUS_Certificate
+{
+    unsigned char data[256];
+    unsigned length;
+} NEXUS_Certificate;
+
+/**
+Summary:
+Client modes
+
+See nexus/docs/Nexus_MultiProcess.pdf for full discussion of process isolation and multi-process application design.
+**/
+typedef enum NEXUS_ClientMode
+{
+    NEXUS_ClientMode_eUnprotected, /* deprecated */
+    NEXUS_ClientMode_eVerified,    /* verify handle value, but not owner. unsynchronized caller may compromise nexus settings. */
+    NEXUS_ClientMode_eProtected,   /* full handle verification. access to full API. if client crashes, server is protected. */
+    NEXUS_ClientMode_eUntrusted,   /* full handle verification. access to limited API. see nexus/build/common/tools/nexus_untrusted_api.txt. if client crashes, server is protected. */
+    NEXUS_ClientMode_eMax
+} NEXUS_ClientMode;
+
+/**
+Summary:
+Join with Nexus server application (using app ipc) and Nexus driver (using Nexus multiprocess)
+
+Description:
+This dynamically registers a client with both nexus and the server app.
+NxClient_Join can be called from multiple processes, or multiple times from the same process.
+
+NxClient_Join is reference counted within the same process. You must call NxClient_Uninit an equal
+number of times to detach from nexus and the server app.
+**/
+typedef struct NxClient_JoinSettings
+{
+    char name[NXCLIENT_MAX_NAME];
+    bool tunnelCapable; /* deprecated */
+    unsigned timeout; /* in seconds. if unable to join, try again for this number of seconds. defaults to 0. */
+    unsigned session; /* set index to choose which session in a multi-session server configuration */
+    bool ignoreStandbyRequest; /* deprecated. see NxClient_RegisterAcknowledgeStandby() instead. */
+    NEXUS_ClientMode mode; /* requested client mode. server may reject the request. */
+    NEXUS_Certificate certificate; /* allows NEXUS_ClientMode_eProtected (aka trusted) status if server requires */
+} NxClient_JoinSettings;
+
+extern void NxClient_GetDefaultJoinSettings(NxClient_JoinSettings *pSettings);
+
+extern NEXUS_Error NxClient_Join(const NxClient_JoinSettings *pSettings);
+
+extern void NxClient_Uninit(void);
+
+
+/* Register a display for exclusive use. The client application should not use the display until
+ * calling NXPL_UnregisterNexusDisplayPlatform.
+ * It will register its own memory, h/w and display APIs suitable for basic exclusive mode rendering on
+ * a Nexus display.
+ * Fills in the NXPL platform handle, which must be passed back into the unregister function.
+ */
+void NXPL_RegisterNexusDisplayPlatform(NXPL_PlatformHandle *handle, NEXUS_DISPLAYHANDLE display);
+
+/* Unregister a display for exclusive use. The client application can the use the Nexus display again. */
+void NXPL_UnregisterNexusDisplayPlatform(NXPL_PlatformHandle handle);
+
+/* Generate a default NXPL_NativeWindowInfoEXT */
+void NXPL_GetDefaultNativeWindowInfoEXT(NXPL_NativeWindowInfoEXT *info);
+
+/* Create a 'native window' of the given size. This is really just a small structure that holds the size
+ * of the window that EGL will write into. */
+void *NXPL_CreateNativeWindowEXT(const NXPL_NativeWindowInfoEXT *info);
+
+/* Destroy a 'native window' */
+void NXPL_DestroyNativeWindow(void *nativeWin);
+
+/* Show/hide a 'native window' */
+void NXPL_ShowNativeWindowEXT(void *native,bool show);
+
+/* Update a 'native window' */
+void NXPL_UpdateNativeWindowEXT(void *native, NXPL_NativeWindowInfoEXT * nativeWindow);
+
+int NEXUS_Platform_AuthenticatedJoin(const void *settings);
+#define NEXUS_Platform_Join() NEXUS_Platform_AuthenticatedJoin(NULL)
+
+#ifdef __cplusplus
+}
+#endif
+
+class CEGLNativeTypeDags : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeDags();
+  virtual ~CEGLNativeTypeDags();
+  virtual std::string GetNativeName() const { return "Dags"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+private:
+  RESOLUTION_INFO m_desktopRes;
+  RESOLUTION_INFO m_desktopResAll[4];
+
+  NXPL_PlatformHandle nxpl_handle = 0;
+  NEXUS_DISPLAYHANDLE  nexus_display = 0;
+
+  bool SetDisplayResolution(int tmp_resolution);
+    /* bool */
+  bool dags_mode_to_resolution(const char *mode, RESOLUTION_INFO *res);
+};
diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
index 30f5757..3ecd288 100644
--- a/xbmc/windowing/egl/EGLWrapper.cpp
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -37,6 +37,30 @@
 #if defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
 #include "EGLNativeTypeAmlogic.h"
 #endif
+#if defined(TARGET_DREAMBOX) 
+  #include "EGLNativeTypeDreambox.h"
+#endif
+#if defined(TARGET_V3DNXPL)
+  #include "EGLNativeTypeV3DNXPL.h"
+#endif
+#if defined(TARGET_XCORE)
+  #include "EGLNativeTypeV3D.h"
+#endif
+#if defined(TARGET_VUPLUS)
+  #include "EGLNativeTypeVuplus.h"
+#endif
+#if defined(TARGET_NEXTV)
+  #include "EGLNativeTypeNexTV.h"
+#endif
+#if defined(TARGET_DAGS)
+  #include "EGLNativeTypeDags.h"
+#endif
+#if defined(TARGET_GB)
+  #include "EGLNativeTypeGB.h"
+#endif
+#if defined(TARGET_MALI)
+  #include "EGLNativeTypeMali.h"
+#endif
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -101,6 +125,22 @@ bool CEGLWrapper::Initialize(const std::string &implementation)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation))
 #elif defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation))
+#elif defined(TARGET_DREAMBOX) 
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeDreambox>(implementation))
+#elif defined(TARGET_V3DNXPL)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeV3D>(implementation))
+#elif defined(TARGET_XCORE)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeV3D>(implementation))
+#elif defined(TARGET_VUPLUS)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeVuplus>(implementation))
+#elif defined(TARGET_NEXTV)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeNexTV>(implementation))
+#elif defined(TARGET_DAGS)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeDags>(implementation))
+#elif defined(TARGET_GB)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeGB>(implementation))
+#elif defined(TARGET_MALI)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeMali>(implementation))
 #endif
       )
   {
diff --git a/xbmc/windowing/egl/Makefile.in b/xbmc/windowing/egl/Makefile.in
index 68f7862..1977d04 100644
--- a/xbmc/windowing/egl/Makefile.in
+++ b/xbmc/windowing/egl/Makefile.in
@@ -12,6 +12,30 @@ endif
 ifeq (@USE_IMXVPU@,1)
 SRCS+= EGLNativeTypeIMX.cpp
 endif
+ifeq (@USE_V3DNXPL@,1)
+SRCS+= EGLNativeTypeV3DNXPL.cpp
+endif
+ifeq (@USE_XCORE@,1)
+SRCS+= EGLNativeTypeV3D.cpp
+endif
+ifeq (@USE_DREAMBOX@,1)
+SRCS+= EGLNativeTypeDreambox.cpp
+endif
+ifeq (@USE_VUPLUS@,1)
+SRCS+= EGLNativeTypeVuplus.cpp
+endif
+ifeq (@USE_NEXTV@,1)
+SRCS+= EGLNativeTypeNexTV.cpp
+endif
+ifeq (@USE_DAGS@,1)
+SRCS+= EGLNativeTypeDags.cpp
+endif
+ifeq (@USE_GB@,1)
+SRCS+= EGLNativeTypeGB.cpp
+endif
+ifeq (@USE_MALI@,1)
+SRCS+= EGLNativeTypeMali.cpp
+endif
 SRCS+= EGLWrapper.cpp
 
 LIB = windowing_egl.a
-- 
2.17.0.windows.1

