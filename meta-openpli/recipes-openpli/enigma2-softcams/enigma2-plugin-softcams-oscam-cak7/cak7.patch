diff --git a/config.sh b/config.sh
index e7ea074c..1e781259 100755
--- a/config.sh
+++ b/config.sh
@@ -349,7 +349,7 @@ list_config() {
 	not_have_flag USE_LIBCRYPTO && echo "CONFIG_LIB_AES=y" || echo "# CONFIG_LIB_AES=n"
 	enabled MODULE_CCCAM && echo "CONFIG_LIB_RC6=y" || echo "# CONFIG_LIB_RC6=n"
 	not_have_flag USE_LIBCRYPTO && enabled MODULE_CCCAM && echo "CONFIG_LIB_SHA1=y" || echo "# CONFIG_LIB_SHA1=n"
-	enabled_any READER_DRE MODULE_SCAM READER_VIACCESS READER_NAGRA READER_NAGRA_MERLIN READER_VIDEOGUARD READER_CONAX && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
+	enabled_any READER_DRE MODULE_SCAM READER_VIACCESS READER_NAGRA_MERLIN READER_VIDEOGUARD READER_CONAX && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
 	enabled_any MODULE_CCCAM READER_NAGRA READER_NAGRA_MERLIN READER_SECA && echo "CONFIG_LIB_IDEA=y" || echo "# CONFIG_LIB_IDEA=n"
 	not_have_flag USE_LIBCRYPTO && enabled_any READER_CONAX READER_CRYPTOWORKS READER_NAGRA READER_NAGRA_MERLIN && echo "CONFIG_LIB_BIGNUM=y" || echo "# CONFIG_LIB_BIGNUM=n"
 	enabled READER_NAGRA_MERLIN && echo "CONFIG_LIB_MDC2=y" || echo "# CONFIG_LIB_MDC2=n"
diff --git a/csctapi/icc_async.c b/csctapi/icc_async.c
index 34d6c83b..14c39637 100644
--- a/csctapi/icc_async.c
+++ b/csctapi/icc_async.c
@@ -54,6 +54,8 @@ static void calculate_cak7_vars(struct s_reader *reader, const ATR *atr)
 	mbedtls_sha256_free(&ctx_sha256);
 	memcpy(reader->cak7_aes_key,aes_key,32);
 	memcpy(reader->cak7_aes_iv,aes_iv,16);
+	char tmp[128];
+	rdr_log(reader, "Initial AES: %s", cs_hexdump(1, reader->cak7_aes_key + 16, 16, tmp, sizeof(tmp)));
 }
 
 void calculate_cak7_cmd(struct s_reader *reader, uint8_t *cmdin,uint8_t cmdlen,uint8_t *cmdout)
@@ -74,8 +76,14 @@ void do_cak7_cmd(struct s_reader *reader,unsigned char *cta_res, uint16_t *p_cta
 	// head
 	req[0]=0x80;
 	req[1]=0xCA;
-	// len
-	req[4]=inlen;
+	if(reader->protocol_type == ATR_PROTOCOL_TYPE_T0)
+	{
+		req[4]=inlen + 1;
+	}
+	else
+	{
+		req[4]=inlen;
+	}
 	req[sizeof(req)-1]=resplen;
 	data[4]=(reader->cak7_seq>>16)&0xFF;
 	data[5]=(reader->cak7_seq>>8)&0xFF;
@@ -83,9 +91,84 @@ void do_cak7_cmd(struct s_reader *reader,unsigned char *cta_res, uint16_t *p_cta
 	calculate_cak7_cmd(reader,data,inlen,&req[5]);
 	if(!ICC_Async_CardWrite(reader, req, sizeof(req), cta_res, p_cta_lr))
 	{
-		AesCtx ctx;
-		AesCtxIni(&ctx, reader->cak7_aes_iv, &reader->cak7_aes_key[16], KEY128, CBC);
-		AesDecrypt(&ctx, cta_res, cta_res, *p_cta_lr-2);
+		if(reader->protocol_type == ATR_PROTOCOL_TYPE_T0)
+		{
+			if(cta_res[*p_cta_lr - 2] == 0x61)
+			{
+				uint8_t resp[] = {0x00,0xC0,0x00,0x00,0x00};
+				memcpy(resp + 4,&cta_res[*p_cta_lr - 1],1);
+				if(!ICC_Async_CardWrite(reader, resp, sizeof(resp), cta_res, p_cta_lr))
+				{
+					AesCtx ctx;
+					AesCtxIni(&ctx, reader->cak7_aes_iv, &reader->cak7_aes_key[16], KEY128, CBC);
+					AesDecrypt(&ctx, cta_res, cta_res, *p_cta_lr-2);
+				}
+				else
+				{
+					*p_cta_lr=0;
+				}
+			}
+			else if(cta_res[*p_cta_lr - 2] == 0x6F && cta_res[*p_cta_lr - 1] == 0x01)
+			{
+				rdr_log(reader, "card answered 6F01 - trying one more time");
+				if(!ICC_Async_CardWrite(reader, req, sizeof(req), cta_res, p_cta_lr))
+				{
+					if(cta_res[*p_cta_lr - 2]  == 0x61)
+					{
+						uint8_t resp[] = {0x00,0xC0,0x00,0x00,0x00};
+						memcpy(resp + 4,&cta_res[*p_cta_lr - 1],1);
+						if(!ICC_Async_CardWrite(reader, resp, sizeof(resp), cta_res, p_cta_lr))
+						{
+							AesCtx ctx;
+							AesCtxIni(&ctx, reader->cak7_aes_iv, &reader->cak7_aes_key[16], KEY128, CBC);
+							AesDecrypt(&ctx, cta_res, cta_res, *p_cta_lr-2);
+						}
+						else
+						{
+							*p_cta_lr=0;
+						}
+					}
+					else if(cta_res[*p_cta_lr - 2]  == 0x6F && cta_res[*p_cta_lr - 1] == 0x01)
+					{
+						rdr_log(reader, "card needs reinit");
+					}
+				}
+				else
+				{
+					*p_cta_lr=0;
+				}
+			}
+		}
+		else
+		{
+			if(cta_res[*p_cta_lr - 2] == 0x6F && cta_res[*p_cta_lr - 1] == 0x01)
+			{
+				rdr_log(reader, "card answered 6F01 - trying one more time");
+				if(!ICC_Async_CardWrite(reader, req, sizeof(req), cta_res, p_cta_lr))
+				{
+					if(cta_res[*p_cta_lr - 2] == 0x6F && cta_res[*p_cta_lr - 1] == 0x01)
+					{
+						rdr_log(reader, "card needs reinit");
+					}
+					else
+					{
+						AesCtx ctx;
+						AesCtxIni(&ctx, reader->cak7_aes_iv, &reader->cak7_aes_key[16], KEY128, CBC);
+						AesDecrypt(&ctx, cta_res, cta_res, *p_cta_lr-2);
+					}
+				}
+				else
+				{
+					*p_cta_lr=0;
+				}
+			}
+			else
+			{
+				AesCtx ctx;
+				AesCtxIni(&ctx, reader->cak7_aes_iv, &reader->cak7_aes_key[16], KEY128, CBC);
+				AesDecrypt(&ctx, cta_res, cta_res, *p_cta_lr-2);
+			}
+		}
 	}
 	else
 	{
@@ -245,29 +328,46 @@ int32_t ICC_Async_Activate(struct s_reader *reader, ATR *atr, uint16_t deprecate
 		return ERROR;
 	}
 
+	reader->cak7type = 0;
 #ifdef READER_NAGRA_MERLIN
-	bool need_nagra_layer_switch = false;
-	bool is_cak7 = false;
-
-	static const uint8_t hd03atr [] = {0x3F,0xFF,0x95,0x00,0xFF,0x91,0x81,0x71,0xA0,0x47,0x00,0x44,0x4E,0x41,0x53,0x50,0x31,0x39,0x30,0x20,0x4D,0x65,0x72,0x51,0x32,0x35,0x4F}; //HD03, HD03A (CAK6.3 Mode)
-	static const uint8_t hd03atr2[] = {0x3F,0xFF,0x95,0x00,0xFF,0x91,0x81,0x71,0xFE,0x57,0x00,0x44,0x4E,0x41,0x53,0x50,0x34,0x31,0x30,0x20,0x52,0x65,0x76,0x51,0x32,0x35,0x17}; //HD03, HD03A (CAK7 Mode)
-	static const uint8_t hd04atr [] = {0x3F,0xFF,0x95,0x00,0xFF,0x91,0x81,0x71,0xFE,0x57,0x00,0x44,0x4E,0x41,0x53,0x50,0x34,0x32,0x30,0x20,0x52,0x65,0x76,0x53,0x36,0x30,0x17}; //HD04, HD04A, HD04B (CAK7 only)
-	static const uint8_t hd04hatr[] = {0x3F,0xFF,0x95,0x00,0xFF,0x91,0x81,0x71,0xFE,0x57,0x00,0x44,0x4E,0x41,0x53,0x50,0x34,0x32,0x30,0x20,0x52,0x65,0x76,0x53,0x36,0x34,0x13}; //HD04H (CAK7 only)
-	static const uint8_t hd05atr [] = {0x3F,0xFF,0x95,0x00,0xFF,0x91,0x81,0x71,0xFE,0x57,0x00,0x44,0x4E,0x41,0x53,0x50,0x34,0x35,0x30,0x20,0x52,0x65,0x76,0x57,0x36,0x30,0x14}; //HD05, HD05A (CAK7 only)
 
 	ATR_GetRaw(atr, atrarr, &atr_size);
-	if(!memcmp(hd03atr, atrarr, atr_size)) need_nagra_layer_switch = true;
-	if(!memcmp(hd03atr2, atrarr, atr_size) || !memcmp(hd04atr, atrarr, atr_size) || !memcmp(hd04hatr, atrarr, atr_size) || !memcmp(hd05atr, atrarr, atr_size)) is_cak7 = true;
 
-	if(is_cak7)
+	if((memcmp(atrarr + 8, "DNASP40", 7) == 0) || (memcmp(atrarr + 11, "DNASP41", 7) == 0) || (memcmp(atrarr + 11, "DNASP48", 7) == 0))
+	{
+		rdr_log(reader, "card needs reset before init");
+		memset(atr, 0, 1);
+		call(crdr_ops->activate(reader, atr)); //try to read the atr of this layer
+		ATR_GetRaw(atr, atrarr, &atr_size);
+		rdr_log(reader,"ATR: %s", cs_hexdump(1, atrarr, atr_size, tmp, sizeof(tmp)));
+		// Parse_ATR and InitCard need to be included in lock because they change parity of serial port
+		if(crdr_ops->lock)
+		{
+		crdr_ops->lock(reader);
+		}
+		int32_t ret1 = Parse_ATR(reader, atr, deprecated);
+		if(crdr_ops->unlock)
+		{
+			crdr_ops->unlock(reader);
+		}
+		if(ret1)
+		{
+			rdr_log(reader, "ERROR: Parse_ATR returned error");
+			return ERROR;
+		}
+	}
+
+	if((memcmp(atrarr + 8, "DNASP4", 6) == 0) || (memcmp(atrarr + 11, "DNASP4", 6) == 0))
 	{
-		rdr_log(reader, "detected nagra merlin card in CAK7 mode");
+		rdr_log(reader, "detected card in CAK7 mode");
 		calculate_cak7_vars(reader, atr);
+		reader->cak7type = 1;
 	}
-	else if(need_nagra_layer_switch)
+	else if(((memcmp(atrarr + 7, "pp", 2) == 0 && ((atrarr[9]&0x0F) >= 10)) || (memcmp(atrarr + 11, "DNASP18", 7) == 0) || (memcmp(atrarr + 11, "DNASP19", 7) == 0) || (memcmp(atrarr + 11, "DNASP1A", 7) == 0)) && reader->cak7_mode)
 	{
-		rdr_log(reader, "detected nagra merlin card in legacy mode -> try switch nagra layer to CAK7");
-		uint8_t changerom_handshake[] = { 0x80, 0xCA, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10 };
+		rdr_log(reader, "detected card in CAK6/Seca mode -> try switch to Nagra CAK7");
+		uint8_t changerom_handshake[22];
+		memset(changerom_handshake, 0x00, 22);
 
 		calculate_changerom_cmd(reader, atr, &changerom_handshake[5]);
 		memset(reader->rom, 0, 15);
@@ -275,6 +375,8 @@ int32_t ICC_Async_Activate(struct s_reader *reader, ATR *atr, uint16_t deprecate
 		memset(cta_res, 0, CTA_RES_LEN);
 		uint16_t cta_lr;
 
+		changerom_handshake[0] = 0x80;
+		changerom_handshake[1] = 0xCA;
 		changerom_handshake[4] = 0x11; // 0x11: length of data we will send
 		uint8_t cta_res1_ok = 0x61;
 		uint8_t cta_res2_ok = 0x10;
@@ -287,6 +389,9 @@ int32_t ICC_Async_Activate(struct s_reader *reader, ATR *atr, uint16_t deprecate
 			cta_res2_ok = 0x00;
 		}
 
+		changerom_handshake[21] = 0x10;
+
+		reader->cak7type = 1;
 		if(!ICC_Async_CardWrite(reader, changerom_handshake, sizeof(changerom_handshake), cta_res, &cta_lr))
 		{
 			if(cta_res[cta_lr-2] == cta_res1_ok && cta_res[cta_lr-1] == cta_res2_ok)
@@ -295,17 +400,31 @@ int32_t ICC_Async_Activate(struct s_reader *reader, ATR *atr, uint16_t deprecate
 				memset(atr, 0, 1);
 				call(crdr_ops->activate(reader, atr)); //try to read the atr of this layer
 				ATR_GetRaw(atr, atrarr, &atr_size);
-				rdr_log(reader,"Nagra layer ATR: %s", cs_hexdump(1, atrarr, atr_size, tmp, sizeof(tmp)));
+				rdr_log(reader,"ATR: %s", cs_hexdump(1, atrarr, atr_size, tmp, sizeof(tmp)));
 				calculate_cak7_vars(reader, atr);
+				if(reader->protocol_type == ATR_PROTOCOL_TYPE_T0)
+				{
+					reader->cak7type = 3;
+				}
+				else
+				{
+					reader->cak7type = 1;
+				}
+
 				if(crdr_ops->lock)
 				{
 					crdr_ops->lock(reader);
 				}
-				Parse_ATR(reader, atr, deprecated);
+				int32_t ret2 = Parse_ATR(reader, atr, deprecated);
 				if(crdr_ops->unlock)
 				{
 					crdr_ops->unlock(reader);
 				}
+				if(ret2)
+				{
+					rdr_log(reader, "ERROR: Parse_ATR returned error");
+					return ERROR;
+				}
 			}
 			else
 			{
@@ -362,7 +481,7 @@ int32_t ICC_Async_CardWrite(struct s_reader *reader, unsigned char *command, uin
 		case ATR_PROTOCOL_TYPE_T1:
 			ret = Protocol_T1_Command(reader, command, command_len, rsp, lr);
 			type = 1;
-			if(ret != OK && !crdr_ops->skip_t1_command_retries)
+			if(ret != OK && !crdr_ops->skip_t1_command_retries && reader->cak7type == 0)
 			{
 				//try to resync
 				rdr_log(reader, "Resync error: readtimeouts %d/%d (max/min) us, writetimeouts %d/%d (max/min) us", reader->maxreadtimeout, reader->minreadtimeout, reader->maxwritetimeout, reader->minwritetimeout);
@@ -398,7 +517,7 @@ int32_t ICC_Async_CardWrite(struct s_reader *reader, unsigned char *command, uin
 		}
 		try++;
 	}
-	while((try < 3) && (ret != OK)); // always do one retry when failing
+	while((try < 3) && (ret != OK) && (((type == 0 || type == 1) && reader->cak7type == 0) || type == 14)); // always do one retry when failing
 	if(crdr_ops->unlock)
 	{
 		crdr_ops->unlock(reader);
diff --git a/globals.h b/globals.h
index 62e6b1cd..433dd13d 100644
--- a/globals.h
+++ b/globals.h
@@ -1556,6 +1556,7 @@ struct s_reader										// contains device info, reader info and card info
 	int32_t			resetcounter;					// actual count
 	uint32_t		auprovid;						// AU only for this provid
 	int8_t			audisabled;						// exclude reader from auto AU
+	int8_t			autype;
 	int8_t			needsemmfirst;					// 0: reader descrambles without emm first, 1: reader needs emms before it can descramble
 	struct timeb	emm_last;							// time of last successfully written emm
 	int8_t			smargopatch;
@@ -1574,27 +1575,50 @@ struct s_reader										// contains device info, reader info and card info
 #ifdef READER_CRYPTOWORKS
 	int8_t			needsglobalfirst;				// 0:Write one Global EMM for SHARED EMM disabled 1:Write one Global EMM for SHARED EMM enabled
 #endif
-#if defined(READER_NAGRA_MERLIN) || defined(READER_NAGRA)
-	uint8_t			nuid[4];
-	uint8_t			nuid_length;
-	uint8_t			cwekey[16];
-	uint8_t			cwekey_length;
-#endif
 #ifdef READER_NAGRA_MERLIN
-	uint8_t			irdid[4];
-	uint8_t			irdid_length;
-	uint8_t			public_exponent[3];
-	uint8_t			public_exponent_length;
 	uint8_t			mod1[112];
 	uint8_t			mod1_length;
+	uint8_t			cmd0eprov[2];
+	uint8_t			cmd0eprov_length;
+	uint8_t			mod2[112];
+	uint8_t			mod2_length;
+	uint8_t			tmprsa[112];
 	uint8_t			data50[80];
 	uint8_t			data50_length;
 	uint8_t			mod50[80];
 	uint8_t			mod50_length;
+	uint8_t			key3588[136];
+	uint8_t			key3588_length;
 	uint8_t			key60[96];
-	uint8_t			key60_length;
 	uint8_t			exp60[96];
-	uint8_t			exp60_length;
+	uint8_t			key68[104];
+	uint8_t			exp68[104];
+	uint8_t			key3des[16];
+	uint8_t			klucz68[24];
+	uint8_t			pairtype;
+	uint8_t			hasunique;
+	uint8_t			key3460[96];
+	uint8_t			key3460_length;
+	uint8_t			key3310[16];
+	uint8_t			key3310_length;
+	uint8_t			cwekey0[16];
+	uint8_t			cwekey0_length;
+	uint8_t			cwekey1[16];
+	uint8_t			cwekey1_length;
+	uint8_t			cwekey2[16];
+	uint8_t			cwekey2_length;
+	uint8_t			cwekey3[16];
+	uint8_t			cwekey3_length;
+	uint8_t			cwekey4[16];
+	uint8_t			cwekey4_length;
+	uint8_t			cwekey5[16];
+	uint8_t			cwekey5_length;
+	uint8_t			cwekey6[16];
+	uint8_t			cwekey6_length;
+	uint8_t			cwekey7[16];
+	uint8_t			cwekey7_length;
+	uint8_t			idird[4];
+	uint8_t			idird_length;
 	uint8_t			kdt05_00[216];
 	uint8_t			kdt05_10[208];
 	uint8_t			cardid[8];
@@ -1605,7 +1629,12 @@ struct s_reader										// contains device info, reader info and card info
 	uint8_t			block3[8];
 	uint8_t			v[8];
 	uint8_t			iout[8];
+	uint32_t		dword_83DBC;
 	uint8_t			data2[4];
+	uint8_t			ecmheader[4];
+	uint8_t			timestmp1[4];
+	uint8_t			timestmp2[4];
+	uint8_t			cak7expo[0x11];
 	uint8_t			data[0x80];
 	uint8_t			step1[0x60];
 	uint8_t			step2[0x68];
@@ -1614,12 +1643,22 @@ struct s_reader										// contains device info, reader info and card info
 	uint8_t			result[104];
 	uint8_t			stillencrypted[0x50];
 	uint8_t			resultrsa[0x50];
-	uint32_t		cak7_restart;
 	uint32_t		cak7_seq;
+	uint32_t		needrestart;
+	uint8_t			otpcsc[2];
+	uint8_t			otpcsc_length;
+	uint8_t			otacsc[2];
+	uint8_t			otacsc_length;
+	uint8_t			forcepair[1];
+	uint8_t			forcepair_length;
 	uint8_t			cak7_camstate;
 	uint8_t			cak7_aes_key[32];
 	uint8_t			cak7_aes_iv[16];
-	struct timeb	last_refresh;
+	int8_t			forcecwswap;
+	int8_t			evensa;
+	int8_t			forceemmg;
+	int8_t                  cwpkota;
+
 #endif
 #ifdef CS_CACHEEX
 	CECSP			cacheex;						// CacheEx Settings
@@ -1644,6 +1683,12 @@ struct s_reader										// contains device info, reader info and card info
 	int32_t			l_port;
 	CAIDTAB			ctab;
 	uint32_t		boxid;
+	int8_t			cak7_mode;
+	uint8_t			cak7type;
+	uint8_t			cwpkcaid[2];
+	uint8_t			cwpkcaid_length;
+	uint8_t			nuid[4];
+	uint8_t			nuid_length;
 	int8_t			nagra_read;						// read nagra ncmed records: 0 Disabled (default), 1 read all records, 2 read valid records only
 	int8_t			detect_seca_nagra_tunneled_card;
 	int8_t			force_irdeto;
@@ -1651,6 +1696,8 @@ struct s_reader										// contains device info, reader info and card info
 	uint8_t			boxkey_length;
 	uint8_t			rsa_mod[120];					// rsa modulus for nagra cards.
 	uint8_t			rsa_mod_length;
+	uint8_t			cwpk_mod[16];					// cwpk modulus for conax cards.
+	uint8_t			cwpk_mod_length;
 	uint8_t			des_key[128];					// 3des key for Viaccess 16 bytes, des key for Dre 128 bytes
 	uint8_t			des_key_length;
 	uint8_t			atr[64];
@@ -1662,8 +1709,18 @@ struct s_reader										// contains device info, reader info and card info
 	SIDTABS			lb_sidtabs;
 	uint8_t			hexserial[8];
 	int32_t			nprov;
+	int32_t			nsa;
+	int32_t			nemm84;
+	int32_t			nemm83u;
+	int32_t			nemm83s;
+	int32_t			nemm87;
 	uint8_t			prid[CS_MAXPROV][8];
 	uint8_t			sa[CS_MAXPROV][4];				// viaccess & seca
+	uint8_t			emm84[CS_MAXPROV][3];
+	uint8_t			emm83u[CS_MAXPROV][6];
+	uint8_t			emm83s[CS_MAXPROV][6];
+	uint8_t			emm87[CS_MAXPROV][6];
+	uint8_t			emm82;
 	uint8_t			read_old_classes;				// viaccess
 	uint8_t			maturity;						// viaccess & seca maturity level
 	uint16_t		caid;
diff --git a/module-webif.c b/module-webif.c
index 29c96083..6854a047 100644
--- a/module-webif.c
+++ b/module-webif.c
@@ -2620,6 +2620,9 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 		tpl_addVar(vars, TPLADD, "AUDISABLEDVALUE", (rdr->audisabled == 1) ? "1" : "0");
 	}
 
+	tpl_printf(vars, TPLADD, "TMP", "AUTYPE%d", rdr->autype);
+	tpl_addVar(vars, TPLADD, tpl_getVar(vars, "TMP"), "selected");
+
 	// AUprovid
 	if(rdr->auprovid)
 		{ tpl_printf(vars, TPLADD, "AUPROVID", "%06X", rdr->auprovid); }
@@ -2681,8 +2684,32 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 		for(i = 0; i < len ; i++)
 			{ tpl_printf(vars, TPLAPPEND, "BOXKEY", "%02X", rdr->boxkey[i]); }
 	}
+#ifdef READER_CONAX
+	// CWPK Key
+	len = rdr->cwpk_mod_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len; i++) { tpl_printf(vars, TPLAPPEND, "CWPKKEY", "%02X", rdr->cwpk_mod[i]); }
+	}
+#endif
 
 #ifdef READER_NAGRA_MERLIN
+	// idird (CAK7)
+	len = rdr->idird_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "IDIRD", "%02X", rdr->idird[i]); }
+	}
+
+	// cmd0e_provider (CAK7)
+	len = rdr->cmd0eprov_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CMD0EPROV", "%02X", rdr->cmd0eprov[i]); }
+	}
+
 	// mod1 (CAK7)
 	len = rdr->mod1_length;
 	if(len > 0)
@@ -2691,6 +2718,38 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 			{ tpl_printf(vars, TPLAPPEND, "MOD1", "%02X", rdr->mod1[i]); }
 	}
 
+	// mod2 (CAK7)
+	len = rdr->mod2_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "MOD2", "%02X", rdr->mod2[i]); }
+	}
+
+	// key3588 (CAK7)
+	len = rdr->key3588_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "KEY3588", "%02X", rdr->key3588[i]); }
+	}
+
+	// key3310 (CAK7)
+	len = rdr->key3310_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+		{ tpl_printf(vars, TPLAPPEND, "KEY3310", "%02X", rdr->key3310[i]); }
+	}
+
+	// key3460 (CAK7)
+	len = rdr->key3460_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "KEY3460", "%02X", rdr->key3460[i]); }
+	}
+
 	// data50 (CAK7)
 	len = rdr->data50_length;
 	if(len > 0)
@@ -2707,39 +2766,131 @@ static char *send_oscam_reader_config(struct templatevars *vars, struct uriparam
 			{ tpl_printf(vars, TPLAPPEND, "MOD50", "%02X", rdr->mod50[i]); }
 	}
 
-	// key60 (CAK7)
-	len = rdr->key60_length;
+	// nuid (CAK7)
+	len = rdr->nuid_length;
 	if(len > 0)
 	{
 		for(i = 0; i < len ; i++)
-			{ tpl_printf(vars, TPLAPPEND, "KEY60", "%02X", rdr->key60[i]); }
+			{ tpl_printf(vars, TPLAPPEND, "NUID", "%02X", rdr->nuid[i]); }
 	}
 
-	// exp60 (CAK7)
-	len = rdr->exp60_length;
+	// OTP CSC (CAK7)
+	len = rdr->otpcsc_length;
 	if(len > 0)
 	{
 		for(i = 0; i < len ; i++)
-			{ tpl_printf(vars, TPLAPPEND, "EXP60", "%02X", rdr->exp60[i]); }
+			{ tpl_printf(vars, TPLAPPEND, "OTPCSC", "%02X", rdr->otpcsc[i]); }
 	}
 
-	// nuid (CAK7)
-	len = rdr->nuid_length;
+	// OTA CSC (CAK7)
+	len = rdr->otacsc_length;
 	if(len > 0)
 	{
 		for(i = 0; i < len ; i++)
-			{ tpl_printf(vars, TPLAPPEND, "NUID", "%02X", rdr->nuid[i]); }
+			{ tpl_printf(vars, TPLAPPEND, "OTACSC", "%02X", rdr->otacsc[i]); }
+	}
+
+	// Force Pairing Type (CAK7)
+	len = rdr->forcepair_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "FORCEPAIR", "%02X", rdr->forcepair[i]); }
+	}
+
+	// cwekey0 (CAK7)
+	len = rdr->cwekey0_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY0", "%02X", rdr->cwekey0[i]); }
+	}
+
+	// cwekey1 (CAK7)
+	len = rdr->cwekey1_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY1", "%02X", rdr->cwekey1[i]); }
+	}
+
+	// cwekey2 (CAK7)
+	len = rdr->cwekey2_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY2", "%02X", rdr->cwekey2[i]); }
+	}
+
+	// cwekey3 (CAK7)
+	len = rdr->cwekey3_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY3", "%02X", rdr->cwekey3[i]); }
+	}
+
+	// cwekey4 (CAK7)
+	len = rdr->cwekey4_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY4", "%02X", rdr->cwekey4[i]); }
+	}
+
+	// cwekey5 (CAK7)
+	len = rdr->cwekey5_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY5", "%02X", rdr->cwekey5[i]); }
 	}
 
-	// cwekey (CAK7)
-	len = rdr->cwekey_length;
+	// cwekey6 (CAK7)
+	len = rdr->cwekey6_length;
 	if(len > 0)
 	{
 		for(i = 0; i < len ; i++)
-			{ tpl_printf(vars, TPLAPPEND, "CWEKEY", "%02X", rdr->cwekey[i]); }
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY6", "%02X", rdr->cwekey6[i]); }
 	}
+
+	// cwekey7 (CAK7)
+	len = rdr->cwekey7_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWEKEY7", "%02X", rdr->cwekey7[i]); }
+	}
+
+	// force_cw_swap
+	if(rdr->forcecwswap)
+		{ tpl_addVar(vars, TPLADD, "FORCECWSWAPCHECKED", "checked"); }
+
+	// only_even_SA
+	if(rdr->evensa)
+		{ tpl_addVar(vars, TPLADD, "EVENSACHECKED", "checked"); }
+
+	// force_EMM_82
+	if(rdr->forceemmg)
+		{ tpl_addVar(vars, TPLADD, "FORCEEMMGCHECKED", "checked"); }
+
+        // OTA_CWPKs
+        if(rdr->cwpkota)
+                { tpl_addVar(vars, TPLADD, "CWPKOTACHECKED", "checked"); }
 #endif
 
+	// CWPK CaID (CAK7)
+	len = rdr->cwpkcaid_length;
+	if(len > 0)
+	{
+		for(i = 0; i < len ; i++)
+			{ tpl_printf(vars, TPLAPPEND, "CWPKCAID", "%02X", rdr->cwpkcaid[i]); }
+	}
+
+	// cak7_mode
+	if(rdr->cak7_mode)
+		{ tpl_addVar(vars, TPLADD, "NAGRACAK7MODECHECKED", "checked"); }
+
 	// ins7E
 	if(rdr->ins7E[0x1A])
 	{
diff --git a/oscam-config-reader.c b/oscam-config-reader.c
index c91ae93f..528c66f5 100644
--- a/oscam-config-reader.c
+++ b/oscam-config-reader.c
@@ -230,6 +230,43 @@ static void boxid_fn(const char *token, char *value, void *setting, FILE *f)
 		{ fprintf_conf(f, token, "\n"); }
 }
 
+static void cwpkkey_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+	//	rdr_log(rdr, "CWPK config key length: %16X", len);
+		if(len == 0 || len > 32)
+		{
+			rdr->cwpk_mod_length = 0;
+			memset(rdr->cwpk_mod, 0, sizeof(rdr->cwpk_mod));
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwpk_mod, len))
+			{
+				fprintf(stderr, "reader cwpkkey parse error, %s=%s\n", token, value);
+				rdr->cwpk_mod_length = 0;
+				memset(rdr->cwpk_mod, 0, sizeof(rdr->cwpk_mod));
+			}
+			else
+			{
+				rdr->cwpk_mod_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwpk_mod_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwpkkey", "%s\n", cs_hexdump(0, rdr->cwpk_mod, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwpkkey", "\n"); }
+}
+
 static void rsakey_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
@@ -375,6 +412,150 @@ static void mod1_fn(const char *token, char *value, void *setting, FILE *f)
 		{ fprintf_conf(f, "mod1", "\n"); }
 }
 
+static void mod2_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 224)
+		{
+			rdr->mod2_length = 0;
+			memset(rdr->mod2, 0, 112);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->mod2, len))
+			{
+				fprintf(stderr, "reader mod2 parse error, %s=%s\n", token, value);
+				rdr->mod2_length = 0;
+				memset(rdr->mod2, 0, sizeof(rdr->mod2));
+			}
+			else
+			{
+				rdr->mod2_length = len/2;
+			}
+		}
+	return;
+	}
+	int32_t len = rdr->mod2_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "mod2", "%s\n", cs_hexdump(0, rdr->mod2, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "mod2", "\n"); }
+}
+
+static void idird_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 8)
+		{
+			rdr->idird_length = 0;
+			memset(rdr->idird, 0, 4);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->idird, len))
+			{
+				fprintf(stderr, "reader idird parse error, %s=%s\n", token, value);
+				rdr->idird_length = 0;
+				memset(rdr->idird, 0, sizeof(rdr->idird));
+			}
+			else
+			{
+				rdr->idird_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->idird_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "idird", "%s\n", cs_hexdump(0, rdr->idird, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "idird", "\n"); }
+}
+
+static void cmd0eprov_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 4)
+		{
+			rdr->cmd0eprov_length = 0;
+			memset(rdr->cmd0eprov, 0, 2);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cmd0eprov, len))
+			{
+				fprintf(stderr, "reader cmd0eprov parse error, %s=%s\n", token, value);
+				rdr->cmd0eprov_length = 0;
+				memset(rdr->cmd0eprov, 0, sizeof(rdr->cmd0eprov));
+			}
+			else
+			{
+				rdr->cmd0eprov_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cmd0eprov_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cmd0eprov", "%s\n", cs_hexdump(0, rdr->cmd0eprov, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cmd0eprov", "\n"); }
+}
+
+static void key3588_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 272)
+		{
+			rdr->key3588_length = 0;
+			memset(rdr->key3588, 0, 136);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->key3588, len))
+			{
+				fprintf(stderr, "reader key3588 parse error, %s=%s\n", token, value);
+				rdr->key3588_length = 0;
+				memset(rdr->key3588, 0, sizeof(rdr->key3588));
+			}
+			else
+			{
+				rdr->key3588_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->key3588_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "key3588", "%s\n", cs_hexdump(0, rdr->key3588, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "key3588", "\n"); }
+}
+
 static void data50_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
@@ -447,7 +628,7 @@ static void mod50_fn(const char *token, char *value, void *setting, FILE *f)
 		{ fprintf_conf(f, "mod50", "\n"); }
 }
 
-static void key60_fn(const char *token, char *value, void *setting, FILE *f)
+static void key3460_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
 	if(value)
@@ -455,72 +636,70 @@ static void key60_fn(const char *token, char *value, void *setting, FILE *f)
 		int32_t len = cs_strlen(value);
 		if(len != 192)
 		{
-			rdr->key60_length = 0;
-			memset(rdr->key60, 0, 96);
+			rdr->key3460_length = 0;
+			memset(rdr->key3460, 0, 96);
 		}
 		else
 		{
-			if(key_atob_l(value, rdr->key60, len))
+			if(key_atob_l(value, rdr->key3460, len))
 			{
-				fprintf(stderr, "reader key60 parse error, %s=%s\n", token, value);
-				rdr->key60_length = 0;
-				memset(rdr->key60, 0, sizeof(rdr->key60));
+				fprintf(stderr, "reader key3460 parse error, %s=%s\n", token, value);
+				rdr->key3460_length = 0;
+				memset(rdr->key3460, 0, sizeof(rdr->key3460));
 			}
 			else
 			{
-				rdr->key60_length = len/2;
+				rdr->key3460_length = len/2;
 			}
 		}
 		return;
 	}
-	int32_t len = rdr->key60_length;
+	int32_t len = rdr->key3460_length;
 	if(len > 0)
 	{
 		char tmp[len * 2 + 1];
-		fprintf_conf(f, "key60", "%s\n", cs_hexdump(0, rdr->key60, len, tmp, sizeof(tmp)));
+		fprintf_conf(f, "key3460", "%s\n", cs_hexdump(0, rdr->key3460, len, tmp, sizeof(tmp)));
 	}
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, "key60", "\n"); }
+		{ fprintf_conf(f, "key3460", "\n"); }
 }
 
-static void exp60_fn(const char *token, char *value, void *setting, FILE *f)
+static void key3310_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
 	if(value)
 	{
 		int32_t len = cs_strlen(value);
-		if(len != 192)
+		if(len != 32)
 		{
-			rdr->exp60_length = 0;
-			memset(rdr->exp60, 0, 96);
+			rdr->key3310_length = 0;
+			memset(rdr->key3310, 0, 16);
 		}
 		else
 		{
-			if(key_atob_l(value, rdr->exp60, len))
+			if(key_atob_l(value, rdr->key3310, len))
 			{
-				fprintf(stderr, "reader exp60 parse error, %s=%s\n", token, value);
-				rdr->exp60_length = 0;
-				memset(rdr->exp60, 0, sizeof(rdr->exp60));
+				fprintf(stderr, "reader key3310 parse error, %s=%s\n", token, value);
+				rdr->key3310_length = 0;
+				memset(rdr->key3310, 0, sizeof(rdr->key3310));
 			}
 			else
 			{
-				rdr->exp60_length = len/2;
+				rdr->key3310_length = len/2;
 			}
 		}
 		return;
 	}
-	int32_t len = rdr->exp60_length;
+	int32_t len = rdr->key3310_length;
 	if(len > 0)
 	{
 		char tmp[len * 2 + 1];
-		fprintf_conf(f, "exp60", "%s\n", cs_hexdump(0, rdr->exp60, len, tmp, sizeof(tmp)));
+		fprintf_conf(f, "key3310", "%s\n", cs_hexdump(0, rdr->key3310, len, tmp, sizeof(tmp)));
 	}
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, "exp60", "\n"); }
+		{ fprintf_conf(f, "key3310", "\n"); }
 }
-#endif
 
-#if defined(READER_NAGRA_MERLIN) || defined(READER_NAGRA)
 static void nuid_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
@@ -557,40 +736,436 @@ static void nuid_fn(const char *token, char *value, void *setting, FILE *f)
 		{ fprintf_conf(f, "nuid", "\n"); }
 }
 
-static void cwekey_fn(const char *token, char *value, void *setting, FILE *f)
+static void forcepair_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
 	if(value)
 	{
 		int32_t len = cs_strlen(value);
+		if(len != 2)
+		{
+			rdr->forcepair_length = 0;
+			memset(rdr->forcepair, 0, 1);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->forcepair, len))
+			{
+				fprintf(stderr, "reader forcepair parse error, %s=%s\n", token, value);
+				rdr->forcepair_length = 0;
+				memset(rdr->forcepair, 0, sizeof(rdr->forcepair));
+			}
+			else
+			{
+				rdr->forcepair_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->forcepair_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "forcepair", "%s\n", cs_hexdump(0, rdr->forcepair, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "forcepair", "\n"); }
+}
+
+static void otpcsc_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 4)
+		{
+			rdr->otpcsc_length = 0;
+			memset(rdr->otpcsc, 0, 2);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->otpcsc, len))
+			{
+				fprintf(stderr, "reader otpcsc parse error, %s=%s\n", token, value);
+				rdr->otpcsc_length = 0;
+				memset(rdr->otpcsc, 0, sizeof(rdr->otpcsc));
+			}
+			else
+			{
+				rdr->otpcsc_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->otpcsc_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "otpcsc", "%s\n", cs_hexdump(0, rdr->otpcsc, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "otpcsc", "\n"); }
+}
+
+static void otacsc_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 4)
+		{
+			rdr->otacsc_length = 0;
+			memset(rdr->otacsc, 0, 2);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->otacsc, len))
+			{
+				fprintf(stderr, "reader otacsc parse error, %s=%s\n", token, value);
+				rdr->otacsc_length = 0;
+				memset(rdr->otacsc, 0, sizeof(rdr->otacsc));
+			}
+			else
+			{
+				rdr->otacsc_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->otacsc_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "otacsc", "%s\n", cs_hexdump(0, rdr->otacsc, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "otacsc", "\n"); }
+}
+
+static void cwpkcaid_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 4)
+		{
+			rdr->cwpkcaid_length = 0;
+			memset(rdr->cwpkcaid, 0, 2);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwpkcaid, len))
+			{
+				fprintf(stderr, "reader cwpkcaid parse error, %s=%s\n", token, value);
+				rdr->cwpkcaid_length = 0;
+				memset(rdr->cwpkcaid, 0, sizeof(rdr->cwpkcaid));
+			}
+			else
+			{
+				rdr->cwpkcaid_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwpkcaid_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwpkcaid", "%s\n", cs_hexdump(0, rdr->cwpkcaid, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwpkcaid", "\n"); }
+}
+
+static void cwekey0_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey0_length = 0;
+			memset(rdr->cwekey0, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey0, len))
+			{
+				fprintf(stderr, "reader cwekey0 parse error, %s=%s\n", token, value);
+				rdr->cwekey0_length = 0;
+				memset(rdr->cwekey0, 0, sizeof(rdr->cwekey0));
+			}
+			else
+			{
+				rdr->cwekey0_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey0_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey0", "%s\n", cs_hexdump(0, rdr->cwekey0, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwekey0", "\n"); }
+}
+
+static void cwekey1_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey1_length = 0;
+			memset(rdr->cwekey1, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey1, len))
+			{
+				fprintf(stderr, "reader cwekey1 parse error, %s=%s\n", token, value);
+				rdr->cwekey1_length = 0;
+				memset(rdr->cwekey1, 0, sizeof(rdr->cwekey1));
+			}
+			else
+			{
+				rdr->cwekey1_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey1_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey1", "%s\n", cs_hexdump(0, rdr->cwekey1, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwekey1", "\n"); }
+}
+
+static void cwekey2_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey2_length = 0;
+			memset(rdr->cwekey2, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey2, len))
+			{
+				fprintf(stderr, "reader cwekey2 parse error, %s=%s\n", token, value);
+				rdr->cwekey2_length = 0;
+				memset(rdr->cwekey2, 0, sizeof(rdr->cwekey2));
+			}
+			else
+			{
+				rdr->cwekey2_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey2_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey2", "%s\n", cs_hexdump(0, rdr->cwekey2, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwekey2", "\n"); }
+}
+
+static void cwekey3_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
 		if(len != 32)
 		{
-			rdr->cwekey_length = 0;
-			memset(rdr->cwekey, 0, 16);
+			rdr->cwekey3_length = 0;
+			memset(rdr->cwekey3, 0, 16);
 		}
 		else
 		{
-			if(key_atob_l(value, rdr->cwekey, len))
+			if(key_atob_l(value, rdr->cwekey3, len))
 			{
-				fprintf(stderr, "reader cwekey parse error, %s=%s\n", token, value);
-				rdr->cwekey_length = 0;
-				memset(rdr->cwekey, 0, sizeof(rdr->cwekey));
+				fprintf(stderr, "reader cwekey3 parse error, %s=%s\n", token, value);
+				rdr->cwekey3_length = 0;
+				memset(rdr->cwekey3, 0, sizeof(rdr->cwekey3));
 			}
 			else
 			{
-				rdr->cwekey_length = len/2;
+				rdr->cwekey3_length = len/2;
 			}
 		}
 		return;
 	}
-	int32_t len = rdr->cwekey_length;
+	int32_t len = rdr->cwekey3_length;
 	if(len > 0)
 	{
 		char tmp[len * 2 + 1];
-		fprintf_conf(f, "cwekey", "%s\n", cs_hexdump(0, rdr->cwekey, len, tmp, sizeof(tmp)));
+		fprintf_conf(f, "cwekey3", "%s\n", cs_hexdump(0, rdr->cwekey3, len, tmp, sizeof(tmp)));
 	}
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, "cwekey", "\n"); }
+		{ fprintf_conf(f, "cwekey3", "\n"); }
+}
+
+static void cwekey4_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey4_length = 0;
+			memset(rdr->cwekey4, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey4, len))
+			{
+				fprintf(stderr, "reader cwekey4 parse error, %s=%s\n", token, value);
+				rdr->cwekey4_length = 0;
+				memset(rdr->cwekey4, 0, sizeof(rdr->cwekey4));
+			}
+			else
+			{
+				rdr->cwekey4_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey4_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey4", "%s\n", cs_hexdump(0, rdr->cwekey4, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+	{ fprintf_conf(f, "cwekey4", "\n"); }
+}
+
+static void cwekey5_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey5_length = 0;
+			memset(rdr->cwekey5, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey5, len))
+			{
+				fprintf(stderr, "reader cwekey5 parse error, %s=%s\n", token, value);
+				rdr->cwekey5_length = 0;
+				memset(rdr->cwekey5, 0, sizeof(rdr->cwekey5));
+			}
+			else
+			{
+				rdr->cwekey5_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey5_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey5", "%s\n", cs_hexdump(0, rdr->cwekey5, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwekey5", "\n"); }
+}
+
+static void cwekey6_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey6_length = 0;
+			memset(rdr->cwekey6, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey6, len))
+			{
+				fprintf(stderr, "reader cwekey6 parse error, %s=%s\n", token, value);
+				rdr->cwekey6_length = 0;
+				memset(rdr->cwekey6, 0, sizeof(rdr->cwekey6));
+			}
+			else
+			{
+				rdr->cwekey6_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey6_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey6", "%s\n", cs_hexdump(0, rdr->cwekey6, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwekey6", "\n"); }
+}
+
+static void cwekey7_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	struct s_reader *rdr = setting;
+	if(value)
+	{
+		int32_t len = strlen(value);
+		if(len != 32)
+		{
+			rdr->cwekey7_length = 0;
+			memset(rdr->cwekey7, 0, 16);
+		}
+		else
+		{
+			if(key_atob_l(value, rdr->cwekey7, len))
+			{
+				fprintf(stderr, "reader cwekey7 parse error, %s=%s\n", token, value);
+				rdr->cwekey7_length = 0;
+				memset(rdr->cwekey7, 0, sizeof(rdr->cwekey7));
+			}
+			else
+			{
+				rdr->cwekey7_length = len/2;
+			}
+		}
+		return;
+	}
+	int32_t len = rdr->cwekey7_length;
+	if(len > 0)
+	{
+		char tmp[len * 2 + 1];
+		fprintf_conf(f, "cwekey7", "%s\n", cs_hexdump(0, rdr->cwekey7, len, tmp, sizeof(tmp)));
+	}
+	else if(cfg.http_full_cfg)
+		{ fprintf_conf(f, "cwekey7", "\n"); }
 }
 #endif
 
@@ -1205,18 +1780,38 @@ static const struct config_list reader_opts[] =
 	DEF_OPT_FUNC("boxid"                          , 0,                                    boxid_fn),
 	DEF_OPT_FUNC("boxkey"                         , 0,                                    boxkey_fn),
 	DEF_OPT_FUNC("rsakey"                         , 0,                                    rsakey_fn),
+	DEF_OPT_FUNC("cwpkkey"                        , 0,                                    cwpkkey_fn),
 	DEF_OPT_FUNC("deskey"                         , 0,                                    deskey_fn),
 #ifdef READER_NAGRA_MERLIN
 	DEF_OPT_FUNC("mod1"                           , 0,                                    mod1_fn),
+	DEF_OPT_FUNC("idird"                          , 0,                                    idird_fn),
+	DEF_OPT_FUNC("cmd0eprov"                      , 0,                                    cmd0eprov_fn),
+	DEF_OPT_FUNC("mod2"                           , 0,                                    mod2_fn),
+	DEF_OPT_FUNC("key3588"                        , 0,                                    key3588_fn),
+	DEF_OPT_FUNC("key3460"                        , 0,                                    key3460_fn),
+	DEF_OPT_FUNC("key3310"                        , 0,                                    key3310_fn),
 	DEF_OPT_FUNC("data50"                         , 0,                                    data50_fn),
 	DEF_OPT_FUNC("mod50"                          , 0,                                    mod50_fn),
-	DEF_OPT_FUNC("key60"                          , 0,                                    key60_fn),
-	DEF_OPT_FUNC("exp60"                          , 0,                                    exp60_fn),
-#endif
-#if defined(READER_NAGRA_MERLIN) || defined(READER_NAGRA)
 	DEF_OPT_FUNC("nuid"                           , 0,                                    nuid_fn),
-	DEF_OPT_FUNC("cwekey"                         , 0,                                    cwekey_fn),
+	DEF_OPT_FUNC("forcepair"                      , 0,                                    forcepair_fn),
+	DEF_OPT_FUNC("otpcsc"                         , 0,                                    otpcsc_fn),
+	DEF_OPT_FUNC("otacsc"                         , 0,                                    otacsc_fn),
+	DEF_OPT_FUNC("cwpkcaid"                       , 0,                                    cwpkcaid_fn),
+	DEF_OPT_FUNC("cwekey0"                        , 0,                                    cwekey0_fn),
+	DEF_OPT_FUNC("cwekey1"                        , 0,                                    cwekey1_fn),
+	DEF_OPT_FUNC("cwekey2"                        , 0,                                    cwekey2_fn),
+	DEF_OPT_FUNC("cwekey3"                        , 0,                                    cwekey3_fn),
+	DEF_OPT_FUNC("cwekey4"                        , 0,                                    cwekey4_fn),
+	DEF_OPT_FUNC("cwekey5"                        , 0,                                    cwekey5_fn),
+	DEF_OPT_FUNC("cwekey6"                        , 0,                                    cwekey6_fn),
+	DEF_OPT_FUNC("cwekey7"                        , 0,                                    cwekey7_fn),
+	DEF_OPT_INT8("forcecwswap"                    , OFS(forcecwswap),                     0),
+	DEF_OPT_INT8("evensa"                         , OFS(evensa),                          0),
+	DEF_OPT_INT8("forceemmg"                      , OFS(forceemmg),                       0),
+	DEF_OPT_INT8("cwpkota"                        , OFS(cwpkota),                         0),
 #endif
+
+	DEF_OPT_INT8("cak7_mode"                      , OFS(cak7_mode),                       0),
 	DEF_OPT_FUNC_X("ins7e"                        , OFS(ins7E),                           ins7E_fn, SIZEOF(ins7E)),
 	DEF_OPT_FUNC_X("ins42"                        , OFS(ins42),                           ins42_fn, SIZEOF(ins42)),
 	DEF_OPT_FUNC_X("ins7e11"                      , OFS(ins7E11),                         ins7E_fn, SIZEOF(ins7E11)),
@@ -1295,6 +1890,7 @@ static const struct config_list reader_opts[] =
 #endif
 	DEF_OPT_INT8("deprecated"                     , OFS(deprecated),                      0),
 	DEF_OPT_INT8("audisabled"                     , OFS(audisabled),                      0),
+	DEF_OPT_INT8("autype"                         , OFS(autype),                          0),
 	DEF_OPT_FUNC("auprovid"                       , 0,                                    auprovid_fn),
 	DEF_OPT_INT8("ndsversion"                     , OFS(ndsversion),                      0),
 	DEF_OPT_FUNC("ratelimitecm"                   , 0,                                    ratelimitecm_fn),
@@ -1329,14 +1925,14 @@ static bool reader_check_setting(const struct config_list *UNUSED(clist), void *
 		"fix9993", "rsakey", "deskey", "ins7e", "ins42", "ins7e11", "ins2e06", "k1_generic", "k1_unique", "force_irdeto", "needsemmfirst", "boxkey",
 		"atr", "detect", "nagra_read", "mhz", "cardmhz", "readtiers", "read_old_classes", "use_gpio", "needsglobalfirst",
 #ifdef READER_NAGRA_MERLIN
-		"mod1", "data50", "mod50", "key60", "exp60",
-#endif
-#if defined(READER_NAGRA_MERLIN) || defined(READER_NAGRA)
-		"nuid", "cwekey",
+		"mod1", "idird", "cmd0eprov", "mod2", "key3588", "key3460", "key3310", "data50", "mod50", "nuid", "forcepair", "otpcsc", "otacsc", "cwpkcaid", "cwekey0", "cwekey1", "cwekey2", "cwekey3", "cwekey4", "cwekey5", "cwekey6", "cwekey7",
 #endif
 #if defined(READER_DRE) || defined(READER_DRECAS)
 		"exec_cmd_file",
 #endif
+#if READER_CONAX
+		"cwpkkey",
+#endif
 #ifdef WITH_AZBOX
 		"mode",
 #endif
@@ -1346,7 +1942,7 @@ static bool reader_check_setting(const struct config_list *UNUSED(clist), void *
 	// These are written only when the reader is network reader
 	static const char *network_only_settings[] =
 	{
-		"user", "inactivitytimeout", "reconnecttimeout",
+		"user", "inactivitytimeout", "reconnecttimeout", "autype",
 		0
 	};
 	if(is_network_reader(reader))
diff --git a/oscam-emm.c b/oscam-emm.c
index fc75799c..c190b031 100644
--- a/oscam-emm.c
+++ b/oscam-emm.c
@@ -165,6 +165,16 @@ int32_t emm_reader_match(struct s_reader *reader, uint16_t caid, uint32_t provid
 	if(reader->audisabled)
 		{ return 0; }
 
+	if(reader->cwpkcaid_length && reader->nuid_length)
+	{
+		uint8_t check[1];
+		check[0] = caid & 0xFF;
+		if(check[0] == reader->cwpkcaid[1])
+		{
+			return 1;
+		}
+	}
+
 	if(reader->caid != caid)
 	{
 		int caid_found = 0;
diff --git a/oscam-work.c b/oscam-work.c
index 148dc7dc..019a0527 100644
--- a/oscam-work.c
+++ b/oscam-work.c
@@ -11,9 +11,6 @@
 #include "oscam-string.h"
 #include "oscam-work.h"
 #include "reader-common.h"
-#ifdef READER_NAGRA_MERLIN
-#include "reader-nagracak7.h"
-#endif
 #include "module-cccam.h"
 #include "module-cccam-data.h"
 #include "module-cccshare.h"
@@ -333,12 +330,6 @@ void *work_thread(void *ptr)
 					cardreader_poll_status(reader);
 					break;
 
-#ifdef READER_NAGRA_MERLIN
-				case ACTION_READER_RENEW_SK:
-					CAK7_getCamKey(reader);
-					break;
-#endif
-
 				case ACTION_READER_INIT:
 					if(!cl->init_done)
 						{ reader_init(reader); }
diff --git a/oscam-work.h b/oscam-work.h
index 5fb9e75e..7c6ac334 100644
--- a/oscam-work.h
+++ b/oscam-work.h
@@ -16,9 +16,6 @@ enum actions
 	ACTION_READER_CHECK_HEALTH = 11,    // wr11
 	ACTION_READER_CAPMT_NOTIFY = 12,    // wr12
 	ACTION_READER_POLL_STATUS  = 13,    // wr13
-#ifdef READER_NAGRA_MERLIN
-	ACTION_READER_RENEW_SK     = 14,    // wr14
-#endif
 	ACTION_READER_SENDCMD      = 15,    // wr15
 	// Client actions
 	ACTION_CLIENT_UDP          = 22,    // wc22
diff --git a/reader-common.c b/reader-common.c
index 5df23a69..cb6753f7 100644
--- a/reader-common.c
+++ b/reader-common.c
@@ -37,6 +37,11 @@ static void reader_nullcard(struct s_reader *reader)
 	reader->csystem = NULL;
 	memset(reader->hexserial, 0, sizeof(reader->hexserial));
 	memset(reader->prid, 0xFF, sizeof(reader->prid));
+	memset(reader->sa, 0, sizeof(reader->sa));
+	memset(reader->emm84, 0, sizeof(reader->emm84));
+	memset(reader->emm83s, 0, sizeof(reader->emm83s));
+	memset(reader->emm83u, 0, sizeof(reader->emm83u));
+	memset(reader->emm87, 0, sizeof(reader->emm87));
 	reader->caid = 0;
 	reader->nprov = 0;
 	cs_clear_entitlement(reader);
diff --git a/reader-conax.c b/reader-conax.c
index 00317be7..3b08ade2 100644
--- a/reader-conax.c
+++ b/reader-conax.c
@@ -2,6 +2,91 @@
 #ifdef READER_CONAX
 #include "cscrypt/bn.h"
 #include "reader-common.h"
+#include "cscrypt/des.h"
+
+static int32_t CWPK_CNX(struct s_reader *reader,uint8_t *msg)
+{
+int32_t ret = 0;
+
+uint8_t CWp1[8];
+uint8_t CWp2[8];
+uint8_t CWs1[8];
+uint8_t CWs2[8];
+
+CWp1[0] = msg[7];
+CWp1[1] = msg[8];
+CWp1[2] = msg[9];
+CWp1[3] = msg[10];
+CWp1[4] = msg[11];
+CWp1[5] = msg[12];
+CWp1[6] = msg[13];
+CWp1[7] = msg[14];
+
+CWp2[0] = msg[22];
+CWp2[1] = msg[23];
+CWp2[2] = msg[24];
+CWp2[3] = msg[25];
+CWp2[4] = msg[26];
+CWp2[5] = msg[27];
+CWp2[6] = msg[28];
+CWp2[7] = msg[29];
+
+des_ecb3_decrypt(CWp1,reader->cwpk_mod);
+des_ecb3_decrypt(CWp2,reader->cwpk_mod);
+CWs1[0] = CWp1[4];
+CWs1[1] = CWp1[5];
+CWs1[2] = CWp1[6];
+CWs1[3] = CWp1[7];
+CWs1[4] = CWp1[0];
+CWs1[5] = CWp1[1];
+CWs1[6] = CWp1[2];
+CWs1[7] = CWp1[3];
+
+CWs2[0] = CWp2[4];
+CWs2[1] = CWp2[5];
+CWs2[2] = CWp2[6];
+CWs2[3] = CWp2[7];
+CWs2[4] = CWp2[0];
+CWs2[5] = CWp2[1];
+CWs2[6] = CWp2[2];
+CWs2[7] = CWp2[3];
+
+int chkok = 1;
+if(((CWs1[0] + CWs1[1] + CWs1[2]) & 0xFF) != CWs1[3])
+{
+	chkok = 0;
+	rdr_log(reader, "CW0 checksum error [0]");
+}
+if(((CWs1[4] + CWs1[5] + CWs1[6]) & 0xFF) != CWs1[7])
+{
+	chkok = 0;
+	rdr_log(reader, "CW0 checksum error [1]");
+}
+if(((CWs2[0] + CWs2[1] + CWs2[2]) & 0xFF) != CWs2[3])
+{
+	chkok = 0;
+	rdr_log(reader, "CW1 checksum error [0]");
+}
+if(((CWs2[4] + CWs2[5] + CWs2[6]) & 0xFF) != CWs2[7])
+{
+	chkok = 0;
+	rdr_log(reader, "CW1 checksum error [1]");
+}
+
+if(chkok == 1)
+{
+	memcpy(&msg[7],CWs1,0x08);
+	memcpy(&msg[22],CWs2,0x08);
+
+	ret = 0;
+}
+if(chkok != 1)
+{
+	ret = -8;
+}
+
+return ret;
+}
 
 static int32_t RSA_CNX(struct s_reader *reader, uint8_t *msg, uint8_t *mod, uint8_t *exp, uint32_t cta_lr, uint32_t modbytes, uint32_t expbytes)
 {
@@ -114,6 +199,26 @@ static int32_t read_record(struct s_reader *reader, const uint8_t *cmd, const ui
 	return (cta_lr - 2);
 }
 
+static int32_t check_pairing(struct s_reader *reader, const uint8_t *cmd, const uint8_t *data, uint8_t *cta_res)
+{
+	uint16_t cta_lr;
+
+	if(reader->cwpk_mod_length)
+	{
+		write_cmd(cmd, data);
+		rdr_log(reader, "CWPK Pairing is active");
+	}
+	else if(reader->rsa_mod_length)
+	{
+		rdr_log(reader, "RSA Pairing is active");
+	}
+	else
+	{
+		rdr_log(reader, "Pairing is not active");
+	}
+	return OK;
+}
+
 static uint8_t PairingECMRotation(struct s_reader *reader, const ECM_REQUEST *er, int32_t n)
 {
 	uint8_t cta_res[CTA_RES_LEN] = { 0x00 };
@@ -147,6 +252,7 @@ static int32_t conax_card_init(struct s_reader *reader, ATR *newatr)
 	uint8_t cta_res[CTA_RES_LEN];
 	int32_t i, j, n;
 	static const uint8_t ins26[] = { 0xDD, 0x26, 0x00, 0x00, 0x03, 0x10, 0x01, 0x40 };
+	static const uint8_t inscp[] = { 0xDD, 0x26, 0x00, 0x00, 0x04, 0x6C, 0x02, 0x10,0x00 };
 	uint8_t ins82[] = { 0xDD, 0x82, 0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0xb0, 0x0f, 0xff,
 						0xff, 0xfb, 0x00, 0x00, 0x09, 0x04, 0x0b, 0x00, 0xe0, 0x30, 0x2b };
 
@@ -213,6 +319,7 @@ static int32_t conax_card_init(struct s_reader *reader, ATR *newatr)
 		rdr_log(reader, "Provider: %d Provider-Id: %06X", j + 1, b2i(4, reader->prid[j]));
 		rdr_log_sensitive(reader, "Provider: %d SharedAddress: {%08X}", j + 1, b2i(4, reader->sa[j]));
 	}
+	check_pairing(reader, inscp, inscp + 5, cta_res);
 
 	return OK;
 }
@@ -239,16 +346,37 @@ static int32_t conax_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, stru
 	uint8_t exp[] = { 0x01, 0x00, 0x01 };
 	uint8_t buf[256];
 
+	char ppp = 0x00;
+
 	if((n = check_sct_len(er->ecm, 3)) < 0)
 		{ return ERROR; }
 
 	buf[0] = 0x14;
 	buf[1] = n + 1;
 
-	if(0x0 != PairingECMRotation(reader, er, n))
-		{ buf[2] = 2; } // card will answer with encrypted dw
+	if(reader->cwpk_mod_length)
+	{
+		buf[2] = 4;
+		ppp = 0x01;
+	}
+	else if(0x0 != reader->rsa_mod[0])
+	{
+		if(0x0 != PairingECMRotation(reader, er, n))
+		{
+			buf[2] = 2;
+			ppp = 0x03;
+		}
+		else
+		{
+			buf[2] = 0;
+			ppp = 0x02;
+		}
+	}
 	else
-		{ buf[2] = 0; }
+	{
+		buf[2] = 0;
+		ppp = 0x02;
+	}
 
 	memcpy(buf + 3, er->ecm, n);
 	insA2[4] = n + 3;
@@ -263,13 +391,25 @@ static int32_t conax_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, stru
 		if((cta_res[cta_lr - 2] == 0x98) || ((cta_res[cta_lr - 2] == 0x90)))
 		{
 			/*checks if answer is encrypted with RSA algo and decrypts it if needed*/
-			if(0x81 == cta_res[0] && 2 == cta_res[2] >> 5) /*81 XX 5X*/
+			if(0x81 == cta_res[0] && 2 == cta_res[2] >> 5 && 0x03 == ppp) /*81 XX 5X*/
 			{
 				if(0x00 == cta_res[cta_lr - 1])
 					{ rc = RSA_CNX(reader, cta_res, reader->rsa_mod, exp, cta_lr, 64u, 3u); }
 				else
 					{ rc = -4; } /*card has no right to decode this channel*/
 			}
+			else if(0x01 == ppp)
+			{
+				if(0x00 == cta_res[cta_lr - 1])
+				{
+					/*trying to decode using CWPK*/
+					rc = CWPK_CNX(reader, cta_res);		/*enabled when no loging needed*/
+				}
+				else
+				{
+					rc = -4;
+				}
+			}
 
 			if(0 == rc)
 			{
@@ -341,6 +481,10 @@ static int32_t conax_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, stru
 		case -4:
 			rdr_log(reader, "card has no right to decode this channel");
 			break;
+
+		case -8:
+			rdr_log(reader, "CWPK is faulty");
+			break;
 	}
 
 	/* answer 9011 - conax smart card need reset */
diff --git a/reader-nagra-common.c b/reader-nagra-common.c
index eaf40c88..c4c52bb6 100644
--- a/reader-nagra-common.c
+++ b/reader-nagra-common.c
@@ -2,83 +2,531 @@
 #include "reader-common.h"
 #include "reader-nagra-common.h"
 
-// returns 1 if shared emm matches SA, unique emm matches serial, or global or unknown
+int32_t get_prov_idx(struct s_reader *rdr, const uint8_t *provid)
+{
+	int prov;
+	for(prov = 0; prov < rdr->nprov; prov++) // search for provider index
+	{
+		if(!memcmp(provid, &rdr->prid[prov][2], 2))
+		{
+			return (prov);
+		}
+	}
+	return (-1);
+}
+
 int32_t nagra_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
 {
-	switch(ep->emm[0])
+	if(rdr->cak7type == 3 || rdr->autype == 1)
 	{
-		case 0x83:
-			memset(ep->hexserial, 0x00, 0x08);
-			ep->hexserial[0] = ep->emm[5];
-			ep->hexserial[1] = ep->emm[4];
-			ep->hexserial[2] = ep->emm[3];
-			if(ep->emm[7] == 0x10)
-			{
+		int i;
+
+		switch(ep->emm[0])
+		{
+			case 0x82:
+				ep->type = UNIQUE;
+				memset(ep->hexserial, 0, 8);
+				memcpy(ep->hexserial, ep->emm + 3, 6);
+
+				return (!memcmp(rdr->hexserial, ep->hexserial, 6));
+
+			case 0x84:
 				ep->type = SHARED;
-				return (!memcmp(rdr->sa[0], ep->hexserial, 0x03));
-			}
-			else
-			{
-				ep->hexserial[3] = ep->emm[6];
+				memset(ep->hexserial, 0, 8);
+				memcpy(ep->hexserial, ep->emm + 5, 3);
+				i = get_prov_idx(rdr, ep->emm + 3);
+
+				if(i == -1)
+				{
+					return 0;
+				}
+
+				return (!memcmp(rdr->sa[i], ep->hexserial, 3));
+
+			case 0x83:
+				ep->type = GLOBAL;
+				uint8_t filtr[] = {0x83, 0x00, 0x74};
+				return (!memcmp(ep->emm, filtr, 3));
+
+			case 0x90:
 				ep->type = UNIQUE;
-				return (!memcmp(rdr->hexserial + 2, ep->hexserial, 0x04));
-			}
+				if(rdr->cwpkcaid_length && rdr->nuid_length)
+				{
+					memset(ep->hexserial, 0x00, 0x08);
+					ep->hexserial[0] = ep->emm[5];
+					ep->hexserial[1] = ep->emm[4];
+					ep->hexserial[2] = ep->emm[3];
+					ep->hexserial[3] = ep->emm[6];
+					return (!memcmp(rdr->nuid, ep->hexserial, 4));
+				}
+				return 0;
+
+			default:
+				ep->type = UNKNOWN;
+				return 0;
+		}
+	}
+	else if(rdr->cak7type == 1)
+	{
+		int i;
+		switch(ep->emm[0])
+		{
+			case 0x82:
+				ep->type = GLOBAL;
+				if(rdr->emm82 == 1 && ep->emm[3] == 0x00 && ep->emm[4] == 0x00 && ep->emm[5] == 0x00)
+				{
+					return 1;
+				}
+				return 0;
+
+			case 0x83:
+				if(ep->emm[7] == 0x10)
+				{
+					ep->type = SHARED;
+
+					for(i = 0; i < rdr->nemm83s; i++)
+					{
+						if(!memcmp(rdr->emm83s[i] + 1, ep->emm + 3, 0x03))
+						{
+							return 1;
+						}
+					}
+				}
+				else
+				{
+					ep->type = UNIQUE;
+
+					for(i = 0; i < rdr->nemm83u; i++)
+					{
+						if(!memcmp(rdr->emm83u[i] + 1, ep->emm + 3, 0x04))
+						{
+							return 1;
+						}
+					}
+				}
+				return 0;
+
+			case 0x84:
+				ep->type = GLOBAL;
+
+				for(i = 0; i < rdr->nemm84; i++)
+				{
+					if(!memcmp(rdr->emm84[i] + 1, ep->emm + 3, 0x02))
+					{
+						return 1;
+					}
+				}
+				return 0;
+
+			case 0x87:
+				ep->type = SHARED;
+
+				for(i = 0; i < rdr->nemm87; i++)
+				{
+					if(!memcmp(rdr->emm87[i] + 1, ep->emm + 3, 0x04))
+					{
+						return 1;
+					}
+				}
+				return 0;
+
+			case 0x90:
+				ep->type = UNIQUE;
+				if(rdr->cwpkcaid_length && rdr->nuid_length)
+				{
+					memset(ep->hexserial, 0x00, 0x08);
+					ep->hexserial[0] = ep->emm[5];
+					ep->hexserial[1] = ep->emm[4];
+					ep->hexserial[2] = ep->emm[3];
+					ep->hexserial[3] = ep->emm[6];
+					return (!memcmp(rdr->nuid, ep->hexserial, 4));
+				}
+				return 0;
+
+			default:
+				ep->type = UNKNOWN;
+				return 0;
+		}
+	}
+	else if(rdr->autype == 2)
+	{
+		int i;
+		switch(ep->emm[0])
+		{
+			case 0x82:
+				ep->type = GLOBAL;
+				if(ep->emm[3] == 0x00 && ep->emm[4] == 0x00 && ep->emm[5] == 0x00)
+				{
+					return 1;
+				}
+				return 0;
+
+			case 0x83:
+				memset(ep->hexserial, 0x00, 0x08);
+				ep->hexserial[0] = ep->emm[5];
+				ep->hexserial[1] = ep->emm[4];
+				ep->hexserial[2] = ep->emm[3];
+				if(ep->emm[7] == 0x10)
+				{
+					ep->type = SHARED;
+
+					for(i = 0; i < rdr->nprov; i++)
+					{
+						if(!memcmp(rdr->sa[i], "\x00\x00\x00", 3))
+						{
+							continue;
+						}
+
+						if(!memcmp(rdr->sa[i], ep->hexserial, 0x03))
+						{
+							return 1;
+						}
+					}
+				}
+				else
+				{
+					ep->hexserial[3] = ep->emm[6];
+					ep->type = UNIQUE;
+
+					return (!memcmp(rdr->hexserial + 2, ep->hexserial, 0x04));
+				}
+				return 0;
+
+			case 0x84:
+				ep->type = GLOBAL;
+				return 1;
+
+			case 0x87:
+				memset(ep->hexserial, 0x00, 0x08);
+				ep->hexserial[0] = ep->emm[5];
+				ep->hexserial[1] = ep->emm[4];
+				ep->hexserial[2] = ep->emm[3];
+				ep->hexserial[3] = ep->emm[6];
+				ep->type = SHARED;
+
+				for(i = 0; i < rdr->nprov; i++)
+				{
+					if(!memcmp(rdr->sa[i], "\x00\x00\x00", 3))
+					{
+						continue;
+					}
+					if(!memcmp(rdr->sa[i], ep->hexserial, 0x04))
+					{
+						return 1;
+					}
+				}
+				return 0;
+
+			default:
+				ep->type = UNKNOWN;
+				return 0;
+		}
+	}
+	else
+	{
+		switch(ep->emm[0])
+		{
+			case 0x83:
+				memset(ep->hexserial, 0x00, 0x08);
+				ep->hexserial[0] = ep->emm[5];
+				ep->hexserial[1] = ep->emm[4];
+				ep->hexserial[2] = ep->emm[3];
+				if(ep->emm[7] == 0x10)
+				{
+					ep->type = SHARED;
+					return (!memcmp(rdr->sa[0], ep->hexserial, 0x03));
+				}
+				else
+				{
+					ep->hexserial[3] = ep->emm[6];
+					ep->type = UNIQUE;
+					return (!memcmp(rdr->hexserial + 2, ep->hexserial, 0x04));
+				}
 
-		case 0x82:
-			ep->type = GLOBAL;
-			return 1;
+			case 0x82:
+				ep->type = GLOBAL;
+				if(ep->emm[3] == 0x00 && ep->emm[4] == 0x00 && ep->emm[5] == 0x00)
+				{
+					return 1;
+				}
+				return 0;
 
-		default:
-			ep->type = UNKNOWN;
-			return 1;
+			default:
+				ep->type = UNKNOWN;
+				return 0;
+		}
 	}
 }
 
 int32_t nagra_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
+	if(rdr->cak7type == 3 || rdr->autype == 1)
+	{
+		if(*emm_filters == NULL)
+		{
+			const unsigned int max_filter_count = 2 + (2 * rdr->nprov);
+			if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{
+				return ERROR;
+			}
+
+			struct s_csystem_emm_filter *filters = *emm_filters;
+			*filter_count = 0;
+
+			int32_t idx = 0;
+
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0] = 0xFF;
+			memcpy(&filters[idx].filter[1], rdr->hexserial, 6);
+			memset(&filters[idx].mask[1], 0xFF, 6);
+			idx++;
+
+			int32_t prov;
+			for(prov = 0; prov < rdr->nprov; prov++)
+			{
+				if(!memcmp(rdr->sa[prov], "\x00\x00\x00", 3))
+				{
+					continue;
+				}
+
+				filters[idx].type = EMM_GLOBAL;
+				filters[idx].enabled = 1;
+				filters[idx].filter[0] = 0x83;
+				filters[idx].mask[0] = 0xFF;
+				memcpy(&filters[idx].filter[1], &rdr->prid[prov][2], 2);
+				memset(&filters[idx].mask[1], 0xFF, 2);
+				idx++;
+
+				filters[idx].type = EMM_SHARED;
+				filters[idx].enabled = 1;
+				filters[idx].filter[0] = 0x84;
+				filters[idx].mask[0] = 0xFF;
+				memcpy(&filters[idx].filter[1], &rdr->prid[prov][2], 2);
+				memset(&filters[idx].mask[1], 0xFF, 2);
+				memcpy(&filters[idx].filter[3], &rdr->sa[prov], 3);
+				memset(&filters[idx].mask[3], 0xFF, 3);
+				idx++;
+			}
+
+			if(rdr->cwpkcaid_length && rdr->nuid_length)
+			{
+				filters[idx].type = EMM_UNIQUE;
+				filters[idx].enabled = 1;
+				filters[idx].filter[0] = 0x90;
+				filters[idx].filter[1] = rdr->nuid[2];
+				filters[idx].filter[2] = rdr->nuid[1];
+				filters[idx].filter[3] = rdr->nuid[0];
+				filters[idx].filter[4] = rdr->nuid[3];
+				memset(&filters[idx].mask[0], 0xFF, 5);
+				idx++;
+			}
+
+			*filter_count = idx;
+		}
+
+		return OK;
+	}
+	else if(rdr->cak7type == 1)
+	{
+		if(*emm_filters == NULL)
+		{
+			const unsigned int max_filter_count = 2 + (4 * rdr->nprov);
+			if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{
+				return ERROR;
+			}
+
+			struct s_csystem_emm_filter *filters = *emm_filters;
+			*filter_count = 0;
+
+			int32_t idx = 0;
+
+			if(rdr->emm82 == 1)
+			{
+				filters[idx].type = EMM_GLOBAL;
+				filters[idx].enabled = 1;
+				filters[idx].filter[0] = 0x82;
+				filters[idx].mask[0] = 0xFF;
+				idx++;
+			}
+
+			int32_t i;
+			for(i = 0; i < rdr->nemm83u; i++)
+			{
+				filters[idx].type = EMM_UNIQUE;
+				filters[idx].enabled = 1;
+				memcpy(&filters[idx].filter[0], rdr->emm83u[i], 6);
+				memset(&filters[idx].mask[0], 0xFF, 6);
+				idx++;
+			}
+
+			for(i = 0; i < rdr->nemm83s; i++)
+			{
+				filters[idx].type = EMM_SHARED;
+				filters[idx].enabled = 1;
+				memcpy(&filters[idx].filter[0], rdr->emm83s[i], 6);
+				memset(&filters[idx].mask[0], 0xFF, 6);
+				idx++;
+			}
+
+			for(i = 0; i < rdr->nemm84; i++)
+			{
+				filters[idx].type = EMM_GLOBAL;
+				filters[idx].enabled = 1;
+				memcpy(&filters[idx].filter[0], rdr->emm84[i], 3);
+				memset(&filters[idx].mask[0], 0xFF, 3);
+				idx++;
+			}
+
+			for(i = 0; i < rdr->nemm87; i++)
+			{
+				filters[idx].type = EMM_SHARED;
+				filters[idx].enabled = 1;
+				memcpy(&filters[idx].filter[0], rdr->emm87[i], 6);
+				memset(&filters[idx].mask[0], 0xFF, 6);
+				idx++;
+			}
+
+			if(rdr->cwpkcaid_length && rdr->nuid_length)
+			{
+				filters[idx].type = EMM_UNIQUE;
+				filters[idx].enabled = 1;
+				filters[idx].filter[0] = 0x90;
+				filters[idx].filter[1] = rdr->nuid[2];
+				filters[idx].filter[2] = rdr->nuid[1];
+				filters[idx].filter[3] = rdr->nuid[0];
+				filters[idx].filter[4] = rdr->nuid[3];
+				memset(&filters[idx].mask[0], 0xFF, 5);
+				idx++;
+			}
+
+			*filter_count = idx;
+		}
+
+		return OK;
+	}
+	else if(rdr->autype == 2)
 	{
-		const unsigned int max_filter_count = 3;
-		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+		if(*emm_filters == NULL)
 		{
-			return ERROR;
+			const unsigned int max_filter_count = 3 + (2 * rdr->nprov);
+			if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{
+				return ERROR;
+			}
+
+			struct s_csystem_emm_filter *filters = *emm_filters;
+			*filter_count = 0;
+
+			int32_t idx = 0;
+
+			filters[idx].type = EMM_GLOBAL;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0] = 0xFF;
+			idx++;
+
+			filters[idx].type = EMM_GLOBAL;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x84;
+			filters[idx].mask[0] = 0xFF;
+			idx++;
+
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x83;
+			filters[idx].filter[1] = rdr->hexserial[4];
+			filters[idx].filter[2] = rdr->hexserial[3];
+			filters[idx].filter[3] = rdr->hexserial[2];
+			filters[idx].filter[4] = rdr->hexserial[5];
+			filters[idx].filter[5] = 0x00;
+			memset(&filters[idx].mask[0], 0xFF, 6);
+			idx++;
+
+			int i;
+			for(i = 0; i < rdr->nprov; i++)
+			{
+				if(!memcmp(rdr->sa[i], "\x00\x00\x00", 3))
+				{
+					continue;
+				}
+
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x83;
+			filters[idx].filter[1] = rdr->sa[i][2];
+			filters[idx].filter[2] = rdr->sa[i][1];
+			filters[idx].filter[3] = rdr->sa[i][0];
+			filters[idx].filter[4] = 0x00;
+			filters[idx].filter[5] = 0x10;
+			memset(&filters[idx].mask[0], 0xFF, 6);
+			idx++;
+
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x87;
+			filters[idx].filter[1] = rdr->sa[i][2];
+			filters[idx].filter[2] = rdr->sa[i][1];
+			filters[idx].filter[3] = rdr->sa[i][0];
+			filters[idx].filter[4] = rdr->sa[i][3];
+			filters[idx].filter[5] = 0x00;
+			memset(&filters[idx].mask[0], 0xFF, 6);
+			idx++;
+			}
+
+			*filter_count = idx;
 		}
 
-		struct s_csystem_emm_filter *filters = *emm_filters;
-		*filter_count = 0;
-
-		int32_t idx = 0;
-
-		filters[idx].type = EMM_UNIQUE;
-		filters[idx].enabled = 1;
-		filters[idx].filter[0] = 0x83;
-		filters[idx].filter[1] = rdr->hexserial[4];
-		filters[idx].filter[2] = rdr->hexserial[3];
-		filters[idx].filter[3] = rdr->hexserial[2];
-		filters[idx].filter[4] = rdr->hexserial[5];
-		filters[idx].filter[5] = 0x00;
-		memset(&filters[idx].mask[0], 0xFF, 6);
-		idx++;
-
-		filters[idx].type = EMM_SHARED;
-		filters[idx].enabled = 1;
-		filters[idx].filter[0] = 0x83;
-		filters[idx].filter[1] = rdr->sa[0][2];
-		filters[idx].filter[2] = rdr->sa[0][1];
-		filters[idx].filter[3] = rdr->sa[0][0];
-		filters[idx].filter[4] = 0x00;
-		filters[idx].filter[5] = 0x10;
-		memset(&filters[idx].mask[0], 0xFF, 6);
-		idx++;
-
-		filters[idx].type = EMM_GLOBAL;
-		filters[idx].enabled = 1;
-		filters[idx].filter[0] = 0x82;
-		filters[idx].mask[0] = 0xFF;
-		idx++;
-
-		*filter_count = idx;
+		return OK;
 	}
+	else
+	{
+		if(*emm_filters == NULL)
+		{
+			const unsigned int max_filter_count = 3;
+			if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{
+				return ERROR;
+			}
 
-	return OK;
+			struct s_csystem_emm_filter *filters = *emm_filters;
+			*filter_count = 0;
+
+			int32_t idx = 0;
+
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x83;
+			filters[idx].filter[1] = rdr->hexserial[4];
+			filters[idx].filter[2] = rdr->hexserial[3];
+			filters[idx].filter[3] = rdr->hexserial[2];
+			filters[idx].filter[4] = rdr->hexserial[5];
+			filters[idx].filter[5] = 0x00;
+			memset(&filters[idx].mask[0], 0xFF, 6);
+			idx++;
+
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x83;
+			filters[idx].filter[1] = rdr->sa[0][2];
+			filters[idx].filter[2] = rdr->sa[0][1];
+			filters[idx].filter[3] = rdr->sa[0][0];
+			filters[idx].filter[4] = 0x00;
+			filters[idx].filter[5] = 0x10;
+			memset(&filters[idx].mask[0], 0xFF, 6);
+			idx++;
+
+			filters[idx].type = EMM_GLOBAL;
+			filters[idx].enabled = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0] = 0xFF;
+			idx++;
+
+			*filter_count = idx;
+		}
+
+		return OK;
+	}
 }
diff --git a/reader-nagra.c b/reader-nagra.c
index 141206d3..584b58b6 100644
--- a/reader-nagra.c
+++ b/reader-nagra.c
@@ -2,7 +2,6 @@
 #ifdef READER_NAGRA
 #include "cscrypt/bn.h"
 #include "cscrypt/idea.h"
-#include "cscrypt/des.h"
 #include "oscam-time.h"
 #include "reader-common.h"
 #include "reader-nagra-common.h"
@@ -25,7 +24,6 @@ struct nagra_data
 	uint8_t IdeaCamKey[16];
 	uint8_t sessi[16];
 	uint8_t signature[8];
-	uint8_t ird_info;
 	uint8_t cam_state[3];
 };
 
@@ -33,8 +31,6 @@ struct nagra_data
 #define HAS_CW()      ((csystem_data->cam_state[2]&6)==6)
 #define RENEW_SESSIONKEY() ((csystem_data->cam_state[0]&128)==128 || (csystem_data->cam_state[0]&64)==64 || (csystem_data->cam_state[0]&32)==32 || (csystem_data->cam_state[2]&8)==8)
 #define SENDDATETIME() (csystem_data->cam_state[0]&8)
-// IRD Info
-#define CW_NEEDS_3DES()	((csystem_data->ird_info&0x18)==0x18)
 // Datatypes
 #define DT01    0x01
 #define IRDINFO 0x00
@@ -201,8 +197,6 @@ static int32_t CamStateRequest(struct s_reader *reader)
 
 	if(do_cmd(reader, 0xC0, 0x02, 0xB0, 0x06, NULL, cta_res, &cta_lr))
 	{
-		csystem_data->ird_info = cta_res[2];
-		rdr_log_dbg(reader, D_READER, "Irdinfo: %02X", csystem_data->ird_info);
 		memcpy(csystem_data->cam_state, cta_res + 3, 3);
 		rdr_log_dbg(reader, D_READER, "Camstate: %s", cs_hexdump(1, csystem_data->cam_state, 3, tmp_dbg, sizeof(tmp_dbg)));
 	}
@@ -380,16 +374,6 @@ static int32_t NegotiateSessionKey(struct s_reader *reader)
 		0x01, 0x02, 0x03, 0x04, //IRD nr
 		0x00 };//keynr
 
-	uint8_t cmd2a[] = {
-		0x00,
-		0xA5, 0xFB, 0x02, 0x76,	//NUID
-		0x00, 0x08,		//OTP-CSC
-		0x00, 0x00,		//OTA-CSC
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00,
-		0x22, 0x11 }; //Provider ID
-
 	uint8_t tmp[64];
 	uint8_t idea1[16];
 	uint8_t idea2[16];
@@ -425,28 +409,10 @@ static int32_t NegotiateSessionKey(struct s_reader *reader)
 
 	if(!csystem_data->is_n3_na)
 	{
-		if (reader->nuid_length == 4) //nuid is set
+		if(!do_cmd(reader, 0x2a, 0x02, 0xaa, 0x42, NULL, cta_res, &cta_lr))
 		{
-			// inject provid
-			cmd2a[26] = reader->prid[0][2];
-			cmd2a[27] = reader->prid[0][3];
-
-			memcpy(&cmd2a[1], reader->nuid, 4); // inject NUID
-
-			if (!do_cmd(reader, 0x2a,0x1E,0xAA,0x42, cmd2a, cta_res, &cta_lr))
-			{
-				rdr_log_dbg(reader, D_READER, "CMD$2A failed");
-				return ERROR;
-			}
-		}
-		else
-		{
-			if(!do_cmd(reader, 0x2a, 0x02, 0xaa, 0x42, NULL, cta_res, &cta_lr))
-			{
-				rdr_log_dbg(reader, D_READER, "CMD$2A failed");
-				return ERROR;
-			}
-
+			rdr_log_dbg(reader, D_READER, "CMD$2A failed");
+			return ERROR;
 		}
 	}
 	else if(!do_cmd(reader, 0x26, 0x07, 0xa6, 0x42, tmp, cta_res, &cta_lr))
@@ -659,7 +625,7 @@ static void addProvider(struct s_reader *reader, uint8_t *cta_res)
 static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_res, uint16_t cta_lr)
 {
 	struct nagra_data *csystem_data = reader->csystem_data;
-	char ds[36], de[36];
+	char ds[20], de[16];
 	uint16_t chid;
 
 	switch(dt)
@@ -828,7 +794,7 @@ static int32_t nagra2_card_init(struct s_reader *reader, ATR *newatr)
 		}
 		memcpy(reader->rom, cta_res + 2, 15);
 	}
-	else if(reader->detect_seca_nagra_tunneled_card && memcmp(atr + 7, "pp", 2) == 0 && ((atr[9]&0x0F) >= 10))
+	else if(!reader->cak7_mode && reader->detect_seca_nagra_tunneled_card && memcmp(atr + 7, "pp", 2) == 0 && ((atr[9]&0x0F) >= 10))
 	{
 		rdr_log(reader, "detect seca/nagra tunneled card");
 
@@ -1370,83 +1336,18 @@ static int32_t nagra2_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, str
 		{
 			uint8_t v[8];
 			memset(v, 0, sizeof(v));
-			uint8_t _cwe0[8];
-			uint8_t _cwe1[8];
-			char tmp_dbg[25];
+			idea_cbc_encrypt(&cta_res[30], ea->cw, 8, &csystem_data->ksSession, v, IDEA_DECRYPT);
+			memset(v, 0, sizeof(v));
+			idea_cbc_encrypt(&cta_res[4], ea->cw + 8, 8, &csystem_data->ksSession, v, IDEA_DECRYPT);
 
 			if(csystem_data->swapCW == 1)
 			{
 				rdr_log_dbg(reader, D_READER, "swap cws");
-				idea_cbc_encrypt(&cta_res[30], &_cwe1[0], 8, &csystem_data->ksSession, v, IDEA_DECRYPT);
-				memset(v, 0, sizeof(v));
-				idea_cbc_encrypt(&cta_res[4], &_cwe0[0], 8, &csystem_data->ksSession, v, IDEA_DECRYPT);
-			}
-			else
-			{
-				idea_cbc_encrypt(&cta_res[30], &_cwe0[0], 8, &csystem_data->ksSession, v, IDEA_DECRYPT);
-				memset(v, 0, sizeof(v));
-				idea_cbc_encrypt(&cta_res[4], &_cwe1[0], 8, &csystem_data->ksSession, v, IDEA_DECRYPT);
-			}
-			rdr_log_dbg(reader, D_READER, "CW0 after IDEA decrypt: %s", cs_hexdump(1, _cwe0, 8, tmp_dbg, sizeof(tmp_dbg)));
-			rdr_log_dbg(reader, D_READER, "CW1 after IDEA decrypt: %s", cs_hexdump(1, _cwe1, 8, tmp_dbg, sizeof(tmp_dbg)));
-
-			if(CW_NEEDS_3DES())
-			{
-				rdr_log_dbg(reader, D_READER, "3DES encryption of CWs detected. Using CWPK index:%02X", (csystem_data->ird_info & 7));
-
-				if(reader->cwekey_length != 16)
-				{
-					rdr_log_dbg(reader, D_READER, "ERROR: Invalid CWPK, can not decrypt CW");
-					return ERROR;
-				}
-
-				des_ecb3_decrypt(_cwe0, reader->cwekey);
-				des_ecb3_decrypt(_cwe1, reader->cwekey);
-				rdr_log_dbg(reader, D_READER, "CW0 after 3DES decrypt: %s", cs_hexdump(1, _cwe0, 8, tmp_dbg, sizeof(tmp_dbg)));
-				rdr_log_dbg(reader, D_READER, "CW1 after 3DES decrypt: %s", cs_hexdump(1, _cwe1, 8, tmp_dbg, sizeof(tmp_dbg)));
-
-				if (!cfg.disablecrccws && !reader->disablecrccws && !chk_if_ignore_checksum((ECM_REQUEST*) er, &cfg.disablecrccws_only_for) && !chk_if_ignore_checksum((ECM_REQUEST*) er, &reader->disablecrccws_only_for))
-				{
-					int chkok = 1;
-					if(((_cwe0[0] + _cwe0[1] + _cwe0[2]) & 0xFF) != _cwe0[3])
-					{
-						chkok = 0;
-						rdr_log_dbg(reader, D_READER, "CW0 checksum error [0]");
-					}
-
-					if(((_cwe0[4] + _cwe0[5] + _cwe0[6]) & 0xFF) != _cwe0[7])
-					{
-						chkok = 0;
-						rdr_log_dbg(reader, D_READER, "CW0 checksum error [1]");
-					}
-
-					if(((_cwe1[0] + _cwe1[1] + _cwe1[2]) & 0xFF) != _cwe1[3])
-					{
-						chkok = 0;
-						rdr_log_dbg(reader, D_READER, "CW1 checksum error [0]");
-					}
-
-					if(((_cwe1[4] + _cwe1[5] + _cwe1[6]) & 0xFF) != _cwe1[7])
-					{
-						chkok = 0;
-						rdr_log_dbg(reader, D_READER, "CW1 checksum error [1]");
-					}
-
-					if(chkok == 0)
-					{
-						rdr_log_dbg(reader, D_READER, "CW Decrypt failed");
-						return ERROR;
-					}
-				}
-				else
-				{
-					rdr_log_dbg(reader, D_READER, "checksum test skipped");
-				}
+				uint8_t tt[8];
+				memcpy(&tt[0], &ea->cw[0], 8);
+				memcpy(&ea->cw[0], &ea->cw[8], 8);
+				memcpy(&ea->cw[8], &tt[0], 8);
 			}
-
-			memcpy(ea->cw, _cwe0, 0x08);
-			memcpy(ea->cw + 8, _cwe1, 0x08);
-
 			return OK;
 		}
 	}
diff --git a/reader-nagracak7.c b/reader-nagracak7.c
index 6fc06ad0..4f30aba2 100644
--- a/reader-nagracak7.c
+++ b/reader-nagracak7.c
@@ -1,24 +1,23 @@
 #include "globals.h"
 #ifdef READER_NAGRA_MERLIN
+#include "math.h"
 #include "cscrypt/bn.h"
 #include "cscrypt/idea.h"
 #include "csctapi/icc_async.h"
 #include "oscam-time.h"
 #include "reader-common.h"
 #include "reader-nagra-common.h"
-#include "reader-nagracak7.h"
 #include "oscam-work.h"
 #include "cscrypt/des.h"
 #include "cscrypt/mdc2.h"
 
+static const uint8_t public_exponent[] = { 0x01, 0x00, 0x01 };
 static const uint8_t d00ff[] = { 0x00, 0xFF, 0xFF, 0xFF };
-static uint8_t data1[] = { 0x00, 0x00, 0x00, 0x01 };
 
 // Datatypes
-#define SYSID_CAID 			0x02
-#define IRDINFO 			0x03
-#define DT05				0x05
-#define TIERS				0x0C
+#define IRDINFO 0x03
+#define TIERS   0x0C
+#define SYSID   0x05
 
 static time_t tier_date(uint64_t date, char *buf, int32_t l)
 {
@@ -33,7 +32,7 @@ static time_t tier_date(uint64_t date, char *buf, int32_t l)
 	return ut;
 }
 
-void rsa_decrypt(uint8_t *edata50, int len, uint8_t *out, uint8_t *key, int keylen, uint8_t *expo, uint8_t expolen)
+static void rsa_decrypt(uint8_t *edata50, int len, uint8_t *out, uint8_t *key, int keylen)
 {
 	BN_CTX *ctx0 = BN_CTX_new();
 #ifdef WITH_LIBCRYPTO
@@ -44,7 +43,7 @@ void rsa_decrypt(uint8_t *edata50, int len, uint8_t *out, uint8_t *key, int keyl
 	BIGNUM *bnCT0 = BN_CTX_get(ctx0);
 	BIGNUM *bnPT0 = BN_CTX_get(ctx0);
 	BN_bin2bn(&key[0], keylen, bnN0);
-	BN_bin2bn(&expo[0], expolen, bnE0);
+	BN_bin2bn(public_exponent, 0x03, bnE0);
 	BN_bin2bn(&edata50[0], len, bnCT0);
 	BN_mod_exp(bnPT0, bnCT0, bnE0, bnN0, ctx0);
 	memset(out,0x00,len);
@@ -55,12 +54,12 @@ void rsa_decrypt(uint8_t *edata50, int len, uint8_t *out, uint8_t *key, int keyl
 
 static void addProvider(struct s_reader *reader, uint8_t *cta_res)
 {
-	uint8_t i;
+	int i;
 	bool toadd = true;
 
 	for(i = 0; i < reader->nprov; i++)
 	{
-		if((cta_res[19] == reader->prid[i][2]) && (cta_res[20] == reader->prid[i][3]))
+		if((cta_res[0] == reader->prid[i][2]) && (cta_res[1] == reader->prid[i][3]))
 		{
 			toadd = false;
 		}
@@ -70,20 +69,202 @@ static void addProvider(struct s_reader *reader, uint8_t *cta_res)
 	{
 		reader->prid[reader->nprov][0] = 0;
 		reader->prid[reader->nprov][1] = 0;
-		reader->prid[reader->nprov][2] = cta_res[19];
-		reader->prid[reader->nprov][3] = cta_res[20];
-		memcpy(reader->sa[reader->nprov], reader->sa[0], 0x04);
+		reader->prid[reader->nprov][2] = cta_res[0];
+		reader->prid[reader->nprov][3] = cta_res[1];
+
 		reader->nprov += 1;
 	}
 }
 
+static int32_t get_prov_index(struct s_reader *reader, const uint8_t *provid)
+{
+	int prov;
+	for(prov = 0; prov < reader->nprov; prov++)
+	{
+		if(!memcmp(provid, &reader->prid[prov][2], 2))
+		{
+			return (prov);
+		}
+	}
+	return (-1);
+}
+
+static void addSA(struct s_reader *reader, uint8_t *cta_res)
+{
+	if((cta_res[0] == 0x83 && cta_res[5] == 0x10) || cta_res[0] == 0x87)
+	{
+		int i;
+		bool toadd = true;
+
+		if(reader->evensa)
+		{
+			unsigned long sax = (cta_res[3] << 16) + (cta_res[2] << 8) + (cta_res[1]);
+			if(sax % 2 != 0)
+			{
+				sax--;
+				cta_res[3]=(sax>>16)&0xFF;
+				cta_res[2]=(sax>>8)&0xFF;
+				cta_res[1]=(sax)&0xFF;
+			}
+		}
+
+		for(i = 0; i < reader->nsa; i++)
+		{
+			if((cta_res[1] == reader->sa[i][2]) && (cta_res[2] == reader->sa[i][1]) && (cta_res[3] == reader->sa[i][0]) && (cta_res[4] == reader->sa[i][3]))
+			{
+				toadd = false;
+			}
+		}
+
+		if(toadd && (memcmp(cta_res + 1, "\x00\x00\x00", 3)))
+		{
+			reader->sa[reader->nsa][0] = cta_res[3];
+			reader->sa[reader->nsa][1] = cta_res[2];
+			reader->sa[reader->nsa][2] = cta_res[1];
+			reader->sa[reader->nsa][3] = cta_res[4];
+
+			reader->nsa += 1;
+		}
+	}
+}
+
+static void addSAseca(struct s_reader *reader, uint8_t *cta_res)
+{
+	if(cta_res[0] == 0x84)
+	{
+		addProvider(reader, cta_res + 1);
+
+		if(memcmp(cta_res + 3, "\x00\x00\x00", 3))
+		{
+			int i;
+			i = get_prov_index(reader, cta_res + 1);
+
+			memcpy(reader->sa[i], cta_res + 3, 3);
+		}
+	}
+}
+
+static void addemmfilter(struct s_reader *reader, uint8_t *cta_res)
+{
+	if(cta_res[0] == 0x82)
+	{
+		reader->emm82 = 1;
+	}
+	else if(cta_res[0] == 0x84)
+	{
+		int i;
+		bool toadd = true;
+
+		for(i = 0; i < reader->nemm84; i++)
+		{
+			if(!memcmp(cta_res, reader->emm84[i], 3))
+			{
+				toadd = false;
+			}
+		}
+
+		if(toadd && (memcmp(cta_res + 1, "\x00\x00", 2)))
+		{
+			reader->emm84[reader->nemm84][0] = cta_res[0];
+			reader->emm84[reader->nemm84][1] = cta_res[1];
+			reader->emm84[reader->nemm84][2] = cta_res[2];
+
+			reader->nemm84 += 1;
+		}
+	}
+	else if(cta_res[0] == 0x83 && cta_res[5] == 0x00)
+	{
+		int i;
+		bool toadd = true;
+
+		for(i = 0; i < reader->nemm83u; i++)
+		{
+			if(!memcmp(cta_res, reader->emm83u[i], 6))
+			{
+				toadd = false;
+			}
+		}
+
+		if(toadd && (memcmp(cta_res + 1, "\x00\x00\x00\x00", 4)))
+		{
+			memcpy(reader->emm83u[reader->nemm83u], cta_res, 6);
+
+			reader->nemm83u += 1;
+		}
+	}
+	else if(cta_res[0] == 0x83 && cta_res[5] == 0x10)
+	{
+		int i;
+		bool toadd = true;
+
+		if(reader->evensa)
+		{
+			unsigned long sax = (cta_res[3] << 16) + (cta_res[2] << 8) + (cta_res[1]);
+			if(sax % 2 != 0)
+			{
+				sax--;
+				cta_res[3]=(sax>>16)&0xFF;
+				cta_res[2]=(sax>>8)&0xFF;
+				cta_res[1]=(sax)&0xFF;
+			}
+		}
+
+		for(i = 0; i < reader->nemm83s; i++)
+		{
+			if(!memcmp(cta_res, reader->emm83s[i], 6))
+			{
+				toadd = false;
+			}
+		}
+
+		if(toadd && (memcmp(cta_res + 1, "\x00\x00\x00", 3)))
+		{
+			memcpy(reader->emm83s[reader->nemm83s], cta_res, 6);
+
+			reader->nemm83s += 1;
+		}
+	}
+	else if(cta_res[0] == 0x87)
+	{
+		int i;
+		bool toadd = true;
+
+		if(reader->evensa)
+		{
+			unsigned long sax = (cta_res[3] << 16) + (cta_res[2] << 8) + (cta_res[1]);
+			if(sax % 2 != 0)
+			{
+				sax--;
+				cta_res[3]=(sax>>16)&0xFF;
+				cta_res[2]=(sax>>8)&0xFF;
+				cta_res[1]=(sax)&0xFF;
+			}
+		}
+
+		for(i = 0; i < reader->nemm87; i++)
+		{
+			if(!memcmp(cta_res, reader->emm87[i], 6))
+			{
+				toadd = false;
+			}
+		}
+
+		if(toadd && (memcmp(cta_res + 1, "\x00\x00\x00", 3)))
+		{
+			memcpy(reader->emm87[reader->nemm87], cta_res, 6);
+
+			reader->nemm87 += 1;
+		}
+	}
+}
+
 static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_res, uint16_t cta_lr)
 {
-	char ds[36], de[36];
+	char ds[11], de[11];
 
 	switch(dt)
 	{
-		case SYSID_CAID:
+		case 0x02:
 		{
 			reader->prid[0][0] = 0x00;
 			reader->prid[0][1] = 0x00;
@@ -94,7 +275,7 @@ static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_r
 			reader->prid[1][1] = 0x00;
 			reader->prid[1][2] = 0x00;
 			reader->prid[1][3] = 0x00;
-			memcpy(reader->sa[1], reader->sa[0], 0x04);
+
 			reader->nprov += 1;
 			reader->caid = (SYSTEM_NAGRA | cta_res[25]);
 			rdr_log_dbg(reader, D_READER, "CAID : %04X", reader->caid);
@@ -107,33 +288,109 @@ static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_r
 			{
 				uint32_t timestamp = b2i(0x04, cta_res + 22);
 				reader->card_valid_to = tier_date(timestamp, de, 11);
-				rdr_log(reader, "Provider Sys ID: %02X %02X is active to: %s", cta_res[19], cta_res[20], de);
+			}
+			if(reader->protocol_type == ATR_PROTOCOL_TYPE_T0)
+			{
+				uint16_t chid = 0;
+				uint32_t id = b2i(0x02, cta_res + 19);
+				uint32_t start_date;
+				uint32_t expire_date;
+
+				start_date = 1;
+				expire_date = b2i(0x04, cta_res + 22);
+
+				cs_add_entitlement(reader,
+				reader->caid,
+				id,
+				chid,
+				0,
+				tier_date(start_date, ds, 11),
+				tier_date(expire_date, de, 11),
+				4,
+				1);
+				rdr_log(reader, "|%04X|%04X    |%s  |%s  |", id, chid, ds, de);
+				addProvider(reader, cta_res + 19);
+			}
+			return OK;
+		}
+
+		case 0x04:
+		{
+			if(cta_res[18] != 0x80)
+			{
+				addProvider(reader, cta_res + 19);
+
+				uint8_t check[] = {0x00, 0x01};
+				check[0] = reader->caid & 0xFF;
+				int p;
+
+				for(p=23; p < (cta_lr - 6); p++)
+				{
+					if(!memcmp(cta_res + p, check, 2))
+					{
+						addProvider(reader, cta_res + p + 2);
+
+						if(reader->cak7type == 3)
+						{
+							addSAseca(reader, cta_res + p + 5);
+						}
+						else
+						{
+							addSA(reader, cta_res + p + 5);
+							addemmfilter(reader, cta_res + p + 5);
+						}
+					}
+				}
 			}
 			return OK;
 		}
 
-		case DT05: // case 0x05
+		case SYSID: // case 0x05
 		{
-			IDEA_KEY_SCHEDULE ks;
 			memcpy(reader->edata,cta_res + 26, 0x70);
 			reader->dt5num = cta_res[20];
-			rsa_decrypt(reader->edata, 0x70, reader->out, reader->mod1, reader->mod1_length, reader->public_exponent, reader->public_exponent_length);
+			char tmp[8];
+			rdr_log(reader, "Card has DT05_%s", cs_hexdump(1, &reader->dt5num, 1, tmp, sizeof(tmp)));
 
 			if(reader->dt5num == 0x00)
 			{
+				IDEA_KEY_SCHEDULE ks;
+				rsa_decrypt(reader->edata, 0x70, reader->out, reader->mod1, reader->mod1_length);
 				memcpy(reader->kdt05_00,&reader->out[18], 0x5C + 2);
 				memcpy(&reader->kdt05_00[0x5C + 2], cta_res + 26 + 0x70, 6);
 				memcpy(reader->ideakey1, reader->out, 16);
+				rdr_log_dump_dbg(reader, D_READER, reader->ideakey1, 16, "IDEAKEY1: ");
 				memcpy(reader->block3, cta_res + 26 + 0x70 + 6, 8);
 				idea_set_encrypt_key(reader->ideakey1, &ks);
 				memset(reader->v, 0, sizeof(reader->v));
 				idea_cbc_encrypt(reader->block3, reader->iout, 8, &ks, reader->v, IDEA_DECRYPT);
 				memcpy(&reader->kdt05_00[0x5C + 2 + 6],reader->iout, 8);
+				uint8_t mdc_hash1[MDC2_DIGEST_LENGTH];
+				memset(mdc_hash1,0x00,MDC2_DIGEST_LENGTH);
+				uint8_t check1[0x7E];
+				memset(check1, 0x00, 0x7E);
+				memcpy(check1 + 18, reader->kdt05_00, 0x6C);
+				MDC2_CTX c1;
+				MDC2_Init(&c1);
+				MDC2_Update(&c1, check1, 0x7E);
+				MDC2_Final(&(mdc_hash1[0]), &c1);
+
+				rdr_log_dump_dbg(reader, D_READER, mdc_hash1, 16, "MDC_HASH: ");
+				if(memcmp(mdc_hash1 + 1, reader->ideakey1 + 1, 14) == 0)
+				{
+				rdr_log(reader, "DT05_00 is correct");
+				}
+				else
+				{
+				rdr_log(reader, "DT05_00 error - check MOD1");
+				}
 				rdr_log_dump_dbg(reader, D_READER, reader->kdt05_00, sizeof(reader->kdt05_00), "DT05_00: ");
 			}
 
 			if(reader->dt5num == 0x10)
 			{
+				IDEA_KEY_SCHEDULE ks;
+				rsa_decrypt(reader->edata, 0x70, reader->out, reader->mod1, reader->mod1_length);
 				memcpy(reader->kdt05_10, &reader->out[16], 6 * 16);
 				memcpy(reader->ideakey1, reader->out, 16);
 				memcpy(reader->block3, cta_res + 26 + 0x70, 8);
@@ -143,6 +400,14 @@ static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_r
 				memcpy(&reader->kdt05_10[6 * 16],reader->iout,8);
 				rdr_log_dump_dbg(reader, D_READER, reader->kdt05_10, sizeof(reader->kdt05_10), "DT05_10: ");
 			}
+
+			if(reader->dt5num == 0x20)
+			{
+				rsa_decrypt(reader->edata, 0x70, reader->out, reader->mod2, reader->mod2_length);
+				memcpy(reader->tmprsa, reader->out, 0x70);
+				reader->hasunique = 1;
+			}
+
 			return OK;
 		}
 
@@ -159,6 +424,13 @@ static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_r
 
 				switch(reader->caid)
 				{
+					case 0x1843: // HD02
+						start_date = b2i(0x04, cta_res + 42);
+						expire_date1 = b2i(0x04, cta_res + 28);
+						expire_date2 = b2i(0x04, cta_res + 46);
+						expire_date = expire_date1 <= expire_date2 ? expire_date1 : expire_date2;
+						break;
+
 					case 0x1860: // HD03
 						start_date = b2i(0x04, cta_res + 42);
 						expire_date1 = b2i(0x04, cta_res + 28);
@@ -173,9 +445,14 @@ static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_r
 						expire_date = expire_date1 <= expire_date2 ? expire_date1 : expire_date2;
 						break;
 
+					case 0x1861: // Polsat
+						start_date = 1;
+						expire_date = b2i(0x04, cta_res + 28);
+						break;
+
 					default: // unknown card
 						start_date = 1;
-						expire_date = 0x569EFB7F;
+						expire_date = 0xA69EFB7F;
 				}
 
 				cs_add_entitlement(reader,
@@ -188,7 +465,7 @@ static int32_t ParseDataType(struct s_reader *reader, uint8_t dt, uint8_t *cta_r
 					4,
 					1);
 				rdr_log(reader, "|%04X|%04X    |%s  |%s  |", id, chid, ds, de);
-				addProvider(reader, cta_res);
+				addProvider(reader, cta_res + 19);
 			}
 			return OK;
 		}
@@ -227,15 +504,19 @@ static int32_t CAK7GetDataType(struct s_reader *reader, uint8_t dt)
 	while(1)
 	{
 		CAK7do_cmd(reader, dt, 0x10, cta_res, &cta_lr, sub, retlen);
+		rdr_log_dump_dbg(reader, D_READER, cta_res, cta_lr, "Decrypted Answer:");
 		// hier eigentlich check auf 90 am ende usw... obs halt klarging ...
 
-		if((cta_lr == 0) || (cta_res[cta_lr-2] == 0x6F && cta_res[cta_lr-1] == 0x01))
+		if(cta_lr == 0)
+		{
+			break;
+		}
+		if(cta_res[cta_lr-2] == 0x6F && cta_res[cta_lr-1] == 0x01)
 		{
 			reader->card_status = CARD_NEED_INIT;
 			add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
 			break;
 		}
-
 		uint32_t newsub = (cta_res[9] << 16) + (cta_res[10] << 8) + (cta_res[11]);
 		if(newsub == 0xFFFFFF)
 		{
@@ -268,77 +549,357 @@ static int32_t CAK7GetDataType(struct s_reader *reader, uint8_t dt)
 	return OK;
 }
 
-void CAK7_getCamKey(struct s_reader *reader)
+static void sub_6AD78(uint32_t *dinit) // gbox function
 {
-	def_resp;
-	uint8_t cmd0e[] = {0xCC,0xCC,0xCC,0xCC,0x00,0x00,0x09,0x0E,0x83,0x00,0x00,0x00,0x00,0x00,0x64,0x65,0x6D,0x6F,0x34,0x11,0x9D,
-	0x7E,0xEE,0xCE,0x53,0x09,0x80,0xAE,0x6B,0x5A,0xEE,0x3A,0x41,0xCE,0x09,0x75,0xEF,0xA6,0xBF,0x1E,0x98,0x4F,
-	0xA4,0x11,0x6F,0x43,0xCA,0xCD,0xD0,0x6E,0x69,0xFA,0x25,0xC1,0xF9,0x11,0x8E,0x7A,0xD0,0x19,0xC0,0xEB,0x00,
-	0xC0,0x57,0x2A,0x40,0xB7,0xFF,0x8A,0xBB,0x25,0x21,0xD7,0x50,0xE7,0x35,0xA1,0x85,0xCD,0xA6,0xD3,0xDE,0xB3,
-	0x3D,0x16,0xD4,0x94,0x76,0x8A,0x82,0x8C,0x70,0x25,0xD4,0x00,0xD0,0x64,0x8C,0x26,0xB9,0x5F,0x44,0xFF,0x73,
-	0x70,0xAB,0x43,0xF5,0x68,0xA2,0xB1,0xB5,0x8A,0x8E,0x02,0x5F,0x96,0x06,0xA8,0xC3,0x4F,0x15,0xCD,0x99,0xC2,
-	0x69,0xB8,0x35,0x68,0x11,0x4C,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0xCC,0xCC,0xCC,0xCC};
+	uint32_t v0 = (uint32_t) * dinit;
+	double f0;
+	f0 = v0;
+	double f12 = 16807;
+	double f15 = 2147483647;
+	f12 = f0 * f12;
+	double v12;
+	v12 = fmod(f12, f15);
+	*dinit = v12;
+}
+
+static void calc_cak7_exponent(uint32_t *dinit, uint8_t *out, uint8_t len)
+{
+	memset(out, 0x00, len);
 
-	get_random_bytes(data1, 0x04);
-	if (data1[3] == 0xFF)
+	sub_6AD78(dinit);
+
+	int nR4 = 0;
+	int nR5 = 0;
+	while(true)
 	{
-		data1[3]--;
+		uint32_t nR0 = (uint32_t)* dinit;
+		int nR3 = nR4 + 3;
+		nR5 += 4;
+
+		if(nR3 > len)
+		{
+			break;
+		}
+
+		out[nR5 - 1] = ((nR0    ) & 0xFF);
+		out[nR5 - 2] = ((nR0 >> 8) & 0xFF);
+		out[nR5 - 3] = ((nR0 >> 16) & 0xFF);
+		out[nR5 - 4] = ((nR0 >> 24) & 0xFF);
+		nR4 += 4;
+		sub_6AD78(dinit);
+
 	}
-	memcpy(cmd0e + 9, data1, 0x04);
-	data1[3]++;
 
-	if (reader->irdid_length == 4)
+	uint32_t nR0 = (uint32_t)* dinit;
+	while(nR4 < len)
 	{
-		memcpy(&cmd0e[14], reader->irdid, reader->irdid_length); // inject irdid
+		out[nR4] = nR0 & 0xFF;
+		nR4++;
+		nR0 >>= 8;
 	}
 
-	// inject provid
-	cmd0e[18] = reader->prid[0][2];
-	cmd0e[19] = reader->prid[0][3];
+	out[0] &= 0x03;
+	out[0x10] |= 0x01;
+
+}
+
+static void IdeaDecrypt(unsigned char *data, int len, const unsigned char *key, unsigned char *iv)
+{
+unsigned char v[8];
+if(!iv) { memset(v,0,sizeof(v)); iv=v; }
+IDEA_KEY_SCHEDULE ks;
+idea_set_encrypt_key(key,&ks);
+idea_cbc_encrypt(data,data,len&~7,&ks,iv,IDEA_DECRYPT);
+}
 
-	if (reader->nuid_length == 4)
+static inline void xxxor(uint8_t *data, int32_t len, const uint8_t *v1, const uint8_t *v2)
+{
+	uint32_t i;
+	switch(len)
 	{
-		memcpy(&cmd0e[132], reader->nuid, reader->nuid_length); // inject NUID
+	case 16:
+		for(i = 0; i < 16; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	case 8:
+		for(i = 0; i < 8; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	case 4:
+		for(i = 0; i < 4; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	default:
+		while(len--)
+		{
+			*data++ = *v1++ ^ *v2++;
+		}
+		break;
 	}
+}
 
-	do_cak7_cmd(reader,cta_res, &cta_lr, cmd0e, sizeof(cmd0e), 0x20);
+static void CreateRSAPair60(struct s_reader *reader, const unsigned char *key)
+{
+unsigned char idata[96];
+int i;
+for(i=11; i>=0; i--) {
+unsigned char *d=&idata[i*8];
+memcpy(d,&key[13],8);
+*d^=i;
+IdeaDecrypt(d,8,key,0);
+xxxor(d,8,d,&key[13]);
+*d^=i;
+}
+BN_CTX *ctx5 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+BN_CTX_start(ctx5);
+#endif
+BIGNUM *p = BN_CTX_get(ctx5);
+BIGNUM *q = BN_CTX_get(ctx5);
+BIGNUM *m = BN_CTX_get(ctx5);
+BIGNUM *e = BN_CTX_get(ctx5);
+BIGNUM *a = BN_CTX_get(ctx5);
+BIGNUM *r = BN_CTX_get(ctx5);
+
+// Calculate P
+idata[0] |= 0x80;
+idata[47] |= 1;
+BN_bin2bn(idata,48,p);
+BN_add_word(p,(key[21] << 5 ) | ((key[22] & 0xf0) >> 3));
+// Calculate Q
+idata[48] |= 0x80;
+idata[95] |= 1;
+BN_bin2bn(idata+48,48,q);
+BN_add_word(q,((key[22]&0xf)<<9) | (key[23]<<1));
+
+// Calculate M=P*Q
+BN_mul(m,p,q,ctx5);
+memset(reader->key60,0x00,0x60);
+BN_bn2bin(m, reader->key60 + (0x60 - BN_num_bytes(m)));
+rdr_log_dump_dbg(reader, D_READER, reader->key60, sizeof(reader->key60), "key60: ");
+
+// Calculate D
+BN_sub_word(p,1);
+BN_sub_word(q,1);
+BN_mul(e,p,q,ctx5);
+BN_bin2bn(public_exponent,3,a);
+BN_mod_inverse(r, a, e, ctx5);
+memset(reader->exp60,0x00,0x60);
+BN_bn2bin(r, reader->exp60 + (0x60 - BN_num_bytes(r)));
+rdr_log_dump_dbg(reader, D_READER, reader->exp60, sizeof(reader->exp60), "exp60: ");
+
+BN_CTX_end(ctx5);
+BN_CTX_free(ctx5);
+}
 
-	reader->cak7_restart =  (cta_res[22] << 16);
-	reader->cak7_restart += (cta_res[23] <<  8);
-	reader->cak7_restart += (cta_res[24]      );
-	reader->cak7_restart--;
+static void CreateRSAPair68(struct s_reader *reader, const unsigned char *key)
+{
+unsigned char idata[104];
+int i;
+for(i=12; i>=0; i--) {
+unsigned char *d=&idata[i*8];
+memcpy(d,&key[13],8);
+*d^=i;
+IdeaDecrypt(d,8,key,0);
+xxxor(d,8,d,&key[13]);
+*d^=i;
+}
+BN_CTX *ctx6 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+BN_CTX_start(ctx6);
+#endif
+BIGNUM *p = BN_CTX_get(ctx6);
+BIGNUM *q = BN_CTX_get(ctx6);
+BIGNUM *m = BN_CTX_get(ctx6);
+BIGNUM *e = BN_CTX_get(ctx6);
+BIGNUM *a = BN_CTX_get(ctx6);
+BIGNUM *r = BN_CTX_get(ctx6);
+
+// Calculate P
+idata[0] |= 0x80;
+idata[51] |= 1;
+BN_bin2bn(idata,52,p);
+BN_add_word(p,(key[21] << 5 ) | ((key[22] & 0xf0) >> 3));
+// Calculate Q
+idata[52] |= 0x80;
+idata[103] |= 1;
+BN_bin2bn(idata+52,52,q);
+BN_add_word(q,((key[22]&0xf)<<9) | (key[23]<<1));
+
+// Calculate M=P*Q
+BN_mul(m,p,q,ctx6);
+memset(reader->key68,0x00,0x68);
+BN_bn2bin(m, reader->key68 + (0x68 - BN_num_bytes(m)));
+rdr_log_dump_dbg(reader, D_READER, reader->key68, sizeof(reader->key68), "key68: ");
+
+// Calculate D
+BN_sub_word(p,1);
+BN_sub_word(q,1);
+BN_mul(e,p,q,ctx6);
+BN_bin2bn(public_exponent,3,a);
+BN_mod_inverse(r, a, e, ctx6);
+memset(reader->exp68,0x00,0x68);
+BN_bn2bin(r, reader->exp68 + (0x68 - BN_num_bytes(r)));
+rdr_log_dump_dbg(reader, D_READER, reader->exp68, sizeof(reader->exp68), "exp68: ");
+
+BN_CTX_end(ctx6);
+BN_CTX_free(ctx6);
+}
 
-	memcpy(reader->cardid,cta_res + 14, 4);
-	rdr_log_dump_dbg(reader, D_READER, reader->cardid, 0x04, "CardSerial: ");
+static void dt05_20(struct s_reader *reader)
+{
+	uint8_t data_20_00[72];
+	uint8_t sig_20_00[16];
+	uint8_t data_20_id[72];
+	uint8_t data_20_x[64];
+	uint8_t data_20_fin[72];
+	uint8_t data_20_flag58[16];
 
-	memcpy(reader->hexserial + 2, reader->cardid, 4);
-	memcpy(reader->sa[0], reader->cardid, 3);
-	memcpy(reader->sa[1], reader->sa[0], 4);
+	rdr_log_dump_dbg(reader, D_READER, reader->tmprsa, sizeof(reader->tmprsa), "DT05_20 after RSA: ");
 
-	unsigned long datal = (cta_res[9] << 24) + (cta_res[10] << 16) + (cta_res[11] << 8) + (cta_res[12]);
-	datal++;
-	reader->data2[0] = (datal >> 24) & 0xFF;
-	reader->data2[1] = (datal >> 16) & 0xFF;
-	reader->data2[2] = (datal >>  8) & 0xFF;
-	reader->data2[3] = (datal      ) & 0xFF;
+	// copy signature
+	memcpy(sig_20_00, reader->tmprsa+24, 16);
 
-	rsa_decrypt(reader->data50, reader->data50_length, reader->data, reader->mod50, reader->mod50_length, reader->public_exponent, reader->public_exponent_length);
+	// copy data
+	memcpy(data_20_00, reader->tmprsa+40, 72);
 
-	memcpy(&reader->step1[0], d00ff, 4);
-	memcpy(&reader->step1[4], reader->data, 0x50);
-	memcpy(&reader->step1[4 + 0x50], reader->irdid, reader->irdid_length);
-	memcpy(&reader->step1[4 + 4 + 0x50], data1, 0x04);
-	memcpy(&reader->step1[4 + 4 + 4 + 0x50], reader->data2, 0x04);
-	rsa_decrypt(reader->step1, 0x60, reader->data, reader->key60, reader->key60_length, reader->exp60, reader->exp60_length);
+	// IDEA encrypt 0x48 data
+	int i;
+	int offs = 0;
+
+	for(i=0; i<9; i++)
+	{
+		IDEA_KEY_SCHEDULE ks;
+		idea_set_encrypt_key(reader->key3310, &ks);
+		idea_ecb_encrypt(data_20_00+offs, data_20_id+offs, &ks);
+		offs+=8;
+	}
+
+	// xor
+	for (i=0; i<64; i++)
+	{
+		data_20_x[i] = data_20_00[i] ^ data_20_id[i+8];
+	}
+
+	rdr_log_dump_dbg(reader, D_READER, data_20_x, sizeof(data_20_x), "data_20_x: ");
+
+	// create final data block
+	memcpy(data_20_fin,data_20_id,8);
+	memcpy(data_20_fin+8,data_20_x,64);
+
+	rdr_log_dump_dbg(reader, D_READER, data_20_fin, sizeof(data_20_fin), "data_20_fin: ");
+
+	uint8_t mdc_hash4[MDC2_DIGEST_LENGTH];
+	memset(mdc_hash4,0x00,MDC2_DIGEST_LENGTH);
+	uint8_t check4[112];
+	memset(check4, 0x00, 112);
+	memcpy(check4, reader->cardid, 4);
+	memcpy(check4 + 4, reader->idird, 4);
+	memcpy(check4 + 23, reader->tmprsa + 23, 1);
+	memcpy(check4 + 40, data_20_fin, 72);
+	MDC2_CTX c4;
+	MDC2_Init(&c4);
+	MDC2_Update(&c4, check4, 112);
+	MDC2_Final(&(mdc_hash4[0]), &c4);
+
+	if(memcmp(mdc_hash4, sig_20_00, 16) == 0)
+	{
+	rdr_log(reader, "DT05_20 is correct");
+	}
+	else
+	{
+	rdr_log(reader, "DT05_20 error - check MOD2");
+	}
+
+	// Store 3des software key Flag58 CW overencrypt
+	memcpy(data_20_flag58, data_20_x+16, 16);
+	memcpy(reader->key3des, data_20_flag58, 16);
+
+	rdr_log_dump_dbg(reader, D_READER, reader->key3des, sizeof(reader->key3des), "Flag58 3DES Key: ");
+
+	// create rsa pair from final data
+
+	memcpy(reader->klucz68, data_20_fin, 0x18);
+
+	rdr_log_dump_dbg(reader, D_READER, reader->klucz68, sizeof(reader->klucz68), "klucz68: ");
+}
+
+static int32_t CAK7_cmd03_global(struct s_reader *reader)
+{
+	def_resp;
+	if(reader->cak7_seq <= 15)
+	{
+		unsigned char klucz[24];
+		memset(klucz, 0x00, 24);
+		memcpy(klucz, reader->key3588, 24);
+		CreateRSAPair60(reader, klucz);
+	}
+
+	BN_CTX *ctx1 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx1);
+#endif
+	BIGNUM *bnN1 = BN_CTX_get(ctx1);
+	BIGNUM *bnE1 = BN_CTX_get(ctx1);
+	BIGNUM *bnCT1 = BN_CTX_get(ctx1);
+	BIGNUM *bnPT1 = BN_CTX_get(ctx1);
+	BN_bin2bn(&reader->key60[0], 0x60, bnN1);
+	BN_bin2bn(&reader->exp60[0], 0x60, bnE1);
+	BN_bin2bn(&reader->step1[0], 0x60, bnCT1);
+	BN_mod_exp(bnPT1, bnCT1, bnE1, bnN1, ctx1);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT1, reader->data + (0x60 - BN_num_bytes(bnPT1)));
+	BN_CTX_end(ctx1);
+	BN_CTX_free(ctx1);
 
 	memcpy(&reader->step2[0], d00ff, 4);
 	memcpy(&reader->step2[4], reader->cardid, 4);
 	memcpy(&reader->step2[8], reader->data, 0x60);
-	rsa_decrypt(reader->step2, 0x68, reader->data, reader->kdt05_10, 0x68, reader->public_exponent, reader->public_exponent_length);
+	rdr_log_dump_dbg(reader, D_READER, reader->step2, sizeof(reader->step2), "STEP 2:");
+
+	BN_CTX *ctx2 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx2);
+#endif
+	BIGNUM *bnN2 = BN_CTX_get(ctx2);
+	BIGNUM *bnE2 = BN_CTX_get(ctx2);
+	BIGNUM *bnCT2 = BN_CTX_get(ctx2);
+	BIGNUM *bnPT2 = BN_CTX_get(ctx2);
+	BN_bin2bn(&reader->kdt05_10[0], 0x68, bnN2);
+	BN_bin2bn(public_exponent, 3, bnE2);
+	BN_bin2bn(&reader->step2[0], 0x68, bnCT2);
+	BN_mod_exp(bnPT2, bnCT2, bnE2, bnN2, ctx2);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT2, reader->data + (0x68 - BN_num_bytes(bnPT2)));
+	BN_CTX_end(ctx2);
+	BN_CTX_free(ctx2);
 
 	memcpy(&reader->step3[0], d00ff, 4);
 	memcpy(&reader->step3[4], reader->data, 0x68);
-	rsa_decrypt(reader->step3, 0x6c, reader->data, reader->kdt05_00, 0x6c, reader->public_exponent, reader->public_exponent_length);
+	rdr_log_dump_dbg(reader, D_READER, reader->step3, sizeof(reader->step3), "STEP 3:");
+
+	BN_CTX *ctx3 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx3);
+#endif
+	BIGNUM *bnN3 = BN_CTX_get(ctx3);
+	BIGNUM *bnE3 = BN_CTX_get(ctx3);
+	BIGNUM *bnCT3 = BN_CTX_get(ctx3);
+	BIGNUM *bnPT3 = BN_CTX_get(ctx3);
+	BN_bin2bn(&reader->kdt05_00[0], 0x6c, bnN3);
+	BN_bin2bn(public_exponent, 3, bnE3);
+	BN_bin2bn(&reader->step3[0], 0x6c, bnCT3);
+	BN_mod_exp(bnPT3, bnCT3, bnE3, bnN3, ctx3);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT3, reader->data + (0x6c - BN_num_bytes(bnPT3)));
+	BN_CTX_end(ctx3);
+	BN_CTX_free(ctx3);
 
 	uint8_t cmd03[] = {0xCC,0xCC,0xCC,0xCC,0x00,0x00,0x0A,0x03,0x6C,
 	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
@@ -351,88 +912,557 @@ void CAK7_getCamKey(struct s_reader *reader)
 	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};
 
 	memcpy(&cmd03[9],reader->data,0x6c);
+
 	do_cak7_cmd(reader,cta_res,&cta_lr,cmd03,sizeof(cmd03),0x90);
 
+	if(cta_lr == 0)
+	{
+		rdr_log(reader, "card is not responding to CMD03 - check your data");
+		return ERROR;
+	}
+
+	rdr_log_dump_dbg(reader, D_READER, cta_res, 0x90, "CMD03 ANSWER:");
 	memcpy(reader->encrypted,&cta_res[10],0x68);
-	rsa_decrypt(reader->encrypted, 0x68, reader->result, reader->kdt05_10, 0x68, reader->public_exponent, reader->public_exponent_length);
 
+	BN_CTX *ctx = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx);
+#endif
+	BIGNUM *bnN = BN_CTX_get(ctx);
+	BIGNUM *bnE = BN_CTX_get(ctx);
+	BIGNUM *bnCT = BN_CTX_get(ctx);
+	BIGNUM *bnPT = BN_CTX_get(ctx);
+	BN_bin2bn(&reader->kdt05_10[0], 104, bnN);
+	BN_bin2bn(public_exponent, 3, bnE);
+	BN_bin2bn(&reader->encrypted[0], 104, bnCT);
+	BN_mod_exp(bnPT, bnCT, bnE, bnN, ctx);
+	memset(reader->result, 0, 104);
+	BN_bn2bin(bnPT, reader->result + (104 - BN_num_bytes(bnPT)));
+	BN_CTX_end(ctx);
+	BN_CTX_free(ctx);
+
+	//uint8_t stillencrypted[0x50];
 	memcpy(reader->stillencrypted,&reader->result[12],0x50);
-	rsa_decrypt(reader->stillencrypted, 0x50, reader->resultrsa, reader->mod50, reader->mod50_length, reader->public_exponent, reader->public_exponent_length);
 
-	uint8_t mdc_hash[MDC2_DIGEST_LENGTH];
-	memset(mdc_hash,0x00,MDC2_DIGEST_LENGTH);
-	MDC2_CTX c;
-	MDC2_Init(&c);
-	MDC2_Update(&c, reader->resultrsa, sizeof(reader->resultrsa));
-	MDC2_Final(&(mdc_hash[0]), &c);
+	//uint8_t resultrsa[0x50];
+	BN_CTX *ctxs = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctxs);
+#endif
+	BIGNUM *bnNs  = BN_CTX_get(ctxs);
+	BIGNUM *bnEs  = BN_CTX_get(ctxs);
+	BIGNUM *bnCTs = BN_CTX_get(ctxs);
+	BIGNUM *bnPTs = BN_CTX_get(ctxs);
+	BN_bin2bn(&reader->mod50[0], reader->mod50_length, bnNs);
+	BN_bin2bn(&reader->cak7expo[0], 0x11, bnEs);
+	BN_bin2bn(&reader->stillencrypted[0], 0x50, bnCTs);
+	BN_mod_exp(bnPTs, bnCTs, bnEs, bnNs, ctxs);
+	memset(reader->resultrsa, 0x00, 0x50);
+	BN_bn2bin(bnPTs, reader->resultrsa + (0x50 - BN_num_bytes(bnPTs)));
+	BN_CTX_end(ctxs);
+	BN_CTX_free(ctxs);
+
+	uint8_t mdc_hash3[MDC2_DIGEST_LENGTH];
+	memset(mdc_hash3,0x00,MDC2_DIGEST_LENGTH);
+	MDC2_CTX c3;
+	MDC2_Init(&c3);
+	MDC2_Update(&c3, reader->resultrsa, sizeof(reader->resultrsa));
+	MDC2_Final(&(mdc_hash3[0]), &c3);
+
+	memcpy(&reader->cak7_aes_key[16],mdc_hash3,16);
+	memcpy(reader->cak7_aes_key,mdc_hash3,16);
+
+	char tmp7[128];
+	rdr_log(reader, "New AES: %s", cs_hexdump(1, reader->cak7_aes_key, 16, tmp7, sizeof(tmp7)));
 
-	memcpy(&reader->cak7_aes_key[16],mdc_hash,16);
-	memcpy(reader->cak7_aes_key,mdc_hash,16);
+	return OK;
 }
 
-void CAK7_reinit(struct s_reader *reader)
+static int32_t CAK7_cmd03_unique(struct s_reader *reader)
 {
-	ATR newatr[ATR_MAX_SIZE];
-	memset(newatr, 0, 1);
-	if(ICC_Async_Activate(reader, newatr, 0))
-	{
-		reader->card_status = CARD_NEED_INIT;
-		add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
-	}
-	else
+	def_resp;
+	BN_CTX *ctx1 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx1);
+#endif
+	BIGNUM *bnN1 = BN_CTX_get(ctx1);
+	BIGNUM *bnE1 = BN_CTX_get(ctx1);
+	BIGNUM *bnCT1 = BN_CTX_get(ctx1);
+	BIGNUM *bnPT1 = BN_CTX_get(ctx1);
+	BN_bin2bn(&reader->key3460[0], 0x60, bnN1);
+	BN_bin2bn(public_exponent, 3, bnE1);
+	BN_bin2bn(&reader->step1[0], 0x60, bnCT1);
+	BN_mod_exp(bnPT1, bnCT1, bnE1, bnN1, ctx1);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT1, reader->data + (0x60 - BN_num_bytes(bnPT1)));
+	BN_CTX_end(ctx1);
+	BN_CTX_free(ctx1);
+
+	memcpy(&reader->step2[0], d00ff, 4);
+	memcpy(&reader->step2[4], reader->cardid, 4);
+	memcpy(&reader->step2[8], reader->data, 0x60);
+	rdr_log_dump_dbg(reader, D_READER, reader->step2, sizeof(reader->step2), "STEP 2:");
+
+	if(reader->cak7_seq <= 15)
 	{
-		reader->cak7_seq = 0;
-		CAK7_getCamKey(reader);
+		dt05_20(reader);
+		CreateRSAPair68(reader, reader->klucz68);
 	}
-}
-
-static int32_t nagra3_card_init(struct s_reader *reader, ATR *newatr)
-{
-	get_atr;
 
-	memset(reader->hexserial, 0x00, 0x08);
+	BN_CTX *ctx2 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx2);
+#endif
+	BIGNUM *bnN2 = BN_CTX_get(ctx2);
+	BIGNUM *bnE2 = BN_CTX_get(ctx2);
+	BIGNUM *bnCT2 = BN_CTX_get(ctx2);
+	BIGNUM *bnPT2 = BN_CTX_get(ctx2);
+	BN_bin2bn(&reader->key68[0], 0x68, bnN2);
+	BN_bin2bn(&reader->exp68[0], 0x68, bnE2);
+	BN_bin2bn(&reader->step2[0], 0x68, bnCT2);
+	BN_mod_exp(bnPT2, bnCT2, bnE2, bnN2, ctx2);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT2, reader->data + (0x68 - BN_num_bytes(bnPT2)));
+	BN_CTX_end(ctx2);
+	BN_CTX_free(ctx2);
 
-	reader->public_exponent[0] = 0x01;
-	reader->public_exponent[1] = 0x00;
-	reader->public_exponent[2] = 0x01;
-	reader->public_exponent_length = 3;
+	memcpy(&reader->step3[0], d00ff, 4);
+	memcpy(&reader->step3[4], reader->data, 0x68);
+	rdr_log_dump_dbg(reader, D_READER, reader->step3, sizeof(reader->step3), "STEP 3:");
 
-	reader->irdid[0] = 0x64;
-	reader->irdid[1] = 0x65;
-	reader->irdid[2] = 0x6D;
-	reader->irdid[3] = 0x6F;
-	reader->irdid_length = 4;
+	BN_CTX *ctx3 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx3);
+#endif
+	BIGNUM *bnN3 = BN_CTX_get(ctx3);
+	BIGNUM *bnE3 = BN_CTX_get(ctx3);
+	BIGNUM *bnCT3 = BN_CTX_get(ctx3);
+	BIGNUM *bnPT3 = BN_CTX_get(ctx3);
+	BN_bin2bn(&reader->kdt05_00[0], 0x6c, bnN3);
+	BN_bin2bn(public_exponent, 3, bnE3);
+	BN_bin2bn(&reader->step3[0], 0x6c, bnCT3);
+	BN_mod_exp(bnPT3, bnCT3, bnE3, bnN3, ctx3);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT3, reader->data + (0x6c - BN_num_bytes(bnPT3)));
+	BN_CTX_end(ctx3);
+	BN_CTX_free(ctx3);
 
-	reader->cak7_seq = 0;
-	cs_clear_entitlement(reader);
+	uint8_t cmd03[] = {0xCC,0xCC,0xCC,0xCC,0x00,0x00,0x0A,0x03,0x6C,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};
+
+	memcpy(&cmd03[9],reader->data,0x6c);
+
+	do_cak7_cmd(reader,cta_res,&cta_lr,cmd03,sizeof(cmd03),0x90);
 
-	if(memcmp(atr + 11, "DNASP4", 6) == 0)
+	if(cta_lr == 0)
 	{
-		memcpy(reader->rom, atr + 11, 15);
-		rdr_log(reader,"Rom revision: %.15s", reader->rom);
+		rdr_log(reader, "card is not responding to CMD03 - check your data");
+		return ERROR;
+	}
+
+	rdr_log_dump_dbg(reader, D_READER, cta_res, 0x90, "CMD03 ANSWER:");
+	memcpy(reader->encrypted,&cta_res[18],0x60);
+
+	BN_CTX *ctx = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx);
+#endif
+	BIGNUM *bnN = BN_CTX_get(ctx);
+	BIGNUM *bnE = BN_CTX_get(ctx);
+	BIGNUM *bnCT = BN_CTX_get(ctx);
+	BIGNUM *bnPT = BN_CTX_get(ctx);
+	BN_bin2bn(&reader->key3460[0], 96, bnN);
+	BN_bin2bn(public_exponent, 3, bnE);
+	BN_bin2bn(&reader->encrypted[0], 96, bnCT);
+	BN_mod_exp(bnPT, bnCT, bnE, bnN, ctx);
+	memset(reader->result, 0, 96);
+	BN_bn2bin(bnPT, reader->result + (96 - BN_num_bytes(bnPT)));
+	BN_CTX_end(ctx);
+	BN_CTX_free(ctx);
+
+	rdr_log_dump_dbg(reader, D_READER, reader->result, 96, "after RSA_3460: ");
+
+	//uint8_t stillencrypted[0x50];
+	memcpy(reader->stillencrypted,&reader->result[4],0x50);
+
+	//uint8_t resultrsa[0x50];
+	BN_CTX *ctxs = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctxs);
+#endif
+	BIGNUM *bnNs  = BN_CTX_get(ctxs);
+	BIGNUM *bnEs  = BN_CTX_get(ctxs);
+	BIGNUM *bnCTs = BN_CTX_get(ctxs);
+	BIGNUM *bnPTs = BN_CTX_get(ctxs);
+	BN_bin2bn(&reader->mod50[0], reader->mod50_length, bnNs);
+	BN_bin2bn(&reader->cak7expo[0], 0x11, bnEs);
+	BN_bin2bn(&reader->stillencrypted[0], 0x50, bnCTs);
+	BN_mod_exp(bnPTs, bnCTs, bnEs, bnNs, ctxs);
+	memset(reader->resultrsa, 0x00, 0x50);
+	BN_bn2bin(bnPTs, reader->resultrsa + (0x50 - BN_num_bytes(bnPTs)));
+	BN_CTX_end(ctxs);
+	BN_CTX_free(ctxs);
+
+	uint8_t mdc_hash5[MDC2_DIGEST_LENGTH];
+	memset(mdc_hash5,0x00,MDC2_DIGEST_LENGTH);
+	MDC2_CTX c5;
+	MDC2_Init(&c5);
+	MDC2_Update(&c5, reader->resultrsa, sizeof(reader->resultrsa));
+	MDC2_Final(&(mdc_hash5[0]), &c5);
+
+	memcpy(&reader->cak7_aes_key[16],mdc_hash5,16);
+	memcpy(reader->cak7_aes_key,mdc_hash5,16);
+
+	char tmp7[128];
+	rdr_log(reader, "New AES: %s", cs_hexdump(1, reader->cak7_aes_key, 16, tmp7, sizeof(tmp7)));
+
+	return OK;
+}
+
+static int32_t CAK7_GetCamKey(struct s_reader *reader)
+{
+	def_resp;
+	uint8_t cmd0e[] = {0xCC,0xCC,0xCC,0xCC,0x00,0x00,0x00,0x0E,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,
+	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};
+
+	if(!reader->nuid_length)
+	{
+		uint8_t cmd02[] = {0x02,0x7B};
+
+		memcpy(cmd0e + 7, cmd02, 2);
+
+		rdr_log(reader, "using CMD02");
 	}
 	else
 	{
+		memcpy(cmd0e + 132, reader->nuid, reader->nuid_length); // inject NUID
+
+                uint8_t cwekeycount = 0;
+
+                if(reader->cwekey0_length)
+                        { cwekeycount++; }
+                if(reader->cwekey1_length)
+                        { cwekeycount++; }
+                if(reader->cwekey2_length)
+                        { cwekeycount++; }
+                if(reader->cwekey3_length)
+                        { cwekeycount++; }
+                if(reader->cwekey4_length)
+                        { cwekeycount++; }
+                if(reader->cwekey5_length)
+                        { cwekeycount++; }
+                if(reader->cwekey6_length)
+                        { cwekeycount++; }
+                if(reader->cwekey7_length)
+                        { cwekeycount++; }
+
+                if(cwekeycount == 0)
+                {
+                        rdr_log(reader, "only NUID defined - enter at least CWPK0");
+                        return ERROR;
+                }
+		else
+		{
+			if(reader->otpcsc_length)
+			{
+				memcpy(cmd0e + 136, reader->otpcsc, reader->otpcsc_length);
+			}
+			else
+			{
+				if(!reader->cwpkota)
+				{
+					cmd0e[136] = 0x00;
+					cmd0e[137] = cwekeycount;
+				}
+				else
+				{
+					cmd0e[136] = 0x00;
+					cmd0e[137] = 0x00;
+				}
+			}
+
+			if(reader->otacsc_length)
+			{
+				memcpy(cmd0e + 138, reader->otacsc, reader->otacsc_length);
+			}
+			else
+			{
+				if(reader->cwpkota)
+				{
+					cmd0e[138] = 0x00;
+					cmd0e[139] = cwekeycount;
+				}
+				else
+				{
+					cmd0e[138] = 0x00;
+					cmd0e[139] = 0x00;
+				}
+			}
+		}
+
+		char tmp[16];
+		rdr_log(reader, "OTP CSC No. of keys: %s", cs_hexdump(1, cmd0e + 136, 2, tmp, sizeof(tmp)));
+		rdr_log(reader, "OTA CSC No. of keys: %s", cs_hexdump(1, cmd0e + 138, 2, tmp, sizeof(tmp)));
+	}
+
+	if(reader->forcepair_length)
+	{
+		rdr_log(reader, "Forcing Pairing Type");
+		memcpy(cmd0e + 13, reader->forcepair, 1);
+	}
+	else
+	{
+		if(reader->hasunique == 1)
+		{
+			cmd0e[13] = 0x40;
+		}
+	}
+
+	memcpy(cmd0e + 14, reader->idird, 4);
+	if(reader->cmd0eprov_length)
+	{
+		memcpy(cmd0e + 18, reader->cmd0eprov, 2);
+	}
+	else
+	{
+		memcpy(cmd0e + 18, reader->prid[0] + 2, 2);
+	}
+
+	memcpy(cmd0e + 20, reader->key3588 + 24, 0x70);
+
+	if(reader->cak7_seq <= 15)
+	{
+		srand(time(NULL));
+	}
+	uint32_t data1r = rand() % 4294967294u;
+
+	reader->timestmp1[0]=(data1r>>24)&0xFF;
+	reader->timestmp1[1]=(data1r>>16)&0xFF;
+	reader->timestmp1[2]=(data1r>>8)&0xFF;
+	reader->timestmp1[3]=(data1r)&0xFF;
+
+	memcpy(cmd0e + 9, reader->timestmp1, 0x04);
+
+	rdr_log_dump_dbg(reader, D_READER, reader->timestmp1, 4, "DATA1  CMD0E:");
+	rdr_log_dump_dbg(reader, D_READER, reader->prid[0], 4, "SysID:");
+
+	do_cak7_cmd(reader,cta_res, &cta_lr, cmd0e, sizeof(cmd0e), 0x20);
+
+	if(cta_lr == 0)
+	{
+		rdr_log(reader, "card is not responding to CMD02/E - check your data");
 		return ERROR;
 	}
 
-	// check the completeness of the required CAK7 keys
-	if(reader->mod1_length && reader->irdid_length && reader->data50_length && reader->mod50_length && reader->key60_length && reader->exp60_length && reader->nuid_length)
+	reader->needrestart =  (cta_res[22] << 16);
+	reader->needrestart += (cta_res[23] <<  8);
+	reader->needrestart += (cta_res[24]      );
+	reader->needrestart--;
+
+	if(reader->cak7_seq <= 15)
 	{
-		rdr_log_dbg(reader, D_READER, "All parameters for CAK7 global pairing are set.");
+		rdr_log(reader, "card needs FASTreinit after %d CMDs", reader->needrestart);
 	}
 	else
 	{
-		rdr_log(reader, "ERROR: Not all required CAK7 parameters are set!");
-		reader->card_status = CARD_FAILURE;
+		uint32_t cmdleft = reader->needrestart - reader->cak7_seq;
+		rdr_log(reader, "%d CMDs left to FASTreinit", cmdleft);
+	}
+
+	reader->dword_83DBC =  (cta_res[18] << 24);
+	reader->dword_83DBC += (cta_res[19] << 16);
+	reader->dword_83DBC += (cta_res[20] <<  8);
+	reader->dword_83DBC += (cta_res[21]      );
+	calc_cak7_exponent(&reader->dword_83DBC, reader->cak7expo, 0x11);
+	rdr_log_dump_dbg(reader, D_READER, reader->cak7expo, 0x11, "CAK7 Exponent:");
+	memcpy(reader->cardid,cta_res + 14, 4);
+	rdr_log_dump_dbg(reader, D_READER, reader->cardid, 0x04, "CardSerial: ");
+	memcpy(reader->hexserial + 2, reader->cardid, 4);
+	unsigned long datal = (cta_res[9] << 24) + (cta_res[10] << 16) + (cta_res[11] << 8) + (cta_res[12]);
+	datal++;
+	reader->data2[0] = (datal >> 24) & 0xFF;
+	reader->data2[1] = (datal >> 16) & 0xFF;
+	reader->data2[2] = (datal >>  8) & 0xFF;
+	reader->data2[3] = (datal      ) & 0xFF;
+
+	data1r++;
+	reader->timestmp2[0]=(data1r>>24)&0xFF;
+	reader->timestmp2[1]=(data1r>>16)&0xFF;
+	reader->timestmp2[2]=(data1r>>8)&0xFF;
+	reader->timestmp2[3]=(data1r)&0xFF;
+
+	memcpy(reader->ecmheader,cta_res + 18,4);
+
+	if(reader->cak7_seq <= 15)
+	{
+		uint8_t mdc_hash2[MDC2_DIGEST_LENGTH];
+		memset(mdc_hash2,0x00,MDC2_DIGEST_LENGTH);
+		uint8_t check2[0x78];
+		memset(check2, 0x00, 0x78);
+		memcpy(check2, reader->cardid, 4);
+		memcpy(check2 + 16, reader->kdt05_10, 0x68);
+		MDC2_CTX c2;
+		MDC2_Init(&c2);
+		MDC2_Update(&c2, check2, 0x78);
+		MDC2_Final(&(mdc_hash2[0]), &c2);
+
+		rdr_log_dump_dbg(reader, D_READER, reader->ideakey1, 16, "IDEAKEY1: ");
+		rdr_log_dump_dbg(reader, D_READER, mdc_hash2, 16, "MDC_HASH: ");
+		if(memcmp(mdc_hash2 + 1, reader->ideakey1 + 1, 14) == 0)
+		{
+		rdr_log(reader, "DT05_10 is correct");
+		}
+		else
+		{
+		rdr_log(reader, "DT05_10 error - check MOD1");
+		}
+	}
+
+	BN_CTX *ctx0 = BN_CTX_new();
+#ifdef WITH_LIBCRYPTO
+	BN_CTX_start(ctx0);
+#endif
+	BIGNUM *bnN0 = BN_CTX_get(ctx0);
+	BIGNUM *bnE0 = BN_CTX_get(ctx0);
+	BIGNUM *bnCT0 = BN_CTX_get(ctx0);
+	BIGNUM *bnPT0 = BN_CTX_get(ctx0);
+	BN_bin2bn(&reader->mod50[0], 0x50, bnN0);
+	BN_bin2bn(&reader->cak7expo[0], 0x11, bnE0);
+	BN_bin2bn(&reader->data50[0], 0x50, bnCT0);
+	BN_mod_exp(bnPT0, bnCT0, bnE0, bnN0, ctx0);
+	memset(reader->data, 0x00, sizeof(reader->data));
+	BN_bn2bin(bnPT0, reader->data + (0x50 - BN_num_bytes(bnPT0)));
+	BN_CTX_end(ctx0);
+	BN_CTX_free(ctx0);
+
+	rdr_log_dump_dbg(reader, D_READER, reader->timestmp2, 4, "DATA1  CMD03:");
+
+	memcpy(&reader->step1[0], d00ff, 4);
+	memcpy(&reader->step1[4], reader->data, 0x50);
+	memcpy(&reader->step1[4 + 0x50], reader->idird, 0x04);
+	memcpy(&reader->step1[4 + 4 + 0x50], reader->timestmp2, 0x04);
+	memcpy(&reader->step1[4 + 4 + 4 + 0x50], reader->data2, 0x04);
+	rdr_log_dump_dbg(reader, D_READER, reader->step1, sizeof(reader->step1), "STEP 1:");
+
+	reader->pairtype = cta_res[13];
+
+	if((reader->pairtype > 0x00) && (reader->pairtype < 0xC0))
+	{
+		rdr_log(reader,"Card is starting in GLOBAL mode");
+		if(!CAK7_cmd03_global(reader))
+		{return ERROR;}
+	}
+	else if(reader->pairtype == 0xC0)
+	{
+		rdr_log(reader,"Card is starting in UNIQUE mode");
+
+		if(!reader->mod2_length)
+        	{
+                	rdr_log(reader, "no mod2 defined");
+                	return ERROR;
+        	}
+                if(!reader->key3460_length)
+                {
+                        rdr_log(reader, "no key3460 defined");
+                        return ERROR;
+                }
+                if(!reader->key3310_length)
+                {
+                        rdr_log(reader, "no key3310 defined");
+                        return ERROR;
+                }
+		if(!CAK7_cmd03_unique(reader))
+		{return ERROR;}
+	}
+	else
+	{
+		rdr_log(reader,"Unknown Pairing Type");
 		return ERROR;
 	}
+	return OK;
+}
 
-	reader->nprov = 1;
+static int32_t nagra3_card_init(struct s_reader *reader, ATR *newatr)
+{
+	get_atr;
 
-	CAK7GetDataType(reader, DT05);
-	CAK7GetDataType(reader, SYSID_CAID); // sysid+caid
-	CAK7_getCamKey(reader);
+	memset(reader->hexserial, 0, 8);
+	reader->cak7_seq = 0;
+	reader->hasunique = 0;
+	memset(reader->ecmheader, 0, 4);
+	cs_clear_entitlement(reader);
+
+	if(memcmp(atr + 8, "DNASP4", 6) == 0)
+	{
+		if((memcmp(atr + 8, "DNASP400", 8) == 0) && !reader->cak7_mode)
+		{
+			return ERROR;
+		}
+		else
+		{
+			memcpy(reader->rom, atr + 8, 15);
+			rdr_log(reader,"Rom revision: %.15s", reader->rom);
+		}
+	}
+	else if(memcmp(atr + 11, "DNASP4", 6) == 0)
+	{
+		memcpy(reader->rom, atr + 11, 15);
+		rdr_log(reader,"Rom revision: %.15s", reader->rom);
+	}
+	else
+	{
+		return ERROR;
+	}
+
+	reader->nprov   = 1;
+	/*reader->nsa     = 0;
+	reader->nemm84  = 0;
+	reader->nemm83u = 0;
+	reader->nemm83s = 0;
+	reader->nemm87  = 0;*/
+
+	if(!reader->mod1_length)
+	{
+		rdr_log(reader, "no MOD1 defined");
+		return ERROR;
+	}
+	if(!reader->key3588_length)
+	{
+                rdr_log(reader, "no key3588 defined");
+                return ERROR;
+        }
+        if(!reader->data50_length)
+        {
+                rdr_log(reader, "no data50 defined");
+                return ERROR;
+        }
+        if(!reader->mod50_length)
+        {
+                rdr_log(reader, "no mod50 defined");
+                return ERROR;
+        }
+        if(!reader->idird_length)
+        {
+                rdr_log(reader, "no idird defined");
+                return ERROR;
+        }
+
+	CAK7GetDataType(reader, 0x02);
+	CAK7GetDataType(reader, 0x05);
+	if(!CAK7_GetCamKey(reader))
+	{return ERROR;}
 
 	rdr_log(reader, "ready for requests");
 	return OK;
@@ -446,37 +1476,111 @@ static int32_t nagra3_card_info(struct s_reader *reader)
 	rdr_log_sensitive(reader, "SER:    {%s}", cs_hexdump(1, reader->hexserial + 2, 4, tmp, sizeof(tmp)));
 	rdr_log(reader, "CAID:   %04X", reader->caid);
 	rdr_log(reader, "Prv.ID: %s(sysid)", cs_hexdump(1, reader->prid[0], 4, tmp, sizeof(tmp)));
-	CAK7GetDataType(reader, IRDINFO);
 	cs_clear_entitlement(reader); // reset the entitlements
 	rdr_log(reader, "-----------------------------------------");
 	rdr_log(reader, "|id  |tier    |valid from  |valid to    |");
 	rdr_log(reader, "+----+--------+------------+------------+");
-	CAK7GetDataType(reader, TIERS);
+	CAK7GetDataType(reader, 0x03);
+	CAK7GetDataType(reader, 0x0C);
 	rdr_log(reader, "-----------------------------------------");
-	uint8_t i;
+
+	reader->nsa     = 0;
+	reader->nemm84  = 0;
+	reader->nemm83u = 0;
+	reader->nemm83s = 0;
+	reader->nemm87  = 0;
+
+	CAK7GetDataType(reader, 0x04);
+	if(reader->forceemmg)
+	{
+		reader->emm82 = 1;
+	}
+
+	int i;
 	for(i = 1; i < reader->nprov; i++)
 	{
 		rdr_log(reader, "Prv.ID: %s", cs_hexdump(1, reader->prid[i], 4, tmp, sizeof(tmp)));
 	}
 
-	struct timeb now;
-	cs_ftime(&now);
-	reader->last_refresh=now;
+	if(reader->cak7type != 3)
+	{
+		rdr_log(reader, "-----------------------------------------");
+		rdr_log(reader, "|       EMM Filters (PRIVATE!!)         |");
+		rdr_log(reader, "+---------------------------------------+");
+
+		if(reader->emm82 == 1)
+		{
+			rdr_log(reader, "|emm82                                  |");
+		}
+
+		char tmp7[48];
+
+		for(i = 0; i < reader->nemm84; i++)
+		{
+			rdr_log(reader, "|emm84 : %s                      |", cs_hexdump(1, reader->emm84[i], 3, tmp7, sizeof(tmp7)));
+		}
+
+		for(i = 0; i < reader->nemm83u; i++)
+		{
+			rdr_log(reader, "|emm83U: %s             |", cs_hexdump(1, reader->emm83u[i], 6, tmp7, sizeof(tmp7)));
+		}
+
+		for(i = 0; i < reader->nemm83s; i++)
+		{
+			rdr_log(reader, "|emm83S: %s             |", cs_hexdump(1, reader->emm83s[i], 6, tmp7, sizeof(tmp7)));
+		}
+
+		for(i = 0; i < reader->nemm87; i++)
+		{
+			rdr_log(reader, "|emm87 : %s             |", cs_hexdump(1, reader->emm87[i], 6, tmp7, sizeof(tmp7)));
+		}
+		rdr_log(reader, "-----------------------------------------");
+	}
 
 	return OK;
 }
 
+static int32_t fastreinit(struct s_reader *reader)
+{
+	ATR newatr[ATR_MAX_SIZE];
+	memset(newatr, 0, 1);
+	if(ICC_Async_Activate(reader, newatr, 0))
+	{
+		return ERROR;
+	}
+	reader->cak7_seq = 0;
+	if(!CAK7_GetCamKey(reader))
+	{
+		return ERROR;
+	}
+	return OK;
+}
+
 static void nagra3_post_process(struct s_reader *reader)
 {
-	if(reader->cak7_seq >= reader->cak7_restart)
+	if(reader->cak7_seq >= reader->needrestart)
 	{
-		rdr_log(reader, "reinit necessary to reset command counter");
-		CAK7_reinit(reader);
+		rdr_log(reader, "card needs FASTreinit to prevent crash");
+		if(!fastreinit(reader))
+		{
+			rdr_log(reader, "FASTreinit failed - need to restart reader");
+			reader->card_status = CARD_NEED_INIT;
+			add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
+		}
 	}
 	else if((reader->cak7_camstate & 64) == 64)
 	{
-		rdr_log_dbg(reader, D_READER, "renew Session Key: CAK7");
-		add_job(reader->client, ACTION_READER_RENEW_SK, NULL, 0); //CAK7_getCamKey
+		rdr_log(reader, "negotiating new Session Key");
+		if(!CAK7_GetCamKey(reader))
+		{
+			rdr_log(reader, "negotiations failed - trying FASTreinit");
+			if(!fastreinit(reader))
+			{
+				rdr_log(reader, "FASTreinit failed - need to restart reader");
+                reader->card_status = CARD_NEED_INIT;
+                add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
+			}
+		}
 	}
 }
 
@@ -484,35 +1588,95 @@ static int32_t nagra3_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, str
 {
 	def_resp;
 
+	if(reader->cak7type == 3)
+	{
+		if(er->ecm[2] > 0x61 && er->ecm[7] == 0x5C && er->ecm[100] == 0x0B)
+		{
+			if(er->ecm[101] == 0x03 || er->ecm[101] == 0x04)
+			{
+				if(er->ecm[104] > reader->pairtype)
+				{
+					rdr_log(reader, "reinit card in Unique Pairing Mode");
+					return ERROR;
+				}
+				if(er->ecm[104] == 0x80 && reader->pairtype == 0x80)
+				{
+					rdr_log(reader, "reinit card in Unique Pairing Mode");
+					return ERROR;
+				}
+			}
+			if(er->ecm[101] == 0x04 && !reader->nuid_length)
+			{
+				rdr_log(reader, "reinit card with NUID");
+				return ERROR;
+			}
+		}
+	}
+	else
+	{
+		if(er->ecm[2] > 0x86 && er->ecm[4] == 0x84 && er->ecm[137] == 0x0B)
+		{
+			if(er->ecm[138] == 0x03 || er->ecm[138] == 0x04)
+			{
+				if(er->ecm[141] > reader->pairtype)
+				{
+					rdr_log(reader, "reinit card in Unique Pairing Mode");
+					return ERROR;
+				}
+				if(er->ecm[141] == 0x80 && reader->pairtype == 0x80)
+				{
+					rdr_log(reader, "reinit card in Unique Pairing Mode");
+					return ERROR;
+				}
+			}
+			if(er->ecm[138] == 0x04 && !reader->nuid_length)
+			{
+				rdr_log(reader, "reinit card with NUID");
+				return ERROR;
+			}
+		}
+	}
+
 	uint8_t ecmreq[0xC0];
 	memset(ecmreq,0xCC,0xC0);
 
 	ecmreq[ 7] = 0x05;
-	ecmreq[ 8] = 0x8A;
-	ecmreq[ 9] = 0x00;
-	ecmreq[10] = 0x00;
-	ecmreq[11] = 0x00;
-	ecmreq[12] = 0x00;
-	ecmreq[13] = 0x01;
-	memcpy(&ecmreq[14], er->ecm + 4, er->ecm[4] + 1);
+	ecmreq[ 9] = 0x04;
+	ecmreq[10] = reader->ecmheader[0];
+	ecmreq[11] = reader->ecmheader[1];
+	ecmreq[12] = reader->ecmheader[2];
+	ecmreq[13] = reader->ecmheader[3];
+	if(reader->cak7type == 3)
+	{
+		ecmreq[8] = er->ecm[7] + 6;
+		memcpy(&ecmreq[14], er->ecm + 7, er->ecm[7] + 1);
+	}
+	else
+	{
+		ecmreq[8] = er->ecm[4] + 6;
+		memcpy(&ecmreq[14], er->ecm + 4, er->ecm[4] + 1);
+	}
 
 	do_cak7_cmd(reader, cta_res, &cta_lr, ecmreq, sizeof(ecmreq), 0xB0);
 
-	if(cta_res[cta_lr - 2] != 0x90 && cta_res[cta_lr - 1] != 0x00)
+	rdr_log_dump_dbg(reader, D_READER, cta_res, 0xB0, "Decrypted ECM Answer:");
+
+	if((cta_res[cta_lr - 2] != 0x90 && cta_res[cta_lr - 1] != 0x00) || cta_lr == 0)
 	{
 		rdr_log(reader, "(ECM) Reader will be restart now cause: %02X %02X card answer!!!", cta_res[cta_lr - 2], cta_res[cta_lr - 1]);
 		reader->card_status = CARD_NEED_INIT;
 		add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
 	}
-
-	if(cta_res[27] == 0x5C)
+	else if(cta_res[27] != 0x00 && cta_res[27] != 0xCC)
 	{
+		memcpy(reader->ecmheader, cta_res + 9, 4);
+		reader->cak7_camstate = cta_res[4];
+
 		uint8_t _cwe0[8];
 		uint8_t _cwe1[8];
 
-		if(cta_res[78] == 0x01)
+		if(cta_res[78] == 0x01 || reader->forcecwswap)
 		{
-			rdr_log (reader,"Swap dcw is at use !");
 			memcpy(_cwe0,&cta_res[52], 0x08);
 			memcpy(_cwe1,&cta_res[28], 0x08);
 		}
@@ -522,120 +1686,166 @@ static int32_t nagra3_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, str
 			memcpy(_cwe1,&cta_res[52], 0x08);
 		}
 
-		if(!reader->cwekey_length)
+		if(cta_res[27] == 0x5C)
 		{
-			rdr_log_dbg(reader, D_READER, "ERROR: CWPK is not set, can not decrypt CW");
-			return ERROR;
-		}
-		des_ecb3_decrypt(_cwe0, reader->cwekey);
-		des_ecb3_decrypt(_cwe1, reader->cwekey);
+			if(!reader->cwekey0_length)
+			{
+				rdr_log(reader, "ERROR: CWPK is not set, can not decrypt CW");
+				return ERROR;
+			}
 
-		int chkok = 1;
-		if(((_cwe0[0] + _cwe0[1] + _cwe0[2]) & 0xFF) != _cwe0[3])
+			des_ecb3_decrypt(_cwe0, reader->cwekey0);
+			des_ecb3_decrypt(_cwe1, reader->cwekey0);
+		}
+		else if(cta_res[27] == 0x58)
 		{
-			chkok = 0;
-			rdr_log_dbg(reader, D_READER, "CW0 checksum error [0]");
+			des_ecb3_decrypt(_cwe0, reader->key3des);
+			des_ecb3_decrypt(_cwe1, reader->key3des);
 		}
 
-		if(((_cwe0[4] + _cwe0[5] + _cwe0[6]) & 0xFF) != _cwe0[7])
+		rdr_log_dbg(reader, D_READER, "CW Decrypt ok");
+		memcpy(ea->cw, _cwe0, 0x08);
+		memcpy(ea->cw + 8, _cwe1, 0x08);
+		return OK;
+	}
+	else if(cta_res[23] == 0x00)
+	{
+		memcpy(reader->ecmheader, cta_res + 9, 4);
+		reader->cak7_camstate = cta_res[4];
+
+		if(reader->hasunique && reader->pairtype < 0xC0)
 		{
-			chkok = 0;
-			rdr_log_dbg(reader, D_READER, "CW0 checksum error [1]");
+			rdr_log(reader, "reinit card in Unique Pairing Mode");
 		}
-
-		if(((_cwe1[0] + _cwe1[1] + _cwe1[2]) & 0xFF) != _cwe1[3])
+		else
 		{
-			chkok = 0;
-			rdr_log_dbg(reader, D_READER, "CW1 checksum error [0]");
+			rdr_log(reader, "card has no right to decode this channel");
 		}
-
-		if(((_cwe1[4] + _cwe1[5] + _cwe1[6]) & 0xFF) != _cwe1[7])
+	}
+	else if(cta_res[23] == 0x04)
+	{
+		if(!reader->nuid_length)
 		{
-			chkok = 0;
-			rdr_log_dbg(reader, D_READER, "CW1 checksum error [1]");
+			rdr_log(reader, "reinit card with NUID");
 		}
-
-		reader->cak7_camstate = cta_res[4];
-		if(chkok == 1)
+		else
 		{
-			rdr_log_dbg(reader, D_READER, "CW Decrypt ok");
-			memcpy(ea->cw, _cwe0, 0x08);
-			memcpy(ea->cw + 8, _cwe1, 0x08);
-			return OK;
+			rdr_log(reader, "wrong OTP/OTA CSC values");
 		}
 	}
-
+	else
+	{
+		rdr_log(reader, "card got wrong ECM");
+	}
 	return ERROR;
 }
 
 static int32_t nagra3_do_emm(struct s_reader *reader, EMM_PACKET *ep)
 {
 	def_resp;
-	uint8_t emmreq[0xC0];
-	memset(emmreq, 0xCC, 0xC0);
-	emmreq[ 7] = 0x05;
-	emmreq[ 8] = 0x8A;
-	emmreq[ 9] = 0x00;
-	emmreq[10] = 0x00;
-	emmreq[11] = 0x00;
-	emmreq[12] = 0x00;
-	emmreq[13] = 0x01;
-	memcpy(&emmreq[14], ep->emm + 9, ep->emm[9] + 1);
-	do_cak7_cmd(reader, cta_res, &cta_lr, emmreq, sizeof(emmreq), 0xB0);
 
-	if(cta_lr == 0)
+	if(ep->emm[0] == 0x90)
 	{
-		rdr_log_dbg(reader, D_READER, "card reinit necessary");
-		CAK7_reinit(reader);
-	}
-	else if(cta_res[cta_lr - 2] != 0x90 && cta_res[cta_lr - 1] != 0x00)
-	{
-		rdr_log(reader, "(EMM) Reader will be restart now cause: %02X %02X card answer!!!", cta_res[cta_lr - 2], cta_res[cta_lr - 1]);
-		CAK7_reinit(reader);
+		rdr_log(reader, "OSCam got your BoxEMM");
+		char tmp[128];
+		rdr_log(reader, "NUID: %s", cs_hexdump(1, reader->nuid, 4, tmp, sizeof(tmp)));
+		rdr_log(reader, "Index: %s", cs_hexdump(1, ep->emm + 10, 1, tmp, sizeof(tmp)));
+		rdr_log(reader, "eCWPK: %s", cs_hexdump(1, ep->emm + 11, 16, tmp, sizeof(tmp)));
 	}
 	else
 	{
-		if(reader->cak7_seq >= reader->cak7_restart)
+		uint8_t emmreq[0xC0];
+		memset(emmreq, 0xCC, 0xC0);
+
+		emmreq[ 7] = 0x05;
+		emmreq[ 9] = 0x04;
+		emmreq[10] = reader->ecmheader[0];
+		emmreq[11] = reader->ecmheader[1];
+		emmreq[12] = reader->ecmheader[2];
+		emmreq[13] = reader->ecmheader[3];
+
+		if(reader->cak7type == 3)
 		{
-			rdr_log_dbg(reader, D_READER, "reinit necessary to reset command counter");
-			CAK7_reinit(reader);
+			int32_t i;
+			uint8_t *prov_id_ptr;
+
+			switch(ep->type)
+			{
+				case SHARED:
+					emmreq[8] = ep->emm[9] + 6;
+					prov_id_ptr = ep->emm + 3;
+					memcpy(&emmreq[14], ep->emm + 9, ep->emm[9] + 1);
+					break;
+
+				case UNIQUE:
+					emmreq[8] = ep->emm[12] + 6;
+					prov_id_ptr = ep->emm + 9;
+					memcpy(&emmreq[14], ep->emm + 12, ep->emm[12] + 1);
+					break;
+
+				case GLOBAL:
+					emmreq[8] = ep->emm[6] + 6;
+					prov_id_ptr = ep->emm + 3;
+					memcpy(&emmreq[14], ep->emm + 6, ep->emm[6] + 1);
+					break;
+
+				default:
+					rdr_log(reader, "EMM: Congratulations, you have discovered a new EMM on Merlin.");
+					rdr_log(reader, "This has not been decoded yet.");
+					return ERROR;
+			}
+
+			i = get_prov_index(reader, prov_id_ptr);
+			if(i == -1)
+			{
+				rdr_log(reader, "EMM: skipped since provider id doesnt match");
+				return SKIPPED;
+			}
 		}
-		else if(cta_res[4] == 0x80)
+		else
 		{
-			rdr_log_dbg(reader, D_READER, "EMM forced card to reinit");
-			reader->card_status = CARD_NEED_INIT;
-			add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
-			return OK;
+			emmreq[8] = ep->emm[9] + 6;
+			memcpy(&emmreq[14], ep->emm + 9, ep->emm[9] + 1);
 		}
-		else if(cta_res[13] == 0x02)
+
+		do_cak7_cmd(reader, cta_res, &cta_lr, emmreq, sizeof(emmreq), 0xB0);
+
+		if((cta_res[cta_lr-2] != 0x90 && cta_res[cta_lr-1] != 0x00) || cta_lr == 0)
 		{
-			rdr_log_dbg(reader, D_READER, "Revision update - card reinit necessary");
+			rdr_log(reader, "(EMM) Reader will be restart now cause: %02X %02X card answer!!!", cta_res[cta_lr - 2], cta_res[cta_lr - 1]);
 			reader->card_status = CARD_NEED_INIT;
 			add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
-			return OK;
-		}
-		else if((cta_res[4] & 64) == 64)
-		{
-			rdr_log_dbg(reader, D_READER, "negotiating new Session Key");
-			CAK7_getCamKey(reader);
 		}
-		else if(cta_res[8] == 0x0E)
+		else
 		{
-			rdr_log_dbg(reader, D_READER, "card got wrong EMM");
-			return OK;
-		}
+			memcpy(reader->ecmheader, cta_res + 9, 4);
 
-		struct timeb now;
-		cs_ftime(&now);
-		int64_t gone_now = comp_timeb(&now, &reader->emm_last);
-		int64_t gone_refresh = comp_timeb(&reader->emm_last, &reader->last_refresh);
-		if(((gone_now > (int64_t)3600*1000) && (gone_now < (int64_t)365*24*3600*1000)) || ((gone_refresh > (int64_t)12*3600*1000) && (gone_refresh < (int64_t)365*24*3600*1000)))
-		{
-			reader->last_refresh=now;
-			add_job(reader->client, ACTION_READER_CARDINFO, NULL, 0); // refresh entitlement since it might have been changed!
+			if(reader->cak7_seq >= reader->needrestart)
+			{
+				rdr_log(reader, "card needs FASTreinit to prevent crash");
+				if(!fastreinit(reader))
+				{
+					rdr_log(reader, "FASTreinit failed - need to restart reader");
+					reader->card_status = CARD_NEED_INIT;
+					add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
+				}
+			}
+			else if((cta_res[4] & 64) == 64)
+			{
+				rdr_log(reader, "negotiating new Session Key");
+				if(!CAK7_GetCamKey(reader))
+				{
+					rdr_log(reader, "negotiations failed - trying FASTreinit");
+					if(!fastreinit(reader))
+					{
+						rdr_log(reader, "FASTreinit failed - need to restart reader");
+						reader->card_status = CARD_NEED_INIT;
+						add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
+					}
+				}
+			}
 		}
 	}
-
 	return OK;
 }
 
diff --git a/reader-seca.c b/reader-seca.c
index 76826095..33d45122 100644
--- a/reader-seca.c
+++ b/reader-seca.c
@@ -441,7 +441,14 @@ static int32_t seca_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, struc
 		if((cta_res[0] == 0x93) && (cta_res[1] == 0x02))
 		{
 			write_cmd(ins3a, NULL); // get cw
-			snprintf(ea->msglog, MSGLOGSIZE, "unsubscribed 93 02");
+			if(er->ecm[2] > 0x61 && er->ecm[7] == 0x5C && er->ecm[100] == 0x0B)
+			{
+				rdr_log(reader, "reinit card in CAK7 mode");
+			}
+			else
+			{
+				snprintf(ea->msglog, MSGLOGSIZE, "unsubscribed 93 02");
+			}
 			return ERROR;
 		} // exit if unsubscribed
 
diff --git a/webif/pages_index.txt b/webif/pages_index.txt
index 919c5c9e..26c2fc94 100644
--- a/webif/pages_index.txt
+++ b/webif/pages_index.txt
@@ -209,6 +209,7 @@ READERCONFIGBOXKEY            readerconfig/readerconfig_hwreader_boxkey.html
 READERCONFIGIRDETO            readerconfig/readerconfig_hwreader_irdeto.html              READER_IRDETO
 READERCONFIGNAGRA             readerconfig/readerconfig_hwreader_nagra.html               READER_NAGRA
 READERCONFIGNAGRACAK7         readerconfig/readerconfig_hwreader_nagracak7.html           READER_NAGRA_MERLIN
+READERCONFIGCONAX             readerconfig/readerconfig_hwreader_conax.html               READER_CONAX
 READERCONFIGNANO              readerconfig/readerconfig_hwreader_nano.html                WITH_CARDREADER
 READERPINCODE                 readerconfig/readerconfig_hwreader_pincode.html             READER_CONAX,READER_CRYPTOWORKS,READER_VIACCESS,READER_SECA
 READERCONFIGRSAKEY            readerconfig/readerconfig_hwreader_rsakey.html              READER_NAGRA,READER_IRDETO,READER_CONAX
diff --git a/webif/readerconfig/readerconfig_cccambit.html b/webif/readerconfig/readerconfig_cccambit.html
index 85232402..82fba335 100644
--- a/webif/readerconfig/readerconfig_cccambit.html
+++ b/webif/readerconfig/readerconfig_cccambit.html
@@ -1,3 +1,12 @@
+			<TR><TD><A>AU NAGRA type:</A></TD>
+					<TD>
+						<select name="autype">
+							<option value="0" ##AUTYPE0##>0 - Standard</option>
+							<option value="1" ##AUTYPE1##>1 - For Seca/Nagra cards</option>
+							<option value="2" ##AUTYPE2##>2 - For CAK7 cards</option>
+						</select>
+					</TD>
+			</TR>
 			<TR><TD><A>Inactivity timeout:</A></TD><TD><input name="inactivitytimeout" class="withunit short" type="text" maxlength="10" value="##INACTIVITYTIMEOUT##"> s</TD></TR>
 			<TR><TD><A>Reconnect timeout:</A></TD><TD><input name="reconnecttimeout" class="withunit short" type="text" maxlength="10" value="##RECEIVETIMEOUT##"> s</TD></TR>
 			<TR><TD><A>Request timeout:</A></TD><TD><input name="cccreconnect" class="withunit short" type="text" maxlength="10" value="##CCCRECONNECT##"> ms</TD></TR>
diff --git a/webif/readerconfig/readerconfig_hwreader.html b/webif/readerconfig/readerconfig_hwreader.html
index 83f06dcd..7e95600f 100644
--- a/webif/readerconfig/readerconfig_hwreader.html
+++ b/webif/readerconfig/readerconfig_hwreader.html
@@ -21,6 +21,7 @@
 ##TPLREADERCONFIGCRYPTOWORKS##
 ##TPLREADERCONFIGNAGRA##
 ##TPLREADERCONFIGNAGRACAK7##
+##TPLREADERCONFIGCONAX##
 ##TPLREADERCONFIGIRDETO##
 ##TPLREADERCONFIGVIACCESS##
 ##TPLREADERCONFIGDRE##
diff --git a/webif/readerconfig/readerconfig_hwreader_conax.html b/webif/readerconfig/readerconfig_hwreader_conax.html
new file mode 100644
index 00000000..53a8bc6a
--- /dev/null
+++ b/webif/readerconfig/readerconfig_hwreader_conax.html
@@ -0,0 +1,2 @@
+			<TR><TH COLSPAN="2">Reader specific settings for Conax</TH></TR>
+			<TR><TD><A>CWPK:</A></TD><TD><input name="cwpkkey" class="longer" type="text" maxlength="32" value="##CWPKKEY##"></TD></TR>
diff --git a/webif/readerconfig/readerconfig_hwreader_nagra.html b/webif/readerconfig/readerconfig_hwreader_nagra.html
index 44b56638..2dd86ed7 100644
--- a/webif/readerconfig/readerconfig_hwreader_nagra.html
+++ b/webif/readerconfig/readerconfig_hwreader_nagra.html
@@ -9,5 +9,3 @@
 					</TD>
 				</TR>
 				<TR><TD><A>Detect tunneled Seca cards:</A></TD><TD><input name="detect_seca_nagra_tunneled_card" type="hidden" value="0"><input name="detect_seca_nagra_tunneled_card" type="checkbox" value="1" ##NAGRADETECTSECACARDCHECKED##><label></label></TD></TR>
-				<TR><TD><A>Nuid:</A></TD><TD><input name="nuid" class="medium" type="text" maxlength="8" value="##NUID##"></TD></TR>
-				<TR><TD><A>CWPK:</A></TD><TD><input name="cwekey" class="longer" type="text" maxlength="32" value="##CWEKEY##"></TD></TR>
diff --git a/webif/readerconfig/readerconfig_hwreader_nagracak7.html b/webif/readerconfig/readerconfig_hwreader_nagracak7.html
index 25957c92..cdc3c948 100644
--- a/webif/readerconfig/readerconfig_hwreader_nagracak7.html
+++ b/webif/readerconfig/readerconfig_hwreader_nagracak7.html
@@ -1,6 +1,29 @@
 			<TR><TH COLSPAN="2">Reader specific settings for Nagra Merlin</TH></TR>
-				<TR><TD><A>mod1:</A></TD><TD><textarea name="mod1" rows="4" class="bt" maxlength="224">##MOD1##</textarea></TD></TR>
-				<TR><TD><A>data50:</A></TD><TD><textarea name="data50" rows="2" class="bt" maxlength="160">##DATA50##</textarea></TD></TR>
-				<TR><TD><A>mod50:</A></TD><TD><textarea name="mod50" rows="2" class="bt" maxlength="160">##MOD50##</textarea></TD></TR>
-				<TR><TD><A>key60:</A></TD><TD><textarea name="key60" rows="3" class="bt" maxlength="192">##KEY60##</textarea></TD></TR>
-				<TR><TD><A>exp60:</A></TD><TD><textarea name="exp60" rows="3" class="bt" maxlength="192">##EXP60##</textarea></TD></TR>
+				<TR><TD><A>Init card in CAK7 mode:</A></TD><TD><input name="cak7_mode" type="hidden" value="0"><input name="cak7_mode" type="checkbox" value="1" ##NAGRACAK7MODECHECKED##><label></label></TD></TR>
+				<TR><TD><A>Force CW swap:</A></TD><TD><input name="forcecwswap" type="hidden" value="0"><input name="forcecwswap" type="checkbox" value="1" ##FORCECWSWAPCHECKED##><label></label></TD></TR>
+				<TR><TD><A>Force Even SA:</A></TD><TD><input name="evensa" type="hidden" value="0"><input name="evensa" type="checkbox" value="1" ##EVENSACHECKED##><label></label></TD></TR>
+				<TR><TD><A>Force EMMs 0x82:</A></TD><TD><input name="forceemmg" type="hidden" value="0"><input name="forceemmg" type="checkbox" value="1" ##FORCEEMMGCHECKED##><label></label></TD></TR>
+				<TR><TD><A>mod1:</A></TD><TD><textarea name="mod1" rows="5" class="bt" maxlength="224">##MOD1##</textarea></TD></TR>
+				<TR><TD><A>mod2:</A></TD><TD><textarea name="mod2" rows="5" class="bt" maxlength="224">##MOD2##</textarea></TD></TR>
+				<TR><TD><A>key3588:</A></TD><TD><textarea name="key3588" rows="6" class="bt" maxlength="272">##KEY3588##</textarea></TD></TR>
+				<TR><TD><A>key3460:</A></TD><TD><textarea name="key3460" rows="4" class="bt" maxlength="192">##KEY3460##</textarea></TD></TR>
+				<TR><TD><A>key3310:</A></TD><TD><textarea name="key3310" rows="1" class="bt" maxlength="32">##KEY3310##</textarea></TD></TR>
+				<TR><TD><A>data50:</A></TD><TD><textarea name="data50" rows="4" class="bt" maxlength="160">##DATA50##</textarea></TD></TR>
+				<TR><TD><A>mod50:</A></TD><TD><textarea name="mod50" rows="4" class="bt" maxlength="160">##MOD50##</textarea></TD></TR>
+				<TR><TD><A>idird:</A></TD><TD><input name="idird" class="medium" type="text" maxlength="8" value="##IDIRD##"></TD></TR>
+				<TR><TD><A>CMD0E ProvID:</A></TD><TD><input name="cmd0eprov" class="medium" type="text" maxlength="4" value="##CMD0EPROV##"> use only if CMD0E needs ProvID other than sysid</TD></TR>
+				<TR><TD><A>Nuid:</A></TD><TD><input name="nuid" class="medium" type="text" maxlength="8" value="##NUID##"></TD></TR>
+				<TR><TD><A>Force Pairing (00 - global):</A></TD><TD><input name="forcepair" class="medium" type="text" maxlength="2" value="##FORCEPAIR##"></TD></TR>
+				<TR><TD><A>Force OTP CSC (optional):</A></TD><TD><input name="otpcsc" class="medium" type="text" maxlength="4" value="##OTPCSC##"></TD></TR>
+				<TR><TD><A>Force OTA CSC (optional):</A></TD><TD><input name="otacsc" class="medium" type="text" maxlength="4" value="##OTACSC##"></TD></TR>
+				<TR><TD><A>CaID BoxEMM:</A></TD><TD><input name="cwpkcaid" class="medium" type="text" maxlength="4" value="##CWPKCAID##"></TD></TR>
+				<TR><TD><A>OTA (Over-The-Air) CWPK:</A></TD><TD><input name="cwpkota" type="hidden" value="0"><input name="cwpkota" type="checkbox" value="1" ##CWPKOTACHECKED##><label></label></TD></TR>
+				<TR><TD><A>CWPK0:</A></TD><TD><input name="cwekey0" class="longer" type="text" maxlength="32" value="##CWEKEY0##"></TD></TR>
+				<TR><TD><A>CWPK1:</A></TD><TD><input name="cwekey1" class="longer" type="text" maxlength="32" value="##CWEKEY1##"></TD></TR>
+				<TR><TD><A>CWPK2:</A></TD><TD><input name="cwekey2" class="longer" type="text" maxlength="32" value="##CWEKEY2##"></TD></TR>
+				<TR><TD><A>CWPK3:</A></TD><TD><input name="cwekey3" class="longer" type="text" maxlength="32" value="##CWEKEY3##"></TD></TR>
+				<TR><TD><A>CWPK4:</A></TD><TD><input name="cwekey4" class="longer" type="text" maxlength="32" value="##CWEKEY4##"></TD></TR>
+				<TR><TD><A>CWPK5:</A></TD><TD><input name="cwekey5" class="longer" type="text" maxlength="32" value="##CWEKEY5##"></TD></TR>
+				<TR><TD><A>CWPK6:</A></TD><TD><input name="cwekey6" class="longer" type="text" maxlength="32" value="##CWEKEY6##"></TD></TR>
+				<TR><TD><A>CWPK7:</A></TD><TD><input name="cwekey7" class="longer" type="text" maxlength="32" value="##CWEKEY7##"></TD></TR>
+
diff --git a/webif/readerconfig/readerconfig_ncd524bit.html b/webif/readerconfig/readerconfig_ncd524bit.html
index 6c1233bc..8bf83c3a 100644
--- a/webif/readerconfig/readerconfig_ncd524bit.html
+++ b/webif/readerconfig/readerconfig_ncd524bit.html
@@ -1,3 +1,12 @@
+			<TR><TD><A>AU NAGRA type:</A></TD>
+					<TD>
+						<select name="autype">
+							<option value="0" ##AUTYPE0##>0 - Standard</option>
+							<option value="1" ##AUTYPE1##>1 - For Seca/Nagra cards</option>
+							<option value="2" ##AUTYPE2##>2 - For CAK7 cards</option>
+						</select>
+					</TD>
+			</TR>
 			<TR><TD><A>User:</A></TD><TD><input name="user" class="longer" type="text" maxlength="50" value="##USERNAME##"></TD></TR>
 			<TR><TD><A>Password:</A></TD><TD><input name="password" class="longer" type="text" maxlength="50" value="##PASSWORD##"></TD></TR>
 			<TR><TD><A>Key:</A></TD><TD><input name="key" class="longer" type="text" maxlength="28" value="##NCD_KEY##"></TD></TR>
diff --git a/webif/readerconfig/readerconfig_ncd525bit.html b/webif/readerconfig/readerconfig_ncd525bit.html
index 6c1233bc..8bf83c3a 100644
--- a/webif/readerconfig/readerconfig_ncd525bit.html
+++ b/webif/readerconfig/readerconfig_ncd525bit.html
@@ -1,3 +1,12 @@
+			<TR><TD><A>AU NAGRA type:</A></TD>
+					<TD>
+						<select name="autype">
+							<option value="0" ##AUTYPE0##>0 - Standard</option>
+							<option value="1" ##AUTYPE1##>1 - For Seca/Nagra cards</option>
+							<option value="2" ##AUTYPE2##>2 - For CAK7 cards</option>
+						</select>
+					</TD>
+			</TR>
 			<TR><TD><A>User:</A></TD><TD><input name="user" class="longer" type="text" maxlength="50" value="##USERNAME##"></TD></TR>
 			<TR><TD><A>Password:</A></TD><TD><input name="password" class="longer" type="text" maxlength="50" value="##PASSWORD##"></TD></TR>
 			<TR><TD><A>Key:</A></TD><TD><input name="key" class="longer" type="text" maxlength="28" value="##NCD_KEY##"></TD></TR>
