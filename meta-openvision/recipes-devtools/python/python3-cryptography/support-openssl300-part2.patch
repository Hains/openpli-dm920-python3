diff --git a/src/_cffi_src/build_openssl.py b/src/_cffi_src/build_openssl.py
index 557296e..723f82e 100644
--- a/src/_cffi_src/build_openssl.py
+++ b/src/_cffi_src/build_openssl.py
@@ -79,6 +79,8 @@ ffi = build_ffi_for_binding(
     modules=[
         # This goes first so we can define some cryptography-wide symbols.
         "cryptography",
+        # Provider comes early as well so we define OSSL_LIB_CTX
+        "provider",
         "aes",
         "asn1",
         "bignum",
@@ -104,7 +106,6 @@ ffi = build_ffi_for_binding(
         "osrandom_engine",
         "pem",
         "pkcs12",
-        "provider",
         "rand",
         "rsa",
         "ssl",
diff --git a/src/_cffi_src/openssl/evp.py b/src/_cffi_src/openssl/evp.py
index 2b2f995..735b8c3 100644
--- a/src/_cffi_src/openssl/evp.py
+++ b/src/_cffi_src/openssl/evp.py
@@ -36,6 +36,7 @@ static const int Cryptography_HAS_EVP_PKEY_get_set_tls_encodedpoint;
 static const int Cryptography_HAS_ONESHOT_EVP_DIGEST_SIGN_VERIFY;
 static const long Cryptography_HAS_RAW_KEY;
 static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF;
+static const long Cryptography_HAS_300_FIPS;
 """
 
 FUNCTIONS = """
@@ -269,4 +273,12 @@ static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF = 1;
 #ifndef EVP_PKEY_POLY1305
 #define EVP_PKEY_POLY1305 NID_poly1305
 #endif
+
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+static const long Cryptography_HAS_300_FIPS = 1;
+#else
+static const long Cryptography_HAS_300_FIPS = 0;
+int (*EVP_default_properties_is_fips_enabled)(OSSL_LIB_CTX *) = NULL;
+int (*EVP_default_properties_enable_fips)(OSSL_LIB_CTX *, int) = NULL;
+#endif
 """
diff --git a/src/cryptography/hazmat/backends/openssl/backend.py b/src/cryptography/hazmat/backends/openssl/backend.py
index e2b9962..4dde889 100644
--- a/src/cryptography/hazmat/backends/openssl/backend.py
+++ b/src/cryptography/hazmat/backends/openssl/backend.py
@@ -195,8 +195,9 @@ class Backend(object):
         b"aes-256-gcm",
     }
     _fips_ciphers = (AES, TripleDES)
+    # Sometimes SHA1 is still permissible. That logic is contained
+    # within the various *_supported methods.
     _fips_hashes = (
-        hashes.SHA1,
         hashes.SHA224,
         hashes.SHA256,
         hashes.SHA384,
@@ -210,6 +211,12 @@ class Backend(object):
         hashes.SHAKE128,
         hashes.SHAKE256,
     )
+    _fips_ecdh_curves = (
+        ec.SECP224R1,
+        ec.SECP256R1,
+        ec.SECP384R1,
+        ec.SECP521R1,
+    )
     _fips_rsa_min_key_size = 2048
     _fips_rsa_min_public_exponent = 65537
     _fips_dsa_min_modulus = 1 << 2048
@@ -237,17 +244,34 @@ class Backend(object):
         if self._lib.Cryptography_HAS_EVP_PKEY_DHX:
             self._dh_types.append(self._lib.EVP_PKEY_DHX)
 
+    def __repr__(self):
+        return "<OpenSSLBackend(version: {}, FIPS: {})>".format(
+            self.openssl_version_text(), self._fips_enabled
+        )
+
     def openssl_assert(self, ok, errors=None):
         return binding._openssl_assert(self._lib, ok, errors=errors)
 
     def _is_fips_enabled(self):
-        fips_mode = getattr(self._lib, "FIPS_mode", lambda: 0)
-        mode = fips_mode()
+        if self._lib.Cryptography_HAS_300_FIPS:
+            mode = self._lib.EVP_default_properties_is_fips_enabled(
+                self._ffi.NULL
+            )
+        else:
+            mode = getattr(self._lib, "FIPS_mode", lambda: 0)()
+
         if mode == 0:
             # OpenSSL without FIPS pushes an error on the error stack
             self._lib.ERR_clear_error()
         return bool(mode)
 
+    def _enable_fips(self):
+        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that
+        # have the FIPS provider installed properly.
+        self._binding._enable_fips()
+        assert self._is_fips_enabled()
+        self._fips_enabled = self._is_fips_enabled()
+
     def activate_builtin_random(self):
         if self._lib.CRYPTOGRAPHY_NEEDS_OSRANDOM_ENGINE:
             # Obtain a new structural reference.
@@ -343,14 +367,25 @@ class Backend(object):
         return evp_md != self._ffi.NULL
 
     def hmac_supported(self, algorithm):
+        # FIPS mode still allows SHA1 for HMAC
+        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):
+            return True
+
         return self.hash_supported(algorithm)
 
     def create_hash_ctx(self, algorithm):
         return _HashContext(self, algorithm)
 
     def cipher_supported(self, cipher, mode):
-        if self._fips_enabled and not isinstance(cipher, self._fips_ciphers):
-            return False
+        if self._fips_enabled:
+            # FIPS mode requires AES or TripleDES, but only CBC/ECB allowed
+            # in TripleDES mode.
+            if not isinstance(cipher, self._fips_ciphers) or (
+                isinstance(cipher, TripleDES)
+                and not isinstance(mode, (CBC, ECB))
+            ):
+                return False
+
         try:
             adapter = self._cipher_registry[type(cipher), type(mode)]
         except KeyError:
@@ -766,7 +801,13 @@ class Backend(object):
         if isinstance(padding, PKCS1v15):
             return True
         elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):
-            return self.hash_supported(padding._mgf._algorithm)
+            # SHA1 is permissible in MGF1 in FIPS
+            if self._fips_enabled and isinstance(
+                padding._mgf._algorithm, hashes.SHA1
+            ):
+                return True
+            else:
+                return self.hash_supported(padding._mgf._algorithm)
         elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):
             return (
                 self._oaep_hash_supported(padding._mgf._algorithm)
@@ -1508,10 +1549,12 @@ class Backend(object):
             raise ValueError("Unsupported public key algorithm.")
 
         else:
+            errors = binding._errors_with_text(errors)
             raise ValueError(
                 "Could not deserialize key data. The data may be in an "
                 "incorrect format or it may be encrypted with an unsupported "
-                "algorithm."
+                "algorithm.",
+                errors,
             )
 
     def elliptic_curve_supported(self, curve):
@@ -1793,6 +1836,11 @@ class Backend(object):
         return _OCSPResponse(self, ocsp_resp)
 
     def elliptic_curve_exchange_algorithm_supported(self, algorithm, curve):
+        if self._fips_enabled and not isinstance(
+            curve, self._fips_ecdh_curves
+        ):
+            return False
+
         return self.elliptic_curve_supported(curve) and isinstance(
             algorithm, ec.ECDH
         )
diff --git a/src/cryptography/hazmat/bindings/openssl/_conditional.py b/src/cryptography/hazmat/bindings/openssl/_conditional.py
index 1f42c7b..dfddafb 100644
--- a/src/cryptography/hazmat/bindings/openssl/_conditional.py
+++ b/src/cryptography/hazmat/bindings/openssl/_conditional.py
@@ -280,6 +280,13 @@ def cryptography_has_providers():
     ]
 
 
+def cryptography_has_300_fips():
+    return [
+        "EVP_default_properties_is_fips_enabled",
+        "EVP_default_properties_enable_fips",
+    ]
+
+
 # This is a mapping of
 # {condition: function-returning-names-dependent-on-that-condition} so we can
 # loop over them and delete unsupported names at runtime. It will be removed
@@ -329,4 +336,5 @@ CONDITIONAL_NAMES = {
     "Cryptography_HAS_SRTP": cryptography_has_srtp,
     "Cryptography_HAS_GET_PROTO_VERSION": cryptography_has_get_proto_version,
     "Cryptography_HAS_PROVIDERS": cryptography_has_providers,
+    "Cryptography_HAS_300_FIPS": cryptography_has_300_fips,
 }
diff --git a/src/cryptography/hazmat/bindings/openssl/binding.py b/src/cryptography/hazmat/bindings/openssl/binding.py
index 6dcec26..0193c78 100644
--- a/src/cryptography/hazmat/bindings/openssl/binding.py
+++ b/src/cryptography/hazmat/bindings/openssl/binding.py
@@ -119,6 +119,22 @@ class Binding(object):
     def __init__(self):
         self._ensure_ffi_initialized()
 
+    def _enable_fips(self):
+        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that
+        # have the FIPS provider installed properly.
+        _openssl_assert(self.lib, self.lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER)
+        self._base_provider = self.lib.OSSL_PROVIDER_load(
+            self.ffi.NULL, b"base"
+        )
+        _openssl_assert(self.lib, self._base_provider != self.ffi.NULL)
+        self.lib._fips_provider = self.lib.OSSL_PROVIDER_load(
+            self.ffi.NULL, b"fips"
+        )
+        _openssl_assert(self.lib, self.lib._fips_provider != self.ffi.NULL)
+
+        res = self.lib.EVP_default_properties_enable_fips(self.ffi.NULL, 1)
+        _openssl_assert(self.lib, res == 1)
+
     @classmethod
     def _register_osrandom_engine(cls):
         # Clear any errors extant in the queue before we start. In many
diff --git a/tests/conftest.py b/tests/conftest.py
index 43debdd..32a4f03 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -10,6 +10,11 @@ from cryptography.hazmat.backends.openssl import backend as openssl_backend
 from .utils import check_backend_support
 
 
+def pytest_configure(config):
+    if config.getoption("--enable-fips"):
+        openssl_backend._enable_fips()
+
+
 def pytest_report_header(config):
     return "\n".join(
         [
@@ -21,6 +26,7 @@ def pytest_report_header(config):
 
 def pytest_addoption(parser):
     parser.addoption("--wycheproof-root", default=None)
+    parser.addoption("--enable-fips", default=False)
 
 
 def pytest_runtest_setup(item):
diff --git a/tests/hazmat/primitives/test_dh.py b/tests/hazmat/primitives/test_dh.py
index bb29919..8afdc54 100644
--- a/tests/hazmat/primitives/test_dh.py
+++ b/tests/hazmat/primitives/test_dh.py
@@ -674,6 +674,7 @@ class TestDHPublicKeySerialization(object):
         pub_num = key.public_numbers()
         assert loaded_pub_num == pub_num
 
+    @pytest.mark.skip_fips(reason="non-FIPS parameters")
     @pytest.mark.parametrize(
         ("key_path", "loader_func", "encoding", "is_dhx"),
         [
@@ -717,6 +718,7 @@ class TestDHPublicKeySerialization(object):
         )
         assert serialized == key_bytes
 
+    @pytest.mark.skip_fips(reason="non-FIPS parameters")
     @pytest.mark.parametrize(
         ("key_path", "loader_func", "vec_path", "is_dhx"),
         [
diff --git a/tests/hazmat/primitives/test_pkcs12.py b/tests/hazmat/primitives/test_pkcs12.py
index b5de09f..96b3856 100644
--- a/tests/hazmat/primitives/test_pkcs12.py
+++ b/tests/hazmat/primitives/test_pkcs12.py
@@ -70,7 +70,6 @@ class TestPKCS12Loading(object):
         only_if=lambda backend: backend.cipher_supported(_RC2(), None),
         skip_message="Does not support RC2",
     )
-    @pytest.mark.skip_fips(reason="Unsupported algorithm in FIPS mode")
     def test_load_pkcs12_ec_keys_rc2(self, filename, password, backend):
         self._test_load_pkcs12_ec_keys(filename, password, backend)
 
@@ -167,6 +166,9 @@ def _load_ca(backend):
     return cert, key
 
 
+@pytest.mark.skip_fips(
+    reason="PKCS12 unsupported in FIPS mode. So much bad crypto in it."
+)
 class TestPKCS12Creation(object):
     @pytest.mark.parametrize("name", [None, b"name"])
     @pytest.mark.parametrize(
diff --git a/tests/hazmat/primitives/test_pkcs7.py b/tests/hazmat/primitives/test_pkcs7.py
index 6bc65ee..2f1ecb3 100644
--- a/tests/hazmat/primitives/test_pkcs7.py
+++ b/tests/hazmat/primitives/test_pkcs7.py
@@ -331,6 +331,9 @@ class TestPKCS7Builder(object):
     def test_sign_alternate_digests_der(
         self, hash_alg, expected_value, backend
     ):
+        if isinstance(hash_alg, hashes.SHA1) and backend._fips_enabled:
+            pytest.skip("SHA1 not supported in FIPS mode")
+
         data = b"hello world"
         cert, key = _load_cert_key()
         builder = (
@@ -354,7 +357,12 @@ class TestPKCS7Builder(object):
             (hashes.SHA512(), b"sha-512"),
         ],
     )
-    def test_sign_alternate_digests_detached(self, hash_alg, expected_value):
+    def test_sign_alternate_digests_detached(
+        self, hash_alg, expected_value, backend
+    ):
+        if isinstance(hash_alg, hashes.SHA1) and backend._fips_enabled:
+            pytest.skip("SHA1 not supported in FIPS mode")
+
         data = b"hello world"
         cert, key = _load_cert_key()
         builder = (
diff --git a/tests/hazmat/primitives/test_serialization.py b/tests/hazmat/primitives/test_serialization.py
index ca969e0..44bb55a 100644
--- a/tests/hazmat/primitives/test_serialization.py
+++ b/tests/hazmat/primitives/test_serialization.py
@@ -59,8 +59,19 @@ def _skip_fips_format(key_path, password, backend):
     if backend._fips_enabled:
         if key_path[0] == "Traditional_OpenSSL_Serialization":
             pytest.skip("Traditional OpenSSL format blocked in FIPS mode")
-        if key_path[0] == "PEM_Serialization" and password is not None:
-            pytest.skip("Encrypted PEM_Serialization blocked in FIPS mode")
+        if (
+            key_path[0] in ("PEM_Serialization", "PKCS8")
+            and password is not None
+        ):
+            pytest.skip(
+                "The encrypted PEM vectors currently have encryption "
+                "that is not FIPS approved in the 3.0 provider"
+            )
+        if key_path[0] == "DER_Serialization" and password is not None:
+            pytest.skip(
+                "The encrypted PKCS8 DER vectors currently have encryption "
+                "that is not FIPS approved in the 3.0 provider"
+            )
 
 
 class TestBufferProtocolSerialization(object):
@@ -75,6 +86,7 @@ class TestBufferProtocolSerialization(object):
         ],
     )
     def test_load_der_rsa_private_key(self, key_path, password, backend):
+        _skip_fips_format(key_path, password, backend)
         data = load_vectors_from_file(
             os.path.join("asymmetric", *key_path),
             lambda derfile: derfile.read(),
@@ -128,6 +140,7 @@ class TestDERSerialization(object):
         ],
     )
     def test_load_der_rsa_private_key(self, key_path, password, backend):
+        _skip_fips_format(key_path, password, backend)
         key = load_vectors_from_file(
             os.path.join("asymmetric", *key_path),
             lambda derfile: load_der_private_key(
@@ -837,6 +850,7 @@ class TestPEMSerialization(object):
         with pytest.raises(ValueError):
             load_pem_private_key(key_data, password, backend)
 
+    @pytest.mark.skip_fips(reason="non-FIPS parameters")
     def test_rsa_pkcs8_encrypted_values(self, backend):
         pkey = load_vectors_from_file(
             os.path.join("asymmetric", "PKCS8", "enc-rsa-pkcs8.pem"),
diff --git a/tests/wycheproof/test_hmac.py b/tests/wycheproof/test_hmac.py
index bfc6907..84b0c19 100644
--- a/tests/wycheproof/test_hmac.py
+++ b/tests/wycheproof/test_hmac.py
@@ -41,7 +41,7 @@ def test_hmac(backend, wycheproof):
     hash_algo = _HMAC_ALGORITHMS[wycheproof.testfiledata["algorithm"]]
     if wycheproof.testgroup["tagSize"] // 8 != hash_algo.digest_size:
         pytest.skip("Truncated HMAC not supported")
-    if not backend.hash_supported(hash_algo):
+    if not backend.hmac_supported(hash_algo):
         pytest.skip("Hash {} not supported".format(hash_algo.name))
 
     h = hmac.HMAC(
diff --git a/tests/wycheproof/test_rsa.py b/tests/wycheproof/test_rsa.py
index 0b0983d..8694b61 100644
--- a/tests/wycheproof/test_rsa.py
+++ b/tests/wycheproof/test_rsa.py
@@ -104,6 +104,13 @@ def test_rsa_pkcs1v15_signature_generation(backend, wycheproof):
     assert isinstance(key, rsa.RSAPrivateKey)
     digest = _DIGESTS[wycheproof.testgroup["sha"]]
     assert digest is not None
+    if backend._fips_enabled:
+        if key.key_size < 2048 or isinstance(digest, hashes.SHA1):
+            pytest.skip(
+                "Invalid params for FIPS. key: {} bits, digest: {}".format(
+                    key.key_size, digest.name
+                )
+            )
 
     sig = key.sign(
         binascii.unhexlify(wycheproof.testcase["msg"]),
